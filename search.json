[{"title":"PlantUML 使用记录","path":"/2025/12/04/0020-plantuml/","content":"使用 Docker 安装 拉取 PlantUML 的 Docker 镜像 docker pull plantuml/plantuml-server:jetty 运行 PlantUML 服务器容器 docker run -d -p 8080:8080 plantuml/plantuml-server:jetty 访问 PlantUML 服务器 通过浏览器访问 PlantUML 服务器，网址：http://localhost:8080/ 时序图注释信息note left@startumlAlice-Bob : hellonote left: this is a first note@enduml note right@startumlBob-Alice : oknote right: this is another note@enduml end note (多行注释)@startumlBob-Bob : I am thinkingnote lefta notecan also be definedon several linesend note@enduml 对消息序列编号autonumber@startumlautonumberBob - Alice : Authentication RequestBob - Alice : Authentication Response@enduml autonumber inc 要增加第一个数字，请使用：autonumber inc A 。 要增加第二位数字，请使用：autonumber inc B 。 @startumlautonumber 1.1.1Alice - Bob: Authentication requestBob -- Alice: Responseautonumber inc ANow we have 2.1.1Alice - Bob: Another authentication requestBob -- Alice: Responseautonumber inc BNow we have 2.2.1Alice - Bob: Another authentication requestBob -- Alice: Responseautonumber inc ANow we have 3.1.1Alice - Bob: Another authentication requestautonumber inc BNow we have 3.2.1Bob -- Alice: Response@enduml autonumber stop 停止自动编号","tags":["UML"],"categories":["工具"]},{"title":"2025年终总结 (更新中)","path":"/2025/12/02/0019-2025-review/","content":"总结1月 我的第二份工作，结束了 6 个月的实习期后，在 1 月的中旬转正。 2月 去电影院看了《哪吒之魔童闹海》。 3月4月 在成都出差一个月，去了三星堆和都江堰。 5月 还完了最后一笔车贷（历时两年）。 看了一场毛不易的演唱会。 6月 6月末把旧电脑的系统刷成了飞牛 fnOS，感觉挺适合我这种普通玩家的。同时也安装了iStoreOS。 7月 7月中旬租房合同到期，感觉目前的小区环境也还可以，也懒得去找新的房子，所以又续了1年的合同。 7月下旬请了一周的假和媳妇儿去了内蒙古，好凉快。 8月NOTE:牙齿的问题一定要重视！ 前段时间有颗牙齿碎了一点，一直没有管。8月中旬发展成了牙髓炎，第一次刻骨铭心的感受到了牙疼，开始了一个月左右的根管治疗。 9月 9月底心血来潮，再次开始博客的更新。仍然使用 hexo，主题在经过对比后选择了 stellar。 10月 时隔多年，又开始看《名侦探柯南》了，之前应该是看到了基尔篇。 短暂的体验了下顺风车车主的工作，对车主来说感觉并不是真的顺风。 11月 下载了多邻国，开启每日打卡。 开始学习 ebpf 的相关内容，通读了《Learning eBPF》。 12月 找了新的房源，再次开启搬家工作。 复盘关于工作美国心理学家、密歇根商学院教授诺尔·迪奇提出了关于舒适圈的行为改变三圈理论。行为改变三圈理论指出：人对于外部世界的认知，分为三个区域，分别是舒适区、学习区、恐慌区。身处不同的区域，人们的情绪感受是不一样的。当你在舒适区里，你会感到放松舒适，一切应对自如，安全可控；进入学习区，你感到了一定的压力，但总体可控，你相信只要学习提升，就能够应对挑战；进入恐慌区，则意味着你处在完全失控的区域，你感到压力山大、无力应对，内心充满了焦虑不安、紧张害怕。 上一份工作作为初入职场的新人，感觉自己一直处于恐慌区；现在的这份工作，最近给我的感觉总是处于舒适区。","tags":["年终总结"],"categories":["复盘"]},{"title":"租房二三事","path":"/2025/12/01/0018-rent/","content":"毕业到现在租房差不多有三年半的时间，因为各种原因基本每年都会换一次地方。但被坑的比较严重的一次是帮家人短租 1 个月的单间，最后花费 1500 元左右，大概只住了不到半个月，也是目前为止唯一一次和中介打交道。 回顾几次租房经历，其实有很多需要注意的地方，比如每次找房源大概只会花一天到两天左右的时间就做决定。 最近在 v2ex 看到一份租房相关检查单，而最近又在租房，所以想整理下和复盘下租房过程中的一些注意点。 合同房东直租如果是房东直租，可以考虑使用该合同作为模版： 城镇房屋租赁合同（市场监管总局2025版）https://htsfwb.samr.gov.cn/View?id=2340996b-882d-47a4-b74d-c30784628737 中介推荐一定要把合同内容复制给豆包、DeepSeek等AI工具，让AI工具帮助我们指出合同中的一些及其不合理的条款。 结合仅有的一次和中介打交道的经历，中介公司使用的是电子合同，合同的内容冗长，且在手机屏幕上很难有效的阅读其中的内容，普通人也很难发现合同中的一些问题。 记得当时中介把合同发给家人之后，家人直接说还用看吗？谨慎起见，我通读了一遍合同内容，但还是没能看出问题。后来把合同内容发送给豆包，发现里面其实有许多及其不合理的条款，中介公司也是基于这些条款坑害租户。 可以询问豆包、DeepSeek等AI工具以下问题： 该合同是否有什么不合理的条约或要求 签约签约前，一定要核验出租人的身份证件、房屋权属证明，确认房屋属于可租赁的房屋且出租人有权出租房屋，并注意留存复印件。 租房的过程中，租客会被索要身份证复印件信息，我们也应该索要房东或中介的身份证复印件信息。还是和中介打交道那次，由于和我们见面的人属于中介的中介，所以问题出现后，我们连人也找不到，只有一个手机号（当然，是打不通的）。 租房检查单可结合实际情况进行增删和修改： 租房相关检查单https://www.v2ex.com/t/1175331","tags":["日常生活"],"categories":["V2EX"]},{"title":"VLAN","path":"/2025/11/19/0017-vlan/","content":"VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的 LAN 在逻辑上划分成多个广播域的通信技术。 VLAN 技术可以把一个物理局域网划分成多个逻辑局域网，即多个 VLAN。每个 VLAN 是一个广播域，使得 VLAN 内的主机可以互通，而 VLAN 间不能直接互通。这样，广播报文被限制在一个 VLAN 内，同时提高了网络安全性。 VLAN 标签当一个局域网被划分为多个 VLAN 时，每个 VLAN 都用一个唯一的 VLAN 标签来标识。VLAN 标签也称为 VLAN Tag 或 802.1Q Tag。 IEEE 802.1Q 标准对传统 Ethernet 帧格式进行了修改，在源MAC地址字段和协议类型字段之间加入 4 字节的 802.1Q Tag，形成了 VLAN 的帧格式。 TPID：Tag Protocol Identifier，用来判断本 VLAN 帧是否带有 802.1Q Tag，缺省取值为 0x8100，表示 802.1Q Tag 帧。 PRI：Priority，表示帧的优先级，取值范围为0-7，值越大优先级越高。用于当设备阻塞时，优先发送优先级高的数据帧。 CFI：Canonical Format Indicator，表示MAC地址是否是标准格式，取值范围为0或1，缺省取值为0。取值为0表示MAC地址以标准格式封装，取值为1表示MAC地址以非标准格式封装。 VID：VLAN ID，表示该帧所属的VLAN，取值范围为 0-4095。由于 0 和 4095 为协议保留取值，所以VLAN ID的有效取值范围为 1-4094。 数据帧分类数据帧根据是否携带 VLAN Tag，分为以下两种形式： Tagged 帧 有标记帧 加入了 4 字节 802.1Q Tag 的帧 Untagged 帧 无标记帧 原始的、未加入 4 字节 802.1Q Tag 的帧 链路类型VLAN 组网中的链路包括： Access Link 接入链路 连接不能或不需要识别 VLAN Tag 的终端设备 Trunk Link 干道链路 其上通过的数据帧都必须打上 VLAN Tag 接口类型根据对 VLAN 帧的识别情况，将接口分为以下几类： Access 接口 用来连接终端设备的接口，这些终端设备不能或者不需要识别 VLAN Tag 如果该接口收到 Untagged 帧，设备将强制加上该接口的 PVID（缺省VLAN） 如果该接口收到 Tagged 帧，只允许 VLAN ID 与接口的 PVID（缺省VLAN）相同的 VLAN 帧通过 Access 接口发送的数据帧永远是 Untagged 帧 Trunk 接口 允许多个 VLAN 的 Tagged 帧通过 该接口发送的帧，VLAN ID PVID 的是 Untagged 帧，其它 VLAN 的帧都必须是 Tagged 帧 Hybrid 接口 允许多个VLAN 的 Tagged 帧通过 在出接口方向可根据需要设置某些 VLAN 内的帧带 Tag，某些 VLAN 内的帧不带 Tag QinQ 接口 给数据帧加上双重 VLAN Tag 缺省 VLANPVID (Port Default VLAN ID) Access接口只属于1个VLAN，它的缺省VLAN就是它所在的VLAN。 Hybrid 接口和 Trunk 接口属于多个 VLAN，但是缺省VLAN只有1个，所以需要设置缺省VLAN。 同一 VLAN 内的互通同设备 VLAN 内互通用户主机 Host1 和 Host2 连接在同台设备上，属于同一VLAN2，且位于相同网段，连接接口均设置为Access接口。 跨设备 VLAN 内互通用户主机Host1和Host2连接在不同的设备上，属于同一个VLAN2，且位于相同网段。为了识别和发送跨越设备的数据帧，设备与设备间通过 Trunk link 连接，且允许携带 VLAN2 的报文通过。 不同 VLAN 间的互通同设备VLAN间互通（VLANIF接口）用户主机Host1和Host2连接在同台设备上，分别属于VLAN2和VLAN3，并位于不同的网段。在DeviceA上分别创建VLANIF2和VLANIF3并配置其IP地址，然后将用户主机的缺省网关设置为所属VLAN对应VLANIF接口的IP地址。 跨设备VLAN间互通（VLANIF接口）由于VLANIF接口的IP地址只能在设备上生成直连路由，当不同VLAN的用户跨多台设备互访时，除配置VLANIF接口的IP地址外，还需要配置静态路由或运行动态路由协议。 用户主机Host1和Host2连接在不同的设备上，分别属于VLAN2和VLAN3，并位于不同的网段。 主机与设备之间使用Access接口，设备之间使用Trunk接口。 在DeviceA上分别创建VLANIF2和VLANIF4，配置其IP地址为10.1.1.1和10.1.4.1；在DeviceB上分别创建VLANIF3和VLANIF4，配置其IP地址为10.1.2.1和10.1.4.2 在DeviceA和DeviceB上分别配置静态路由。DeviceA上静态路由的目的网段是10.1.2.024，下一跳是10.1.4.2；DeviceB上静态路由的目的网段是10.1.1.024，下一跳是10.1.4.1。 同设备VLAN间互通（三层子接口）用户主机属于不同的VLAN，并位于不同的网段。 其中，Host1和Host2属于VLAN2，Host3和Host4属于VLAN3，DeviceA通过以太网接口interface1与DeviceB相连。 在DeviceA的interface1上创建2个子接口interface1.1和interface1.2，并配置802.1Q封装与VLAN2和VLAN3分别对应。 配置子接口的IP地址，保证两个子接口对应的IP地址路由可达，并将用户设备的缺省网关设置为所属VLAN对应子接口的IP地址。","tags":["计算机网络"],"categories":["Linux"]},{"title":"时间轮","path":"/2025/11/13/0016-time-wheel/","content":"为什么使用时间轮基于链表排序的定时器使用唯一的一条链表来管理所有定时器，插入操作的效率随着定时器数目的增多而降低。 时间轮使用哈希表的思想，将定时器散列到不同的链表上，这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响。 时间轮的原理时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot 槽位。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用链表结构保存该时间段到期的所有任务。时间指针随着时间增加逐个slot 转动，并执行 slot 中的所有到期任务。 任务如何加入根据任务的到期时间进行取模，将任务分布到不同的 slot 中。如图所示，时间轮被划分为 8 个 slot，每个 slot 代表 1s，当前时针指向 2。 假如现在需要调度一个 3s 后执行的任务，应该加入 2+35 的 slot 中；如果需要调度一个 12s 以后的任务，需要等待时针完整走完一圈 round 后再走 4 个 slot，需要放入第 (2+12)%86 个 slot。 当时针走到第 6 个 slot 时，怎么区分每个任务是立即执行，还是需要等待下一圈，甚至更久时间之后执行呢？因此需要把 round 信息保存在任务中。 例如图中第 6 个 slot 的链表中包含 3 个任务，第一个任务 round0，需要立即执行；第二个任务 round1，需要等待 1*8=8s 后执行；第三个任务 round2，需要等待 2*8=8s 后执行。所以当时针转动到对应 slot 时，只执行 round0 的任务，slot 中其余任务的 round 应当减 1，等待下一个圈之后执行。 定时器类class tw_timer public: tw_timer(int rot, int ts) : rotation(rot), time_slot(ts), next(nullptr), prev(nullptr) private: int rotation; /* 记录定时器在时间轮转多少 round 后生效 */ int time_slot; /* 记录定时器属于时间轮上哪个 slot*/ void* user_data = nullptr; /* 客户数据 */ void (*cb_func)(void* ); /* 定时器回调函数 */ tw_timer* next; /* 指向下一个定时器 */ tw_timer* prev; /* 指向前一个定时器 */; 多级时间轮todo","tags":["时间"],"categories":["编程"]},{"title":"iptables 和 netfilter","path":"/2025/11/11/0015-netfilter/","content":"iptables 和 netfilter 是一套 Linux 防火墙组合工具，共同合作完成系统的防护工作。 iptables 是客户端工具，netfilter 是服务端程序， iptables 工作在用户态，netfilter 工作在内核态， 用户可以通过 iptables 命令作用到服务端的 netfilter，netfilter 触发相应的回调函数（hook 机制）执行相应的防护动作。 五链netfilter 是 Linux 内核中内置的网络数据包处理框架，提供了 5 个 hook 点，当网络包在协议栈中流转到这些 hook 点时，就会依次执行在这些hook 点上注册的各种规则，进而实现对网络包的各种处理。 PRE_ROUTING 通过数据链路层解包，进入网络层的数据包通过该 hook 点 所有接收数据包到达的第一个 hook 点 此处可以进行数据包目的地址转换（DNAT） LOCAL_IN 经过路由查找后，目的地址是本机的数据包，会到达该 hook 点 IP_FORWARD 进过路由查找后，目的地址不是本机地址的数据包（即转发的数据包），会到达该 hook 点 LOCAL_OUT 所有本地生成的发往其它机器的数据包，在进入网络栈后首先到达该 hook 点 POST_ROUTING 本机产生准备发出的数据包或转发的数据包，在经过路由判断后，会到达该 hook 点 四表每个 hook 点可以注册各种规则，这些规则根据用途的不同，可以分为 4 个表，分别是 raw 表，mangle 表，nat 表和 filter 表。 每个链中的表，按照下面的优先顺序进行查找匹配： raw mangle nat filter raw 表 用于决定数据包是否被连接跟踪机制处理 mangle 表 用于数据包的拆解、修改、再封装 修改包的 IP 头 nat 表 数据包的网络地址转换 filter 表 用于数据包过滤，判断是否允许一个包通过","tags":["计算机网络"],"categories":["Linux"]},{"title":"每天最重要的2小时 - 05","path":"/2025/11/05/0009-two-awesome-hours-05/","content":"对工作环境做出理性的选择，选择那些能够让我们更加专注、更加深入思考的环境。 声音对工作效果的影响一些基本的建议，能够让你在关键时刻保持专注： 一个独立的、远离噪声干扰的环境能够大大提高工作成效 如果无法离开办公环境，那就戴上降噪耳塞吧 不要听音乐或脱口秀节目 如果在家办公，就把电视关上 如果要完成的这项任务需要发挥创造力，那就不要抗拒背景噪声，可以考虑去一家忙碌的餐厅或者咖啡馆，要么放点音乐也不错 早早起床，先在家工作一两个小时，然后下午早点下班，来弥补早上在家的工作时间。 光线对工作效果的影响蓝色光和明亮的白光似乎都能增强大脑的一些功能，并帮助我们更有效地工作。 在需要有良好表现的时候，可以做一下这些事： 多开灯。 在天气晴朗时找一处有充足自然光的地方，然后在那里工作。 把灯泡换成偏蓝光的。 如果需要完成一项需要创造力的工作，把灯调暗一点，或者找个比较昏暗的角落。 可以通过以下方法对自己的办公空间做出改变： 清理杂乱无章的东西。在心理能量不足以做某些难度较高的工作时，就可以清理它们，比如下午或傍晚。 把电话、水杯或其他工作相关的物品放到桌子的四个角上。 不要在桌子边坐太久。 摆放点植物或者水景画。 想象自己正坐在桌子前一张舒服的椅子上，有足够的空间能让你把椅子往后推，把脚跷起来。做这种扩张性、开放性的姿势，并且保持两分钟，就能够提高睾丸酮水平，并较低皮质醇激素水平，这会让人们更乐意冒险。 把物品放在伸手才能够得着的地方。 在跑步机上走路或出门散个步，能够提高人们的创造力。 结论：与你周围的环境协同工作反思考研期间一直不习惯晚上熬夜，听到某个考研老师说可以不熬夜，然后早上四五点钟起床。不过现在对我来说早起似乎也有些困难。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"每天最重要的2小时 - 04","path":"/2025/11/04/0009-two-awesome-hours-04/","content":"当希望在提前安排的任务中或者某些特殊时刻达到自己最好的精神状态，利用身体活动和食物的即时反应来增强你的心理功能。 我们的身体状况可以影响到精神状况，改变你身体的感受，就有可能改变你的心理状态。 运动对精神状态的影响身体上的运动也会在短期内对你的心理表现产生作用。 运动半小时左右可以即刻且连续地提升执行功能。能够让你地注意力更加敏锐，让你更专注，让你的血糖值稳定下来，降低焦虑水平，增强积极的情绪和感受。 不论现在有没有坚持有规律地锻炼，都可以在需要的时候利用运动来提升自己的思考能力和心理能量。 一些非常有用的运动： 如果没法集中精神，就走出办公室，快速行走 30~40 分钟，上下楼梯 20~30 分钟。 把有挑战性或者会让你焦虑的会面安排到一段适中的锻炼之后。 当日程表上有项极具挑战性或者令人疲累的工作时，要么在那之前进行一场早锻炼，要么就在完成任务后立刻运动一下。 需要制造“高效两小时”的时候，就在之前的一两个小时内运动 20~40 分钟. 饮食对精神状态的影响升糖指数低的早餐更能帮助孩子们提升执行功能，而提升效果最明显的时段出现在早餐后的两个小时内。 即使是那些健康的年轻人，只要体内2%的水分流失，就会对注意力和短期记忆力造成损伤。 小贴士： 只吃半份早餐或午餐，把剩下的一半留到两个小时之后再吃。 一份富含碳水化合物的零食也许能帮助你在15分钟内集中注意力，并且让你感觉良好。 吃一些含有蛋白质、含糖指数低的碳水化合物和健康脂肪的饭菜、零食。 当你非常忙的时候，坚果是零食的最佳选择。 不要傻乎乎地大吃一顿全是由碳水化合物组成的饭。 如果在过去一两个小时内没有喝水，或者刚刚做过运动，那就赶紧喝水。 如果很疲惫或者睡眠不足，那就喝点含咖啡因的饮料，但不要喝太多。 结论：主宰自己的感受我们可以根据自己希望大脑在饮食或运动后如何运转，来决定自己要吃什么或何时运动。 反思最近总是在晚上运动完之后，就立即开始整理读书笔记。 运动后及时补水。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"每天最重要的2小时 - 03","path":"/2025/11/03/0009-two-awesome-hours-03/","content":"我们需要让自己的思绪乱飞。 大脑天生无法长时间保持专注从进化的角度来讲，如果不做到这样，我们人类就很难生存下来。 把那些没必要存在的和会让你分心的东西都拿开。 拿开办公地点的干扰物如果想要最大限度地专注于某件事， 尽量降低噪声，尽可能地关掉各种设备。 把你的设备都收起来，或者至少放在隔着几米远的地方。 没必要当个从人群中消失的隐士，只要找个办法，也许只要能让这些设备在20分钟内不会令你分心就可以。 冥想练习能够让大脑更有效地保持注意力。 走神的重要性走神对于认知性任务（创造性地解决问题和做出长远计划）有很重要的作用。 如果想要解决一些特别难的问题，不妨让你的思绪飘飞一会儿，琢磨一些难度不高又不相干的简单工作，这能帮助你找到更具有创造性的解决之道。 在专注于某个问题一段时间之后，转换到另一个从认知角度上讲难度适中的任务 – 但不能选择某个需要利用到工作记忆的任务 – 然后再转回到最初想要解决的任务。 比如： 欣赏墙上的画、房间里的植物、窗外的风景，或是你桌上的照片，注意各种颜色的深浅 整理桌面和书架，把桌子擦干净 听音乐，注意聆听这首曲子里用到了那些乐器 玩个小游戏，比如只要看到有人一边走一边发短信，就在纸上画一笔 不建议在走神时做以下事项： 整理文件 看新闻或博客 查阅和回复邮箱 排练你要演示的PPT，或者为某个会议做准备 研究一个高难度问题，比如填字游戏或者数学难题 “觉察注意力”，放任自己走神，在觉察到我们的思绪飘走了之后，再温和地把它们带回我们再眼下所进行的事情上来。 不要理会那些不能帮助你继续完成任务地想法，就像冲浪者们放弃不够合适的海浪一样。 大脑会产生各种想法，你并不需要对每个想法都做出反应。 结论：给自己一个喘气的机会反思工作时把手机放在视线外的地方。 尝试冥想练习。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"Linux 系统中常用的时间操作函数","path":"/2025/11/03/0014-time/","content":"ef77cdfd35a516030a30622d6798f966922f09fa54d377420ff3f0fc2944db5b883f34d1acc43189aad7e189bb52aa7f01f63e95133dfdb4a8517b8c8eed389ecbcc216614bf14afa2364a29099391971d3f3332d2eafe6cf0680bd7b20512ca17993dc180ec3ab0a4016db97acc4938d032726d128e25795ec607fec28a3354e1151f9a576d06bb1bea4e18df27253b711d47ea1c5e56894d52f6e9e23e417e3c7726d6bd9b3e1bef4084155c84006b5e1fbdd15584af5f991c58786d9893cd42ffe10bab0d350c6da9e8f095901620bc5b3bc65c0c35ba05eec27cfbb250ef274e716646021aedf44af33ca4561da947e6b730e3644c0f0629da552c4b460de3c28edbd6c62a6d280d413cdae9aaecdac783a65797b4c04582f4d8c96294965ebc8e42363854d4a4529037d9bafdcf5e1bcc06d404dd7c15b4474580af3f70e87ac1c593b5c08adb657f8989487e28ecda0331a402d166814102fe4c117d8cc12b2bd8769917db9916e52372eac3b49f33e086cf9abf1e1dde5c535425268a39b748cfe175fce6723cc692b830c43da307482b0ca202eb12f99193e1d1e4778232567260b72dabbce06a62c3c8f3eb266e1a41b25634d1c4e2e7e463d0398dea5fa12234c67f8ed8044616ad54fd923fb26467eeb8993de927e736e664639b82f9c836945c6ebfd0c5c1846ba36d57ddfe079d876ea6fd58799e8be728f966bb5dda97090a36b3a46ee43be1d09bac6bcb934118204142e0023492af15dfc12ca0abfd95d1318214cef542106175645eb63c0ab6e439569e58bfa5936dc5577b8fa052474331a212b8d4405a0665f8ac65894dbdd0e6400f7945a5d41383fa58d5cbd04ce173ee080d5b05542e8d4dd84cccaaa3e790c07534fc5fee5be5f480ac4f7ef2a11976ab6ef3d192f9f23078bf78038867b90b4417f3741ca0e7b74648df5030210293f4fd2f190bd85e9b521ad88db01c4ef4d2c92c2d46465678b3ddb207571da7fa51d7426ae96f800fa2cd3afaaca0e2e1d356b2245d91e2770e1c1dd88f856c41496f5a2100c5651e4efd52ce3b2a82f41eeba106ec52a917e1c0ade33a53109e3c253d56a034f3d85117482773dec2ea33bd002005d8d2e5484f6af95dec4fa7e26437ae0b61622dfd528ce3e2d1cce170db30ef1eb821438d481d7cbb55eab4a3bd98d007f986ff7a7de304b72853a7184f232abdebbf1d2e3e40bc1073f79a512442e7281f4a55c634f45d65b6a00579029459794318ed536c1ddc461d0ed85f096bc45dde5ee290f0b7cf733340b6f11143472a8eb4b883badd64363fef69e8d6d48d893de27e9bfca981036d07429d152deb3cefacf5a74a16a36a3bfed860583146168c2e4abfdf7944b82898f3ea5b5517687c812b89a481808f92f05697ce3b06b9780758b7d195ee7cc54a0edeec6024ebdd6b805ce38b340d6267aab3a63e82f996ccb943030dc822a8437c38e834f51950d74625265d1d69e60af423762e9d9adbd8d764b149da9890d61be7d39843d6339622e455c17fc88ee1844e586883d99c4775806b277f4b04f824301898f6cb2228025f7d55efbae07a4665f0f9d4033d38c28cb8e3e365cb1bffe92563049fc79eeb913b7ceb481689e664bdcc5de26c18704ee342c31d60b4c58f824d585e2a26f7bad7ff5fc76732e90a0862688130c26c58a4724cb65790142cc1b5392f5d3f63938c179565797fae36e8651660b1c38e007414735b3d509c9f8ae1ca069b4d199c2e66586283aa8bc2a375309a5fed67d17691c0e4f76997b3d2919129b546a188de468c7186f2132f458b19d4b9ad97a2844f33a7de147e33aa6cbf678f7610107fa2d5dcbc16516da19a9dd42132842895ab67c6628f8ec72064e3c34a88b4f5efaad327c5657ad2f42e5f0f106dd5728d9542b6be992c59628c08b75f16e33bdebd7160bcd9d47a1bbebe2684fa71d94b578bd9bfbee68639180fe0fdb682b68442470d6e978d43a09ab025f3d620dfc3c461559fdb21366a6d48302bc09b32779823cf5cde9edfcb2a2ce2d04217d83559dcbe226e0e1ecfc5e5d98bcc0de4c8c57d08e1aa161a0c968bf32f9b12bcc4d44ae4f2fdf27ef17519522bb81bd1e84cce07fd35d5ab5555bcdf5db8bb0d12430e091bab1e082f31cb091728aa556d59758b222a1d7293a27c6b8a8f0826d85460eef4e72a56480759a1d7e71ae5c5e073df8c64ef2d15a0f0954e6bf503c6ec47aa345e076ff1d8a7b5e8c9b536e79040eb83affc27fb80ce3e72184477a01ec42ed7bbf6b86dd23f4ad5946a62a39a62dbe78226487fbfd8faf5976f43abc013dc356ae724a9b1887f0295ff3e2b4ef491ef912776e0857ee73fbb8436e856c49fba59bfd2470032ca08001ec6a4fa9b6f8adfee825537cd51b3be57e26f7b45debdfcd89ffb7f7c294e6c326242b29102cbf65914da19a653847e3474689d21150a09043e61cc9ff1b849559b5ec51f0d4c53705a0ec49724dde5c7485f969327fb4593a31b5f1f39fc20ece38b3f393cae1acc87a29ddff8c8ce0f14fd943a9cf4e727bfc5cfdfe3196ebce955db091bf1f61748c20dd07372c90d768764af25fc4dcd341dfb520564b46d38566b92c5e991303397493ca1304d55acd7945334155398e0142d74d3e89d02e1420db9cd3bdb46303d298221cc758d408afb1ae8ff78f10e7dccac72de7a8366f2a30dbbadbc01163b35aa0f1725b0ec5724ef2d3940af5cf092eab0f47bf71cb9b0f81d93a66186f04078f5d1e0149ab9dee1904fe7b14d5b521ee9a27ebd8752888fe967cad8123d82fc44e7c1626542bfee351eb89c717784e71ef0322255be2a8de4307af0a299cb7d0ec7d5e09b9afb948e2f5b95402a3faa821fb79fdf89662a7e1201cfa3c3c26399878eda6132e765990cae9fa9a5d019135d678a549bc3be3a8fb217cd92d32f517767bbe976cfd5abbbca560ef77c7deba57d357ca291f8400dd2f056f59ca6c27ca655b654d133bcb3324551594feac06663e7e6226d2cecb9309fb241df2763622a9399a00d8ab334d83dc8b175b6627ad5919c30841881d8bfd97737b3348fdfe9257e4d056eba1334f5ef94b97f94c04f553819837b7e5ca5fb37690c45851685c6a93153fb50b20c37addbe0678d777c242af49e1e27ec931e957f8f4917f966c992212b08ad9845e50f38e80b7b2e807d07192f89a941b15ae96a40b1744a7c2e41bde9c48fcbbd4e1426ed07b7de90ff042e5a69e4f67ae34a38c50745ee2c0aed61372ea6edf355fdc40d8a3b188839fdcd0233fc788b18c737225ced709defa6793c8b26631e1a8232b1459681c8dc1cb7c66500151a6675a4fbeabcc410a4cb198f93341047100b36d090abd4eb04139a0b0ccc441569430a62a194869905cd55dabe5f9e7cac96c4d8842a2d09f230222efdf46d9d987dbc55fd43fd4ffaaba0460b78c407282917c38fdb73022e7a99adebe091da8b11fc527926180bb81baa2a00abbb651cb2a7507e1533d082f1f509ef93c86b196756b8862a99c10924df720983fe4ffe5b2674c053d6a3e4d834c9c5530431d08f20c85df2b05d21907629d0a5c051d6289988d0383b91969ff2ab17120fe25f3703df54cf2cd580aa00fb0461f6131bbedd1dc1952ba9e7739a993a82769c097e837ba68ce5e00818a7a8913211c105e757beefd58ee1bfb6e8599c57ab9817e38f8eb72ae82d811a4813693d8bf6168530ddebd8c2c6771a4d862fd86f7764f8081709f74ab76ff91e0ec66b96b7d0916bdc825e577a8c1ffc19db0d24c5e07c6a9971d2137bed9b2fd2ff3ef460fe3d7d787d21b804ee42112e4b0e3c62e89ff7ff67e831ed6d59b1fc17546c68f807c765fb30ba2dae41d7f7e7e464851524a7753d67617ffeb229cbde5da2f607581c607970850ec56726eedde02782b8583bb2f7a0631066389330fa09d8965778b09194d3bdf91ec27490ad567fdd4487a277d71a5776f807823856fde4ac641333e239951598751bb63c0ee93693ad4a34bf1b90d18226da35dfc50f01d5c5efddac0224fefe3053ff1a0d8a5bcc455bb34a8d47fe80a9de70163d7d78316e53899461f8aa6d981526acaed97e8482cc865136586e07f0a713c1d8d6733b90ab0ba19bf0cedfb07334889ce14ea9ad68d16c5ca8ab193caa33c9a8c752d6ea89d763bc652b5c896ed6bcd7e5d56ce070d9f8a49a6a38db53b762eba15fd69bc812d7bc0f1246dfa2d9300b26b3b70dd5adcacfc1a00dff01b4b973ef3c4a5d373b18b78a3badaf6e51c565f1150142cb9f49401c5906953e082bad3789a21a943c7eb0b50350c405849bb3a2e289f95fa9af0d6e5b021397b015d19f64bcaf38ac969e1cfc997410e15e1a6b19f5dd98f176ac601ae24f28ac8481afce5414977163ffeb755f254be235f2c126b5b6a2b4ce5cd46562d4a91147249ea00f636c7d31ad075766799f7a9e1170fd721d7735a76ffc7fc95323dad15aa147b2a83e01a4e6d5f3e01e18e07540bf0b05d302fc5aaf5be1311b99a4cc105d62312af31cf31b1fec608209450853abc6ed12efbea72b39bd028e07b77fce1ce40754e2d111e003f0aed56f8138d59e8889df03573dae3d162462b05bdb2b2afbaa701ef1f2efd6e7dfb58b60c9de4d72c9029c548958d2ea902d03148a9e374cd2bfeb0b82409ceea0b44e2398dd20647eaf3d42e2fd328b4b8a786ab1a7bf24ac7272325772318307432d7483a7dd95e27f7f97bf2330201f004bb3cb8d1210abfceea0162c8104e1b62a1459e05a738364144009faf62d533e8a8fdc3e8e7e25a42b7b30949c283c796bbff9c3eaa6c287c493a60c7c8a6151e885591c7dc97df259966711c1383203f0f8b81d05c16051c38d0a310e953611b76f3c8646b1eeccc851812a53351dbec29f7d95b6bc03c29ecfae502f40c2d2d3a2e500438407defb3281bdf73e202e08a44456530eb4d9f5c60f42a63e145bb228e34a2d4c5f7cd19c117cd1285f917d6542a29e823d5dee29d696a052d2d93d33a677789afd4b51c454b48f88aff5ed09f1ddb9a57610bfb53f08abe945ce5b470d258e28da5a07d76fa3e642094e93f1388861aaacd62bdee35db1e87421ea0d14ac3ead59cbc9bbe3d6c090547d5fd66c3e126a304ec0d3b722731db0027fd33ab4f39f78e00ff5cfe589507f5e6df4f0931dc3c6fc8722273fe426e63ce88c925cbe8d9a334ab773e55470065ce5b792bc0fff223671a9108e65c7f95fe57b54e292be34b84ae6be9aff4180dbd7dc1483a765ddd8524c54901beb1ef5585986abfcf6b18716aec221bd7f816d83f871e022ef6c69b5ac66867b3e19f6986f2ddabe4d130aaf92eb3e26b87de1f3fd196356a6c4c43b251546c78f5197a102ec7ae580ffe2ffe4d5b0493b8c8d96b02c98c88d8dd116497eb93e651a219d4790949f73fce87521fe9a07450e545ac68ef91c13ffaca61584b069fbc2a87849d1d81693e6f851f149206378190a2b262b071428555cc7b74f1ac4c982c1f1c08baa896309d10661fbb9db3ff14e3d2ad4e550844681c42235bea9c11c65727bda8df30fcf1ef82ff0e03298c9dcbf0be871ee09459d6ae9f604c4a2f7525a77786b27a99617f22942d88353d2a62130ce34add89451d72d958994176431472461233783af09d09bd969d904605dbaa525060ee2a5796b63495e0e126cf80cc47865d8d675e06a46e57ae40abdd381ad827f31f25811040a99a55702dedd80f734e2eaab1e040653b3d927d23c89cfe4489c17d372f5f2faf24ba009b042f8ead11585c6131f3a3db184d81ae70b56d9782c81e6203dab61b6b92b825856b1ad4ede8ad13c7144fe5f180caeae4cbfd10d2d128d220fecc2541db8895e7793f81009450c91a601bf995d45c715e94aae492e43d5c4bf74310f681d962992a5fe482d922ddbe0c59a3f7856d43bd106f36c24306f209a93028f8201b829c7e277881e8dd7af2c72c972d4a58f5b35ec83ceab2ca05f4a9fb1b0f4cc71a2f7caf8b09e509c7bf093118edbb20c66e094aa96e69aa5b0f444582075a930a79c8ffd8de832496b422d54927d2cea80ae391c07e33a95d4143c76ea30418e774ee6507907afa6cc9c84a5f35921739ff4f4d3fce6ccefed8aa33ecb5dc28a4ae3f6e795b93198a3768cbf6a5ea6b0bc4c57567bc767403c46714e882fe85c9d9e3bb106b68f506836ca7fe7c876e13f3696b49a29d6df736fb3162b157390554331015d449a587f37e9d3a976824e32c43b0b79c3de6a26a47744733e516747e7bf8804b1f79ceacef47bd3adcc99a4b07d36a1db03129bf21c9ff06616aa5e20fcd08e551c26b3583a786e6c2b274c630996f225aa79ab572018737d68dd2495a95a8f1bed48846bf3a6f9cb1086aa4ddbb1d20d5fad1394a8ba37f227901596b5b6e19155bd6771664ff9f52a2c5def8470f9e92516867d45d03a58c613c43564ce4b6e9bc18c1588ef6478c4e81078c5915f10b610e9dac36ef36b9403575429584d7c878af726e55683108f4a6de6a8e804f77e696c3c0e5c9299fccd1a16c729f3476c8a56528286b8cf5152e21dee637fc5f0151f82de2a1e02ee463dcd269328c297614e6f99539d1d5ace7ef4b5650d0764a451f79a8a8081009e1fba7cafbf40b58caf20198b3569c327904332230f9cc381b37374aaa628c69d4ec8342bf7e4b802fcb97a6cc81b98e624ffd4ac880ba1695debf4439bad2849d711f30fac699270db36aef7ddd12d7befa2a9033b4e66e8bf1bdd502105c04de27224ad1df6c0cf959bf79894048647dc5d363aed55aa4b937a2b7319b90af28518d72cf4e233355011eb8f4a05d88cfb1700a8369c271f3d8059790c004edb258edecd8a8fe8c7fff746803d92dff8e71126ea8fe8379617fc03190b4722d90c176b3ebc618db0f6943c67c9014013fff4ae18dfcdd99a53a7699dd7a38b3bc51256307dc299e95fad7c7809371e3100d698629f312bf359f9e4070f8140aa054fe2125c13962026474db4740cd29ab087786e3438409fc0ce1cf896b3736c860bd42d8326bc93b18641267273785697040233da51501d3417614520c45ec01621013dadb0ecd52e117b0e95303e25aa59d1db0ecc8b3e71f1323f2b0b265ae62fdf3a47b1f46dd6b7f4696daef79a2b28ef3a146e5a15b96af23f0524248172444dd0c92025e6727004ba77b6db0f8e3541ae81478dcdf938cef2fbea7a1be16b0de1040878280bcae443e769740b41de9815ceec4648485d493a7a903787dab64fcc89c96ce42d1f35c74b2c42a973f52b3cfe0379ad55f9cca2da5020ce94073bb219342f46aa798844c5d819534ad132dc103b0f462ca1a51411ccf5ef5ab2f7390228704d78a9160e23f1c3143b25683cf5a3f5687465d31ecb14012ab23769611fdda665e1310c871dee13e14f59631a9696f214697cf14360eff23343cef8114ed896e749482dceb8f204b0fafbf25fb7c36821f70f26c07d9648ae1634caf64dd8d4f1e3e48633ff6423b22eb599edba6b694c787f098b1a93e86ecd5ca92775eeff8224dbde636501841df7df601e8700e1e3278479c4c09ae96a988e66890a3574816b6b6b30bbd8c72ad3bebca6d2a6509ea1a5eb65fb4f5a27df567df30e71fdfda49de6bf44bf27aa053582da4110a2fae9525b2cc1c22fdae300fcef604f764b4a7f54075e8ffa2375f94fb70865fea42686640f8e23aa8eaca00f812132816f35e0d89457f8d20e1f6b546d59027a6b4c4a6a0d7f1037e451808a812e75b65064cfbd54696c9d221ced911621419173192a524075547538b223343f75980d9f651ce6e8f198c28803271259d3366789e3f5f233ee506345faa9a51ce525b77d0679bd505ce6a479a44438532941cf80aa78fb73c1df7f2b0fd05b4e31c5e6f6cbd516e9bc8aff03e294bfbdd364b8b18c916eed8790adfc2c94eba90ae67eae9c649a398f65f21d288a18b870dcae6a81171265d41945b908877eeff5e18a5d7619ca2c2d31805ed7270eb9e9aacd65e020e4d92650a23456278095123654eade37b6e534a9d3970c98cdc4b2d22e690a69f1f0ec4fb1fc5d00a05331528a001f324bd10ba705f6ccff7d02410cfea60c8a81267142fc881bbfd1b3d1fd7376fee01da21f339ee2c875876f04f95ce75f4a6e034d0fd5c2c5d42b36cdea6a4409c9fc0371da232c5317fe54f2d0d8a2b6775fd6fcf407b9709442077c1c0cbba8a2173bab915accdd5a4657702e0658dedb01d1f90de5bb5ba1fd42b5fa24c0f41f8aba7afe839441de8a7bfce16875b923450b61722dee442ba762efde94e9a83b23d92ff0ae851253b7089110a0d5cd85162cd3b6270aa05bad7e63afd1b395adfa29052c8bf85b6d5cca153e1fdbcdbf4f0b8b265ec944e106ee60875a744b2f0e599709d60b172b284808ee3782cf54876d9a50867f2a997cc0e26b0d678e34ed41227911b1560d0299620394e3ea337b6156f347ad824b446248b9be0fe68413ffbb5c25d932dd4010cc598470ad059d1426d1744f823eeb4ed04635ad02b958a4e2562a3b014027065ac01f88b89ae11e890c533de0e7cd032b1712e3c75dba7df485c7a2cad65dd9ee5f05b2c4ad33d3d1b0f5aaea4652718d78ddc93b294551bc26aeb46378705736cb9f1bc7d2244b671cfbd544d5df37ad2f0af46f04fef05731da93eb86539901f5160d2f93eb87f6233da53a0dd3900476e23d11a874cf9af3a136c0801e287898f98032b996fc03285ff94c540f4b95d88faf9f3d60d2b265c574791cc99f7dad9b69500b08ef8160c6297a34957a4cc43e9d05ac29e4249053c0dc271f4d3e07b2851804c1d8cbe798e6b3e8cbef7ca7aa4878b5bdccadc59881c70499b01bd08b2c20bea4f2dec5522ce4ee4d14183cb5d08657efcd3103924b1907d67014211d204914fc93314d6a2660800c3b1ee010cc901a9b7a0bfa2b6392e3172f582b7e6b79c1282bef68ef03209b1c2467be80aa5e434469de9dfc2d9e3b46f960709d54e94befdf8ceb1a4462740a98915528a11b38545da8ea24b3677ba04a593091449dfc99146cf13e17b5fd04a74a67daebb3d0927cf6240210971a1b8fb42c6c7005825e4eccb7bf72388be5a511c62bd06a987e50af6c02a6a10e4e6065fa7708482d0864d0de13c4c0c314a799ff44a0db502a1f93bb4c142d6d Hey, password is required here.","tags":["时间"],"categories":["Linux"]},{"title":"NTP 相关内容备忘","path":"/2025/10/31/0013-ntp/","content":"注意事项 NTP 使用 UDP 123 端口。 ntpd 既可以作为服务端程序，也可以作为客户端程序。所以当设备仅使用 NTP 客户端功能时，要在 etcntp.conf 中增加以下内容： restrict default kod nomodify notrap nopeer noqueryrestrict -6 default kod nomodify notrap nopeer noquery #针对ipv6设置# 允许本地所有操作restrict 127.0.0.1restrict ::1 配置文件etcntp.conf NTP 服务（如 ntpd）的主配置文件，核心作用是定义 NTP 服务器的运行规则，包括时间同步的来源、客户端的访问权限、安全认证方式等，直接决定 NTP 服务如何工作 etcntpkeys NTP 服务用于身份认证的密钥文件 文件中每行定义一个密钥，格式为：[密钥ID] [密钥类型] [密钥内容] $ cat /etc/ntp/keys10 M 123 密钥 ID：1-65535 之间的整数，用于在 NTP 配置中引用该密钥（如 trustedkey 1 表示信任 ID 为 1 的密钥）。 密钥类型：通常为 M（MD5 加密，最常用），也支持 S（SHA-1）等，指定密钥的加密算法。 密钥内容：由字母、数字或特殊字符组成的字符串（建议长度 8-32 位，复杂度越高越安全）。 常用命令网络抓包tcpdump udp port 123 -w ntp.pcap ntpdate 使用的是系统随机分配的空闲端口。 ntpqntpq -np ntpq -crv 查看认证状态 ntpq -c as ntpdate# x.x.x.x是 NTP 服务器的 IP 地址ntpdate -u x.x.x.x 认证相关 ntpdate -a 10 -k /etc/ntp/keys x.x.x.x 在对时间有严格要求的生产环境下，使用 ntpdate 可能会产生严重的后果。 ntpd 是步进式的逐渐调整时间，而 ntpdate 是断点更新，比如现在服务器时间是9.18分，而标准时间是9.28分，ntpd 会在一段时间内逐渐的把时间校准到与标准时间相同，而 ntpdate 会立刻把时间调整到 9.28分。","tags":["NTP"],"categories":["编程"]},{"title":"keepalived - VRRP 协议","path":"/2025/10/30/0010-keepalived-00/","content":"虚拟路由冗余协议 VRRP (Virtual Router Redundancy Protocol) 主机设备通过网关与外部网络联系，当网关出现故障时，主机设备将与外界失去联系。 VRRP 将多台设备组成一个虚拟设备，通过将虚拟设备的IP地址配置为网关，当网关设备发生故障时，VRRP 机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。 概念 VRRP 路由器(VRRP Router)：运行 VRRP 协议的设备，它可能属于一个或多个虚拟路由器。 虚拟路由器(Virtual Router): 又称 VRRP 备份组，由一个 Master 路由器和多个 Backup 路由器组成，被当做一个共享局域网内主机的缺省网关。 Master 路由器：承担转发报文任务的 VRRP 设备。 Backup 路由器：一组没有承担转发任务的 VRRP 设备，当 Master 路由器出现故障时，它们将通过竞选成为新的 Master 路由器。 VRID：虚拟路由器标识，在同一个 VRRP 组内的路由器必须有相同的 VRID。 虚拟 IP 地址(Virtual IP Address)：虚拟路由器的 IP 地址，一个虚拟路由器可以有一个或多个 IP 地址。 IP 地址拥有者(IP Address Owner)：如果一个 VRRP 设备将虚拟路由器 IP 地址作为真实的接口地址，则该设备被称为 IP 地址拥有者。如果 IP 地址拥有者是可用的，通常它将成为 Master 路由器。 虚拟 MAC 地址(Virtual MAC Address)：格式：00-00-5E-00-01-{VRID} (VRRP for IPv4); 00-00-5E-00-02-{VRID} (VRRP for IPv6)，其中 00-00-5E 是 IANA 组织分配的，00-01 是为 VRRP 协议指定的，VRID 是虚拟路由器标识，取值范围为[1-255]。当虚拟路由器回应 ARP 请求时，使用虚拟 MAC 地址，而不是接口的真实 MAC 地址。 非抢占方式：如果 Backup 路由器工作在非抢占方式下，只要 Master 路由器没有故障，Backup 路由器即使被配置了更高的优先级，也不会成为 Master 路由器。 抢占方式：如果 Backup 路由器工作在抢占方式下，当它收到 VRRP 报文后，会将自己的优先级与通告报文中的优先级进行比较。如果自己的优先级更高，就会主动抢占成为 Master 路由器。 VRRP 路由器的优先级0优先级为 0 用于指示当前虚拟路由器的 Master 路由器停止参与 VRRP 组。主要用于触发 Backup 路由器快速地迁移到 Master 路由器，而不用等待当前 Master 路由器超时。 255如果 VRRP 路由器是虚拟路由器地址的IP地址拥有者，那么其优先级必须为255。 1-254Backup 路由器的优先级必须在1–254之间。缺省的 VRRP 路由器优先级为100。 典型组网案例主备备份业务仅由 Master 路由器承担，当 Master 路由器出现故障时，才会由选举出来的 Backup 路由器接替它工作。 负载分担在路由器的一个接口上可以创建多个虚拟路由器，使得该路由器可以在一个虚拟路由器中作为 Master 路由器，同时在其它的虚拟路由器中作为 Backup 路由器。 为了实现业务流量在 Device A、Device B 和 Device C 之间进行负载分担，需要将局域网内的主机的默认网关分别设置为虚拟路由器1、2和3。 在配置优先级时，需要确保三个虚拟路由器中各路由器的 VRRP 优先级之间形成一定的交叉，使得一台路由器尽可能不同时充当 2 个 Master 路由器。 keepalived 阅读材料 HUAWEI: VRRP配置","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"每天最重要的2小时 - 02","path":"/2025/10/29/0009-two-awesome-hours-02/","content":"我们的大脑能量是驱动我们行为的燃油，如果没有了它，我们就寸步难行。 什么会让你心理疲惫“执行功能”指的是大脑所拥有的各种控制和决定方向的功能。大脑的执行功能包括做出决定、做计划，必要的时候，还要短暂地记住一些想法。 进行自我控制往往会削弱我们的自控力。当进行自控行为之后，我们的这部分大脑功能往往会显得疲惫。 即使是做一些典型的、日常的、不重要的决定，也会让人在接下来的自控性任务中缺乏动力。 情绪决定你的表现情绪能够帮助我们解决和应对眼前的情况。 愤怒或不快能够让我们积极应对某些特定的想法和行动。下一次，如果你明知冒这个险才是正确的，却又不敢冒险，不妨让自己愤怒起来。 当我们感到悲伤时，往往会在做决定时尽量少带成见。 焦虑是一种能让我们高度警觉、对任何突发状况做好准备的情绪。 如果想让自己在那些不太重要的事情上放开手，如果要发挥自己的创造力，如果需要做出迅速的决定，试试带着积极的情绪去面对。 如何管理心理能量首先要分辨出那些工作最容易极大地消耗你的心理能量。在进行需要自己百分百投入的工作之前，一定要尽可能地避免做那些消耗心理能量的事情。 如果你在做完某项任务之后觉得很累，很有可能就是它让你消耗大量的自控力。 试着做一做下面这四件事： 早上第一件事（真正的第一件事，在看任何社交媒体之前）就是完成你最重要的工作。想想你自己手头上最具创造性、最有意思的工作，或者长远来看最有益的工作是什么，然后在早晨花一两个小时去做。 考虑一下今天所有的待办事项，把他们分类为重要的、创造性的、其他。在一天中较晚的时候完成其他分类里的工作。 试试在下午花上一个小时阅读并回复你的电子邮件。 在第二天有重要活动时，头天晚上就提前做一些决定，比如穿什么，早餐午餐吃什么，也可以是重要的决定。 迅速补充心理能量的三种方法： 缓慢地深呼吸一会儿。 尽情地大笑一场，积极的情绪可以为我们“充电”。 短暂地打个盹儿。10分钟的短暂睡眠能够帮助缓解疲劳，还能够提升警觉度以及许多不同的认知功能。 有时候果断地放弃一些事，以保证自己在最重要的时刻拥有良好的状态，对我们而言或许更有帮助。 为了真正利用好你的心理能量，你需要做的是出色地完成事关紧要的工作，而不是平庸地完成所有的工作。 结论：让你的效率达到最大化下一次，如果你发现自己正处于抉择点，能够开始一项新任务时，请务必回顾一下：刚刚完成了那些任务？大脑是否已经因为做出了太多决定而疲惫不堪？目前的情绪如何？它们有没有影响到你的下一项任务？ 反思Dan Koe 的视频中确实也有提到愤怒的情绪的作用。 某天，我发现折腾博客的个性化配置会让我很累。 时间管理不是把日程塞满。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"keepalived - VRRP 同步","path":"/2025/10/28/0010-keepalived-03/","content":"Keepalived 的 VRRP 同步功能（即同步组，sync groups）解决了复杂网络环境中的一个关键问题：在此类环境中，多个 VRRP 实例可能需要维持状态一致性。若缺乏同步机制，各个 VRRP 实例会各自进行独立的状态转换，这可能导致 “脑裂”（split-brain）场景或路由路径不一致的问题。 keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"Source Insight 配置记录","path":"/2025/10/28/0012-source-insight/","content":"快捷键 F5: 跳转到指定行 F8: 高亮选中 Ctrl + /: 全局搜索 Source Insight 的两种高亮方式1. 自动高亮（鼠标点击高亮） 打开选项设置：在菜单栏中选择 Options File Type Options…。 勾选高亮选项：在弹出的窗口中，找到并勾选 Highlight references to selected symbol 选项。 效果如图 2. 快捷键手动高亮 选中要高亮的部分，点击 F8 效果如图","tags":["SourceInsight"],"categories":["编程"]},{"title":"keepalived - VRRP 调度器","path":"/2025/10/28/0010-keepalived-02/","content":"代码版本： https://github.com/acassen/keepalived/releases/tag/v1.1.12 Socket Pool套接字池（Socket Pool）为虚拟路由冗余协议（VRRP）实例高效管理网络通信，可在合适的情况下允许多个实例共享套接字。 vrrp_dispatcher_init创建和申请一个 socket pool。 假设有 n 个网卡。每个网卡最多有 2 个 fds（1个用于 VRRP，另一个用于 IPSEC_AH）。所有的 VRRP 实例都通过这些文件描述符（fds）实现多路复用。因此，我们的设计可支持 2×n 个多路复用节点。 fd1 fd2 fd3 fd4 fdi fdi+1-----\\__/--------\\__/---........---\\__/--- | ETH0 | | ETH1 | | ETHn | +------+ +------+ +------+ 多个 VRRP 实例不单独占用套接字，而是共享一组 fds 资源，通过操作系统的 IO 多路复用技术（如 Linux 的epoll、BSD 的kqueue）实现对多个实例通信需求的并发处理，最终达成 “用少量 fds 支持大量实例” 的高效设计目标。 vrrp_create_sockpool为 VRRP instances 创建 sockets 结构 vrrp_create_sockpool(vrrp_data-vrrp_socket_pool) for(e : vrrp_data-vrrp_socket_pool) alloc_sock MALLOC vrrp_open_sockpool开启物理 sockets vrrp_open_sockpool(vrrp_data-vrrp_socket_pool) for(e : vrrp_data-vrrp_socket_pool) sock_obj = ELEMENT_DATA(e); sock_obj-fd_in = open_vrrp_socket(); socket(AF_INET, SOCK_RAW, proto); sock_obj-fd_out = open_vrrp_send_socket(); socket(AF_INET, SOCK_RAW, proto); vrrp_set_fds为 VRRP instances 分配合适的 sockets vrrp_set_fds(vrrp_data-vrrp_socket_pool) for(e : vrrp_data-vrrp_socket_pool) vrrp-fd_in = sock_obj-fd_in; vrrp-fd_out = sock_obj-fd_out; 通告处理VRRP 调度器处理传入的 VRRP 通告，并根据实例的当前状态对其进行处理： 代码流程vrrp_read_dispatcher_thread vrrp_dispatcher_read /* read affect received buffer */ read(fd, vrrp_buffer, VRRP_PACKET_TEMP_LEN); /* Searching for matching instance */ vrrp = vrrp_index_lookup(hd-vrid, fd); /* Run the FSM handler */ prev_state = vrrp-state; VRRP_FSM_READ(vrrp, vrrp_buffer, len); /* MASTER */ vrrp_leave_master vrrp_state_master_rx /* Process the incoming packet */ ret = vrrp_check_packet(vrrp, buf, buflen); if (Lower priority) vrrp_send_adv(vrrp, vrrp-priority); vrrp_send_gratuitous_arp(vrrp); return 0; else vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); vrrp-wantstate = VRRP_STATE_BACK; vrrp-state = VRRP_STATE_BACK; return 1; /* BACKUP */ vrrp_backup vrrp_state_backup if(Higher priority) vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); else vrrp-wantstate = VRRP_STATE_GOTO_MASTER; vrrp_send_adv(vrrp, vrrp-priority); vrrp_send_adv VRRP 协议报文封装在 IP 报文中，发送到分配给 VRRP 的 IP 组播地址 在IP 报文头中 源地址为发送报文接口的主 IP 地址 目的地址为 224.0.0.18 TTL 必须是 255。（VRRP 路由器会丢弃 TTL 不等于 255 的 VRRP 协议报文） 协议号是 112 /* send VRRP advertissement */vrrp_send_adv /* build VRRP packet */ vrrp_build_pkt(vrrp, prio) /* build IP header */ vrrp_build_ip ip-ttl = VRRP_IP_TTL; ip-protocol = (vrrp-auth_type == VRRP_AUTH_AH) ? IPPROTO_IPSEC_AH : IPPROTO_VRRP; ip-saddr = VRRP_PKT_SADDR(vrrp); ip-daddr = htonl(INADDR_VRRP_GROUP); /* checksum must be done last */ ip-check = in_csum((u_short *) ip, ip-ihl * 4, 0); /* build the vrrp header */ vrrp_build_vrrp(vrrp, prio, vrrp-send_buffer, vrrp-send_buffer_size) keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"Linux 进程间通信：共享内存","path":"/2025/10/27/0011-ipc-shm/","content":"头文件 sys/shm.h shmget 创建共享内存 第一次创建完共享内存时，它还不能被任何进程访问 int shmget(key_t key, size_t size, int shmflg); shmat — at：attach 启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间 void *shmat(int shm_id, const void *shm_addr, int shmflg); shmdt — dt：detach 将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用 int shmdt(const void *shmaddr); shmctl — ctl：control 控制共享内存 int shmctl(int shm_id, int command, struct shmid_ds *buf);","tags":["进程间通信"],"categories":["Linux"]},{"title":"keepalived - VRRP 状态机","path":"/2025/10/27/0010-keepalived-01/","content":"代码版本： https://github.com/acassen/keepalived/releases/tag/v1.1.12 VRRP 状态机VRRP_FSM Read_to: read timeout struct void (*read) (vrrp_rt *, char *, int);\tvoid (*read_to) (vrrp_rt *); VRRP_FSM[VRRP_MAX_FSM_STATE + 1] =/* Stream Read Handlers | Stream Read_to handlers * *------------------------------+------------------------------*/\tNULL, NULL,\tvrrp_backup, vrrp_goto_master,\t/* BACKUP */\tvrrp_leave_master, vrrp_master, /* MASTER */\tvrrp_leave_fault, vrrp_fault, /* FAULT */\tvrrp_become_master, vrrp_goto_master\t/* GOTO_MASTER */; VRRP FSM Macro/* VRRP FSM Macro */#define VRRP_FSM_READ_TO(V) \\do \\ if ((*(VRRP_FSM[(V)-state].read_to)))\t\\ (*(VRRP_FSM[(V)-state].read_to)) (V);\t\\ while (0)#define VRRP_FSM_READ(V, B, L) \\do \\ if ((*(VRRP_FSM[(V)-state].read))) \\ (*(VRRP_FSM[(V)-state].read)) (V, B, L);\t\\ while (0) VRRP_TSM当某个 VRRP 实例发生状态变更，且需要与其同步组（sync group）内的其他实例进行协调时，将使用 VRRP_TSM 。 使用方式可以理解为：VRRP_TSM[from_state][to_state] struct void (*handler) (vrrp_rt *); VRRP_TSM[VRRP_MAX_TSM_STATE + 1][VRRP_MAX_TSM_STATE + 1] =/* From: To: BACKUP MASTER FAULT *//* v */ NULL, NULL, NULL, NULL ,/* BACKUP */ NULL, vrrp_sync_master_election, vrrp_sync_master, vrrp_sync_fault ,/* MASTER */ NULL, vrrp_sync_backup, vrrp_sync_master, vrrp_sync_fault ,/* FAULT */ NULL, vrrp_sync_backup, vrrp_sync_master, vrrp_sync_fault ; VRRP TSM Macro#define VRRP_TSM_HANDLE(S,V) \\do \\ if ((V)-sync \\ S != VRRP_STATE_GOTO_MASTER) \\ if ((*(VRRP_TSM[S][(V)-state].handler)))\t\\ (*(VRRP_TSM[S][(V)-state].handler)) (V);\t\\ while (0) 状态图 初始化期间，从 INIT（初始化）状态开始 若所有检查均通过，则转换至 BACKUP（备份）状态 若未从优先级更高的主用（MASTER）设备接收到通告消息，则转换至 MASTER（主用）状态 若接收到优先级更高的通告消息，则转换至 BACKUP（备份）状态 若任何被跟踪的资源发生故障，则转换至 FAULT（故障）状态 当故障条件清除后，返回至 BACKUP（备份）状态 INIT 状态/* Initialize state handling */static voidvrrp_init_state(list l) for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) vrrp = ELEMENT_DATA(e); if (vrrp-priority == VRRP_PRIO_OWNER || vrrp-wantstate == VRRP_STATE_MAST) vrrp-state = VRRP_STATE_GOTO_MASTER; else vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); vrrp-state = VRRP_STATE_BACK; BACKUP 状态 当处于 BACKUP（备份）状态时，该实例会设置一个 master_down_timer（主用设备下线计时器）。 每当从优先级更高的主用（MASTER）设备接收到有效的通告消息（advertisement）时，此计时器就会重置。 若计时器超时（即在超时周期内未接收到任何通告消息），该实例将转换至 MASTER（主用）状态。 /* Handle dispatcher read timeout */static intvrrp_dispatcher_read_to(int fd) /* Run the FSM handler */ prev_state = vrrp-state; VRRP_FSM_READ_TO(vrrp); // vrrp_goto_master /* handle instance synchronization */ VRRP_TSM_HANDLE(prev_state, vrrp); MASTER 状态 拥有并维护虚拟 IP 地址（VIPs）。 按照配置的时间间隔发送定期的 VRRP 通告消息。 处理接收的 VRRP 通告消息，若接收到优先级更高的通告消息，该实例将转换至 BACKUP 状态。 static voidvrrp_master(vrrp_rt * vrrp) if (vrrp-state == VRRP_STATE_MAST) vrrp_state_master_tx(vrrp, 0); FAULT 状态由于出现错误条件，该 VRRP 实例无法以 MASTER（主用）或 BACKUP（备份）状态正常运行。 keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"每天最重要的2小时 - 01","path":"/2025/10/21/0009-two-awesome-hours-01/","content":"意识到每天的关键时刻–抉择点我们一旦开始了一项神经性常规活动，就会像电脑程序一样一直运行下去，直到完成任务，或是被打断。 实际上，每一天都是由一系列习惯性的神经常规程序组成：早上起床、穿好衣服去上班、打开电脑、回复电子邮件等。问题在于，我们经常会从一个任务跳到另一个任务，却不仔细想想下一步最好该做什么。 学会意识到一天的当中的几个特殊时刻，在这种时刻，你有机会也有能力决定自己将如何度过接下来的时间。 做出最恰当的选择当常规程序结束的时候，自我意识就会浮现出来。意识最重要的功能就是在我们的自动式神经常规活动遇到困难的时候做出决定。 抉择点通常是作为冲突–无意识的自动行为之间的冲突、行为和目标之间相冲突–的结果而出现的。正因为这些抉择点会令人不舒服，我们往往才选择尽快跳过它们。 忽略抉择点的坏处匆忙跳过抉择点，很可能接下来进行的任务并没有那么重要，或是不适合在这段时间完成，损失也许会更大。 充分利于抉择点的三个诀窍在这一刻，对我们而言究竟什么最为重要。 珍惜每一个抉择点 意识到抉择点的出现，并尽力抓住它；要承认它的存在，而不是无视它，一头扎进无意识思维指引你去做的下一个任务里。 抉择点能够让你与眼下最关注的事保持一定的“距离”。 提前为抉择点做好相应计划 “计划不去做某件事”常常会失败，关键的一点是，你做的计划要让自己在这一刻进行一项新的活动–一项你乐意做的事。 当我们在脑海中设想某一个行动时，所利用的神经回路其实和真正去做这件事时的神经回路相同。 不要随便开始一项新任务，除非已经有意识地决定了它确实值得做。 一旦你完成一项任务，不要去想接下来自己可以是轻松地做些什么，而是把这一刻标记为抉择点。 怎么决定什么事最值得花时间？判断依据之一就是自己当天最重要的任务。 结论：聪明地安排你的时间用途在完成不同任务的间隙之间，我们终于从忘我工作的状态中脱身而出，这些时刻实在是不可多得的礼物，而我们完全应该审慎地利用这些时刻。 反思 早上睡醒之后，会无意识的在社交软件，购物软件之间来回跳转。（睡前将手机放在客厅。） 下班前会突然冒出不想运动的想法。（想象下班后运动的过程。） 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"孕期检查备忘录","path":"/2025/10/20/0008-pregnancy-checklist/","content":"名词解释13+6医生关于孕期的常用描述，13 是指第13周，+6 则指的是第6天，比如 NT 检查需要在 11 到 13+6 这段时间进行，意思就是需要在第11周到第13周的第6天之间的这段时间进行。 重要时间节点NT 检查 时间：孕11周到孕13+6周 通过B超检查胎儿颈项透明层的厚度。 建档（母子健康手册） 时间：孕12周 一本粉红色的小册子，需要保留到孩子上学。 建档需要进行抽血检查，所以当天早上记得不要吃早饭。建档之后，需要按照时间要求，定期到医院进行孕期检查。 准生证（生育登记证明） 时间：怀孕3个月后 准生证应该是计划生育时期的叫法，现在应该都是通过各地的相关公众号进行的。 唐氏筛查 时间：孕15周到孕20周（以医生建议为准） 用于评估胎儿患有唐氏综合征的风险。 四维彩超 时间：孕22周到孕26周（以医生建议为准） 实时三维超声，是在二维超声的基础上，通过技术处理而形成的形象直观的动态立体图像。 糖耐葡萄糖耐量试验（OGTT），简称糖耐。检查时会让准妈妈喝葡萄糖水来模拟一顿饭摄入的糖量，从而检测胰岛功能，排查妊娠期糖尿病。","categories":["生活记录"]},{"title":"顺风车车主初体验","path":"/2025/10/19/0007-hitch/","content":"更新记录：2025-10-28：偶然看到保险会以非运营车辆进行营运拒赔的说法，所以最终还是把所有平台注册的顺风车给注销了，避免不必要的麻烦吧。 在国庆节的末尾进行了爱车的第4次保养，我已有两年的驾龄，由于最近经常需要在周末开车往返于两地，所以下定决心跑一下顺风车平摊路费。 在没有注册成为顺风车车主之前的想法是顺路了就接一单，实在没有就算了，也不指望创收；但在成为车主之后，我的行为竟然瞬间出现了变化，我发现自己早早的发布了几天之后的出行信息，开始频繁的查看三个平台寻找合适的乘客，在乘客莫名其妙的取消订单之后觉得失落，在没有订单的情况下觉得要不再等等看有没有合适的。 在体验了一次顺风车车主的行程之后，我发现与我希望的方式（不接不送，顺路上下）不同，无论是高德、哈啰，还是滴滴，都需要车主按照乘客指定的起点和目的地进行接送。 因此我决定记录并提醒一下自己跑顺风车的最初想法和要求： 不需要跑顺风车创收，有合适的就跑，没有也无所谓 三环以内的订单不接（感受过市区下班高峰期之后的第一个决定） 距离我的起点和终点超过10公里的订单不接 每周五查看平台信息即可 接单后，及时与乘客电话沟通确认 除了上述提到的三个平台之外，在我的城市还有一个公众号平台，早期我也确实作为乘客体验过三四次，这个公众号上车主发布自己的具体行程，乘客依据自己的出行需求选择合适的订单，并主动与车主电话沟通。 哦，对了，那顺便说一下三个平台的逻辑， 高德：车主端可以看到乘客发布的行程；乘客也可以看到车主发布的行程；双方可以根据行程信息相互进行邀请 哈啰：暂时没有体验到 滴滴：乘客发布自己的行程，但看不到车主发布的行程，只能被动等待；需要车主依据自己的行程选择合适的订单 对比下来，我更喜欢高德的顺风车方式，不过感觉好像滴滴上的订单更多。","tags":["顺风车"],"categories":["生活记录"]},{"title":"结构体的内存对齐和变长数组","path":"/2025/10/15/0006-c99-vla/","content":"引入项目中业务模块产生的日志在通过本地 socket 发送给日志模块后，日志模块记录的内容总是会丢失前6个字节。经过排查，业务模块和日志模块使用的虽然都是 log_msg_t 结构体，但结构体中的变量类型定义却略有差异，如下所示： 业务模块的结构体定义 typedef struct\tunsigned char type;\tunsigned char level;\tunsigned short size;\tunsigned int pid;\tunsigned int cds;\tunsigned char imm;\tunsigned char u8wf;\tunsigned char data[]; log_msg_t; 日志模块的结构体定义 typedef struct\tunsigned char type;\tunsigned char level;\tunsigned short size;\tunsigned int pid;\tunsigned int cds;\tunsigned char imm;\tunsigned int u8wf;\tunsigned char data[]; log_msg_t; 显然，由于结构体中 u8wf 变量类型的不同，导致出现了内容丢失。但 unsigned char 的大小为1个字节，unsigned int 的大小为4个字节，怎么会出现丢失6个字节的内容呢，这与结构体的内存对齐有关。 内存对齐为什么需要对齐在 C 语言中，结构体的内存对齐是编译器为了提高 CPU 访问内存效率而采取的一种内存布局优化策略，是一种拿空间换时间的做法。 CPU 访问内存时并非逐个字节读取，而是按固定大小的 “块”（如 4 字节、8 字节）读取。如果数据的起始地址是块大小的整数倍（即 “对齐”），CPU 可以一次完成读取；否则可能需要多次读取，影响效率。 内存对齐规则 第一个成员在与结构体变量偏移量为 0 的地址处。 其他成员变量的起始地址必须是 min(该成员自身大小, 编译器默认对齐数) 的整数倍。 结构体的总大小必须是所有成员中最大对齐值的整数倍，即 min(结构体中最宽成员类型的大小, 编译器默认对齐数) 的整数倍。若不足，编译器会在最后一个成员之后添加填充字节以满足此要求。 练习下面两个结构体的大小分别为多少？ typedef struct\tchar c1;\tint i;\tchar c2; S1;typedef struct\tchar c1;\tchar c2;\tint i; S2; S1 和 S2 的内存布局如下图所示: 相关函数sizeof 获取结构体的大小 printf(%ld , sizeof(S1));printf(%ld , sizeof(S2)); offset 宏 计算结构体中某变量相对于首地址的偏移 头文件: #includestddef.h printf(offsetof(S1, c1) = %ld , offsetof(S1, c1));printf(offsetof(S1, i) = %ld , offsetof(S1, i));printf(offsetof(S1, c2) = %ld , offsetof(S1, c2)); #pragma pack() 修改默认对齐数（谨慎操作） // 将默认对齐数修改为 8#pragma pack(8)typedef struct\tchar c1;\tint i;\tchar c2; S1;// 恢复默认对齐数#pragma pack() TIPS在设计结构体的时候要满足对齐规则，又要节省空间，如何做到呢？ 在定义结构体时，将大小相同或相近的成员声明在一起，并且按照从大到小（或从小到大）的顺序声明，可以最大限度地减少填充字节，节省内存。 可变长数组此外，可以看到 log_msg_t 的最后一个元素为 data[], 且如果使用 sizeof(log_msg_t)，可能会发现结果并不符合预期，这一切都与可变长数组的特点相关。 介绍变长数组是在 C 语言的 C99 标准中引入的新特性。结构体中的最后一个元素允许是大小未知的数组。 比如： struct S int n; int arr[]; // 部分编译器可能会报错，可以将 arr[] 改为 arr[0]; 特点 结构体中的可变长数组前面必须至少有一个其它类型的成员。 可变长数组必须是结构体的最后一个成员。 可变长数组不占用结构体的存储空间，使用 sizeof 计算结构体的大小不包含可变长数组成员。 结构体变量相邻的存储空间保存的是可变长数组的内容。 log_msg_t因此，两个模块使用的log_msg_t结构体的内存布局如图所示: 可以看到两个结构体的 data 成员相对于起始地址的偏移量相差 6 个字节，这也就是为什么日志模块记录的内容总是会丢失前6个字节。 优势使用指针struct S int n; int *arr;; 那么在使用时就需要两次 malloc 和两次 free， struct S *ps = NULL;// 动态分配结构体S的内存空间ps = (struct S*)malloc(sizeof(struct S));if (ps == NULL) return -1;ps-n = 10;// 为结构体中的数组成员分配内存ps-arr = (int*)malloc(ps-n * sizeof(int));if (ps-arr == NULL) free(ps);\tps = NULL;\treturn -1;// do something // 释放所有动态分配的内存free(ps-arr);ps-arr = NULL;free(ps);ps = NULL; 使用可变长数组struct S int n; int arr[0];; 使用时只需要一次 malloc 和 free， // 分配内存以容纳结构体S和10个整数的数组struct S *ps = (struct S *)malloc(sizeof(struct S) + sizeof(int) * 10);if (ps == NULL) return -1;ps-n = 10;// do something // 释放分配的内存并置空指针free(ps);ps = NULL; 总结使用指针： 为了防止内存泄漏，如果分两次分配结构体和缓冲区的内存，当第二次 malloc 失败时，必须回滚释放第一次分配的结构体内存。 进行了两次 malloc，需要对应两次 free，如果我们的代码是在一个给别人用的函数中，我们在函数里做了两次内存分配，并把整个结构体返回给用户；虽然用户调用 free 可以释放结构体，但用户并不知道结构体的成员也需要 free，造成内存泄露。 malloc 次数越多，产生的内存碎片就越多，内存的利用率就会降低。 使用变长数组： 连续内存有利于提高访问速度，同时减少内存碎片","tags":["C语言"],"categories":["编程"]},{"title":"我的影视资源解决方案","path":"/2025/10/15/0005-emby/","content":"影视资源站最初主要在一些影视资源站看视频，比如在在线之家看完了全季的《权力的游戏》。 以下是几个仍保留在收藏夹中的资源站： 低端影视 在线之家 NO视频 网盘网盘在很长时间里都是我获取影视资源的主要阵地，从百度网盘、谷歌云盘、阿里云盘，到现在主要使用的夸克网盘。在阿里云盘开始收费后，我发现88VIP会赠送1年的夸克网盘会员（此时，我已持有88VIP将近半年的时间）。 夸克网盘会员(88VIP版)有6TB的存储空间，且在电视上有对应的客户端，几乎满足了我所有的观看需求，但影视墙功能仍需付费开通SVIP才能使用。不过，最近在折腾飞牛OS里提供的飞牛影视可以挂载夸克网盘，并且能够进行直链播放，也是一种免费使用影视墙的解决方案。 PS: 88VIP还提供1年的优酷会员或芒果会员，应该已经能够满足大部分的观影需求。 以下是几个我目前常用的网盘资源搜索网站： 云盘盘 SeedHub 夸克盘 EmbyEmby 在我看来是强者的存在，几乎可以替代爱优腾和各种流媒体平台。互联网上有大量的公益服和付费服，我记得最早使用的是叫做普拉斯影业的公益服，不过目前好像已经不能使用了。 以下是一个关于 Emby 的介绍视频，部分信息已过期，不过有助于你简单了解 Emby。"},{"title":"家庭网络折腾备忘录","path":"/2025/10/14/0004-cucc-modem/","content":"002a748617e5cc304f438c1409bd96526eb4ad4593d4d71e04e8698e3520de0cf8e5545d3a653be200d7127a72677075b27591933b5624dc42316f783c49f5b39cbe5476d1a3a35076c86152eb558d28c39678e517a24164134ed90692d8bcc00395ead76bb9bf955b19704afa3fb2075cb8988f8d95f0d888ee1b9577408744a705fd6d0008bb468613f9e3165557b4881365223a42ae4d5cda13bc70d5f635bc2932f657c2a25e8aac2cf984edcdbd4f56c4da662c37bea241d1efb52c41221c8e663eac64dc536ef2ed9c1315f235e1631b7eb9ad79cf3f1eb466e1d4ea8dd90ccf78a7ff9632a3b584aede277aeec0cf8c338b321fbeaeb833eb5cd5ff1bf6572b52d008132cb3b4a66efdd439eb75e56f271a6d2ff57e84ab760f4d279279cd828a918447fbfceaafbdb556a2513d4629afbba1ffd5b520a690fff390570a8febcf3bdf62b223a4f032ac02c0d731011c6c1bf4cd79f1596d484a6e477183ef99d4f92e03028d4cc176033163aa1f1c5bb1922adcaeaaf03538658f4c223c21e0f7f985e9032730a942ff60c5619f4f344dac000b70427f472ed7b2225d4195a28db1ad60db56a6dcc178a3325542a44e652800c9212138c3c29916fc9ce344bb42d2e54c6f91a678bd9fd8844ab925b7210a19b05d6fd1d7a3f282927cb658efa98d9547e0ebc4a5da9de7ccf847aeca4c67a77e23bb5855dd8d3391a457c7d1918d32545e6a9ef5ea30c2b9758fbd83455d0ef7a69f489d8b95c29122a21bd94b572a99e28766ea16801946cc Hey, password is required here.","tags":["光猫","路由器"],"categories":["网络"]},{"title":"Hello Stellar","path":"/2025/09/30/0003-hello-stellar/","content":"安装主题在根目录执行如下命令： npm i hexo-theme-stellar 主导航栏根目录下的 _config.stellar.yml # 侧边栏主功能导航菜单menubar: columns: 4 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 # - id: post # 页面中高亮的 menu_id # theme: #1BCDFC # 高亮时的颜色，仅 svg 中 fill=currentColor 时有效 # icon: solar:documents-bold-duotone # 支持 svg/img 标签，可以定义在 icons.yml 文件中，也支持外部图片的 URL # title: 博客 # 标题 # url: / # 跳转链接，支持相对路径和绝对路径 # - id: wiki # theme: #3DC550 # icon: solar:notebook-bookmark-bold-duotone # title: 文档 # url: /wiki/ # - id: explore # theme: #FA6400 # icon: solar:planet-bold-duotone # title: 探索 # url: /explore/ # - id: social # theme: #F44336 # icon: solar:chat-square-like-bold-duotone # title: 社交 # url: /friends/ 文章模版根目录下 scaffolds 文件夹中编辑 post.md ---# 基本信息title: title date: date tags: []categories: []description: # excerpt 也可 # 封面cover: banner: poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选# 插件sticky: # 数字越大越靠前mermaid:katex: mathjax: # 可选topic: # 专栏 idauthor: references:comments: # 设置 false 禁止评论indexing: # 设置 false 避免被搜索breadcrumb: # 设置 false 隐藏面包屑导航leftbar: rightbar:h1: # 设置为 隐藏标题type: # tech/story--- 文档系统（wiki）source 目录结构如下： .+ ├── _data+ │ ├── wiki+ │ │ └── hexo-cpp.yml+ │ └── wiki.yml ├── _posts │ ├── hello-hexo.md │ ├── hello-stellar.md │ └── hello-world.md ├── about │ └── index.md+ └── wiki+ └── cpp+ ├── backup.md+ └── index.md hexo-cpp.yml name: C++title: 学习指南subtitle: 从入门到再次入门tags: 博客主题icon: https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/icon.svgcover: https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/icon.svgdescription: 这是一份从入门到再次入门的学习指南。search: filter: /wiki/cpp/ placeholder: 在 Stellar 中搜索...leftbar: - tree - timeline_cpp_releases - relatedbase_dir: /wiki/cpp/tree: 快速开始: - index 网站备份: - backup wiki.yml - hexo-cpp index.md ---wiki: hexo-cpp # 这是项目id，对应 /data/wiki/hexo-cpp.ymltitle: c++--- sites 网站卡片 source 目录的文件结构如下： . ├── _data+ │ ├── links+ │ | └── tool-life.yml tool-life.yml 的内容如下: - title: 中国科学技术大学测速网站 url: https://test.ustc.edu.cn/ cover: icon: description: 非 WIFI 环境下慎点 在需要的位置添加如下内容： % sites tool-life % timeline 时间线静态时间线 在需要的位置添加如下内容: % timeline %!-- node 2021 年 2 月 16 日 --主要部分功能已经开发的差不多了。% image https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/photos/hello@1x.png width:300px ratio:1179/390 %!-- node 2021 年 2 月 11 日 --今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。% endtimeline % 侧边栏组件 参考链接：https://xaoxuu.com/wiki/stellar/widgets/ 在 source/_data 目录下新建 widgets.yml 文件 about_sidebar: layout: linklist columns: 1 items: - icon: svg.../svg # 或者 icons.yml 中设置的 icon 名称 title: 关于 url: /about/ - icon: svg.../svg # 或者 icons.yml 中设置的 icon 名称 title: 说说 url: /memos/ 在使用的地方，如 about/index.md中添加如下内容： ---leftbar: [about_sidebar]--- hexo","tags":["hexo"],"categories":["博客"]},{"title":"Hello Hexo","path":"/2025/09/30/0002-hello-hexo/","content":"本文描述的过程主要为如何在本地部署Hexo。在了解和熟悉本地部署的流程之后，更推荐利用 GitHub Actions 实现自动化部署 Hexo 到 Github Pages。 前置条件安装下列软件： Node.js Git 安装安装 hexo: npm install -g hexo-cli 查看版本： hexo v 创建创建 blog 文件夹mkdir blogcd bloghexo init 部署 hexohexo g 本地化预览hexo s 写作创建草稿hexo new draft hello-hexo # hello-hexo 为文件名 发布hexo publish hello-hexo # hello-hexo 为文件名 图片全局资源文件夹如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。 然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 文章资源文件夹将 config.yml 文件中的 post_asset_folder 选项设为 true post_asset_folder: true 在通过 hexo new [layout] title 命令创建新文章时，会自动创建一个与文章同名的文件夹。将所有与该文章有关的资源放在这个关联文件夹中之后，可以通过相对路径来引用它们。 相对路径引用的标签插件当打开文章资源文件夹功能后，把一个 example.jpg 图片放在资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](example.jpg) ，它将不会出现在首页上。 正确的引用图片方式是使用下列的标签插件 ： % asset_img example.jpg This is an example image %% asset_img spaced asset.jpg spaced title % GitHub Actionsname: Deploy Hexo to GitHub Pageson: push: branches: - main # 或你使用的默认分支名称jobs: deploy: runs-on: ubuntu-22.04 steps: - name: Checkout blog source uses: actions/checkout@v4 with: path: blog - name: Set up Node.js uses: actions/setup-node@v4 with: node-version: 22 # 设置 Node.js 版本 - name: Cache dependencies uses: actions/cache@v4 with: path: node_modules key: $ runner.os -node-$ hashFiles(**/package-lock.json) restore-keys: | $ runner.os -node- - name: Install dependencies run: npm install working-directory: ./blog - name: Install Hexo CLI run: npm install -g hexo-cli working-directory: ./blog - name: Install Hexo Theme run: npm install hexo-theme-stellar working-directory: ./blog - name: Generate static pages run: hexo generate working-directory: ./blog - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v4 with: personal_token: $ secrets.PERSONAL_TOKEN publish_dir: ./blog/public external_repository: username/username.github.io # 更改为你的 GitHub Pages 仓库, username 是你的用户名 publish_branch: main # GitHub Pages 分支 hexo","tags":["hexo"],"categories":["博客"]},{"title":"Hello World","path":"/2025/09/30/0001-hello-world/","content":"10d79030e8222445804370796b90fca1cf7dd2ee01010d95413afa643c36d75c6da7dc8584583c53132d123565a83bc482d57efe09dbb13f6be1ebadf67b396c5e9af14ae37a94b87d779719bc8c1cd1a95420a6d53586101970b6bd1e11383c5fb9eb6a2afd2dfd764940c736e232c31819ba63da4a7c6eb6c1003cc6443dcf2082b9f749ca03a1484b87b08c908b3c310d7b631064a7fc3f9ca36177e4c3059978875c3caa78a7dceb6037a9522caf5c4adf858dd97440561f76a5ba5e4fd77e9898dfeb4cad54c4bb643f9c0ecbaef49a3431bdd2455830a88255232397afbbe9b23eb9395dfae6f0824e03416bc0b3804386abdc6c923976a913424fdbf1ba89bde972822239ac5e9109f398b65ae65ef00629508a203d30649f6408e1f61f5f6e73d99349907d745bd4c4ef0763621826913a2677273e3b66ae19439d1940d9ebcc45d324738506f0ac5dca5093adf45b82a24da2d49432e9f7cea3b56d73ea8b80628014008c75e6df0aa070ccdaa53907f1adc5e6234b2ab2f7f8485fb9383dc64927d631e20713c7d719815e20c9d6247aa120998e681a19e43d40ca49e20ce7419d535072ff85e74c96caabe848f11f049126a6f4cbbfc746a3cae3d4b6c98db711e8b3bdbd372def67e3d1bf776ee35037a2377d5898704789976ec22fc47c64eb83da5766f0408afee5b438701c6084a1025c673100e7ac0cf710407782790b56679a3fbb40313022e90f715c1a39914fe4b710beb621310bee163ece727a9d02da8b2ef0925acbeedbed1bdf2fb2a5a106956f607dcb5fcef0e36a97afa6fe5d415be51d647cc196fec6186575845eba2577edf79b237f40501d9e0516fe26fcc18e5bb029218ceea51ed6571ed6499c1b863fe5e4184373aee7af54e687aecc3ffa4986afe90e3a5fd67d73f47c0c882443054fed1625259e96370f07d55431f1a03130d5486c9ac1bc2c51d48a7b31ca8c81fdd6cc8795e3296ee5cc4dd66f3e582583d5516a299f41c5bc32710ee392ddb18d02b9fea50df38fbea6579d1f8a7a1ec2fdcff1a546b8a51d96657a2c6538c2dc93476d69467cb3671b880c09d3c422cfb3bb9199050f0c77a137b4b0dbdb4041a1be97361f0b783b6ab8bbbdcfdf1c9d545e17a129eca1e4cc3aabe88b7ab633ec35eacbb26e1b4b8c0876bd6ed5f351cc4d04c974e55a4f37f0580b599953ae28a9a6f6ea344c8bee255996315fa0673b087d06f292b6f9e84801a38c8ffea05fecb03b16577db7697bbac072e1d372bf5fb0dfd48bdb369ba8ac97c5f3f8b3173cbee017a98e2eea5f78edd3ad8ae87ff061a3e43ccbb435291c501139a80744cf59040e4b980306c75cfb527b82fe4c578a8973a6a75baeb2be249b344f14cd6153f99e07309fee10b0e8e4702ded0dbde9bcc5b0eb0d117b479db98f93d36f1c8721a712a9650023572dd95effb7718f45c2948d9192a1d27b38e652903d68992618f4c9feee5c5dfc2fcb15fbf1d3fd5896245a14bc1bdabb6dddb4db0ea3fc36165bbc4b56ffbbb0ed570e77f7d8820a5078d5fe499945473ff216f85fe92c706d7aa308198dfcd4d85abe4f1fcb8924d6b5c72b05a03333c163fedfef1f479daeff26a1d99802645980fefa0f8be445851c3f508e0b5ee79b06b504a054b4e7ad26f9d0344d2395322d452565b03020d13fe150bbc9ca3e433e04e3411da56239b42807d0090d11b5858ff8487212fb6771f4914fdcd8393d2cd2150eb82d8e82be0db2e71679f2f78d5b22b32a305993748f09821838303b75df669acf24e08c3eab2fe0433662a1056cc392ccecc20041dbf44a229ada35bed43255979bfd7e150b6e812c6c23466dd45e57c5b443d976b298b5f5e4d977130bcaf5ec26e2e2c727886f3f116fd1fbad331bbf9d1ca9efa141a0174450b00f818e2b59a784a40b77918ba82e75a31bd542e611a43010f08fc30369e93386f239e5fb9a515d6c2afc272997890c0ec4619f78f4b5fed881f0002b85e8165088649391e0249613310e523cdf5e2dfd5d4b4236bf38c02fb72341cfe539508f7af5c7db00d07b8425db13d92aa628930b5521eba6daf54fce1a8a6a36e1b095f67ebadd2fb0c096012eee795a471f33f501a0fef0a9075dfce83a3227087b12382ff22011db6d7fc3cc877c19d425b5b672b574f4df7643bee516ecdc66629c21963733bea688bc205c9add0c36479130ca3eee5dc72698d00713bf52775cba1634cf4cdb9d5856c60135524af408c949847e6cce9729997a3858154a3cf638ec1f1d326b3caa59b6a3555f947a761998b37a3890339d86cf8eaaf75260de0475d5ba017d78d7e2671849c4f8924658a4fa3a6bb478e5dde99ccb965fc5f099418feda6e45cb85e810e253d8da0ec932b4f426793cb86b882291a6d98f048b162b71dd6888262a0e3d96caa0538f96845e3bddee62faf30f9b8e3176953e68652ed0b429f284bbd828de3d2c4815b2b69cd2f5cd993b1bcf65d2c8b67f3a5cc99dab9d029d01f9730eccf97c48dcfefbd9c3589bee7e98ebc76468ce1e4d47c4a4c89e275bb743892c4b8558d8ea957afa93b5ce2bd02f94ee38eb9fdcddcb8231584cc840b914a3eefe46c659029555aa0c43e523b507722c6753aa625f67b07ade89ad34eabd449f4c1d2822e0a0f435ce2602c2f5427dabec0f8cee68c5d64d9685cfc8e367505320dff6026c07f62ddb32c3039fe867067bcac7347b455893575e795974c91cd2b13bfe2341efd7b5e24b81aac898e60bb569def27c91bd3554bcf25d039002a7541daf01684f1aa4e4eb493a7ef9d3ab8c8489f98da8bf72989e524f97268729a6f437727d3354db4d2e5890f9b70fe2daa36cfbba178ccb0ead684e862eacb694e5c22f388c7d8b1f360f0459117529cf67e806255f61f71f840674c20c1b6c9b0ba4072bb7b1e19abec986c902fa25e735c93371dfb51ec15e9a2440cf886f29bc4e911d7c8925922efbc893b336161da60f33600143637d99e132a76da2087f75934b4997351f5e29ce8da8b847b61959afe5e9c612a2cc64730cf8dcb02cd15002ed3ec0088023a12023dcab79efe9d7f1f1d222b1193c79f0bab1a8e6a2dff9665327e827e675d76d3555cdc880e Hey, password is required here."},{"title":"关于我","path":"/about/index.html","content":"喜欢搜集有趣的东西。"},{"title":"探索","path":"/explore/index.html","content":"工具纸由我 PaperMe在线自定义打印纸生成器PDF24PDF工具中国科学技术大学测速网站非 WIFI 环境下慎点Notion 风格头像制作https://notion-avatar.app/zhWiFi 连接卡https://github.com/bndw/wifi-card 公开信息查询中国裁判文书网https://wenshu.court.gov.cn/合同示范文本库https://htsfwb.samr.gov.cn/专利查询世界知识产权组织的免费专利数据库wikiHow互联网上最值得信赖的指南网站 自用stellar 文档https://xaoxuu.com/wiki/stellar/#start闪卡导入 CSV 创建卡片引导城镇房屋租赁合同市场监管总局2025版云盘盘https://www.yppan.com/儿童睡前故事https://beddystories.com/zh中文播客榜https://xyzrank.com/"},{"title":"关于博客","path":"/about/blog/index.html","content":"2025 年 11 月 26 日使用 PicGo 将 Github 作为图床。2025 年 11 月 7 日增加评论功能。2025 年 9 月 30 日使用 hexo + stellar 重新部署博客。"},{"title":"说说","path":"/about/memos/index.html","content":"2025 年 12 月 8 日发现双十二买棉服价格更优惠，今年着实买早了。2025 年 12 月 3 日今年的第一份年度报告来自多邻国。2025 年 11 月 21 日发现最近很少去电影院了，上一次是今年2月去看的《哪吒2之魔童闹海》，上上次是24年6月。现在即便有想看的电影，也干脆等到上线流媒体平台了再看。2025 年 11 月 17 日手机在使用了半年后，电池循环154次，最大容量99%。2025 年 11 月 11 日今年的双十一让人有点摸不清下单的合适时间点，优惠力度也从原来的85折变成了9折。2025 年 11 月 4 日在晚上运动后，立刻开始整理《每天最重要的2小时》的读书笔记，感觉确实不错。这也能够驱使我晚上坚持运动。2025 年 10 月 30 日如何做一个有质量的技术分享：问题 - 方案 - 总结2025 年 10 月 29 日昨晚无意间刷到一个外卖员练习英语的视频，想到自己也可以下载一个多邻国试试。"},{"title":"最近听的播客","path":"/about/podcast/index.html","content":"2025 年 12 月 7 日成功向媳妇儿安利了《半拿铁·故事篇：西游篇》，她说比末世文有意思多了。2025 年 11 月 21 日最近听到的比较惊喜，也比较喜欢的一期《正经叭叭: vol.224 第一届叭叭KTV》。顺便说一句，谐星聊天会 YYDS。"},{"title":"探索v2","path":"/explore/special/index.html","content":"bd25ed9264b080267271e137e33d0ce1d0282572d5a8774de4a8591099effe6cbbea95011b5608b4d93057167f79e933c475fca1bf1861a6670a60b88626bd0db985a388d0ea9e70d50eefaeeae2f6d6df403787d817446b50a8cf9aa7cd47dd8d847a8d4edfe5811d14ca0ffecfe8d52b4c7b0a7c36ec403d29a7c872a4f2a18c36fd63a0c22de96b5a277b9c480019a81cf5c3a2f8f7a9de0ca906db1d86b4cd865e3e529d9e121d368c9ccb82155af0512d6c06f193565939d2739b6dcbd334372a1b06e87f28e9a434730d42f173a232ab132c05fe0795a6e09c1bc12f337ccfe1645c0f710796d4d7bfeece8f9d0db697669dafe211c3005a71b127eabe431eaa931f1faca0c04f551fa3f1d1f2179992d0f1297f4b95e0e81534a2bf3a0a580728b84fd3ba79eac3f51cfe0a5562cec70a8b9b87bfcc80f672744e0ff6fca076a3ab90031505dae536bc0792f48e4a2c2cd8b7f9bed5c7f1c68de760bfdc9dbc78cffb8d6740bec24c2a05f17d60e105fabff8132383de8b056ab4a503df34dbdee50ed94aa6d702d62b8d4d9ee044fb18dfce6cabde08c28f6038725fd28d5474cffebb40a2c5946329561ecc58b9c4b84bd5e92e457db576c5b58d9346630550451bce27272d09ee1eb34b0056a407d48285dda25fae7a1ca0c9cef2324a5adfbf55048d6ec43845f5eb9b4d1d618c04f1378cdae2fbcc2029e707193eba419a962a814cceae82e990ac4ce181af042a4f6b9ccea2e03fabfac4100a8f8d8a41e3b58817c0d30333619aa3db3e1518ca70d5c92a8949f459ba5c75908db0a18283286bc124e9c0c852962849362017076e37ac0d85e0aa537a929f11e301ccf5ed5171802cd095acf969dceb3d2e7245ce17b8bda376ca718d8ee844be4d03d0d227e05b0e0edfd9b43eb27ca8eb7af9f383e37499f75aaf73b2e116bc8b682fbf8147ae23ec4acff889497aca4593654b7bf255774844447d1a3547afd6402c17bea0a941d8fc826e681f821b26a49bb8e19dc206ca2866d1b7bc4cd75fd80241c33f3b0685df123aa43c591a6b725b162d20332f5848f657395e7457303a32a61be095ba98590b350f583414cff58fb90d610649f1b0875e27e87a30582442c9af90eb4d8a10f9061448e235e0a1dc9b57058d5dc7f227dd78d41f3cefe8175804c5fee823ba9c8f08696379b616f3e26da3a98f0afcc96b707507fc825c19e476772e7d09ee6f8662587d0ec142397d7c5a300c9da3c95a8bfd13643aa23a2637adede9adcfec29dda04936a89d1936d3b2f3849d2a36fabb313eb37d7fc91c62db8c351ac795e65a8c80c2a545c9eb9c0e24845c5dc326fa6441643600c136f8387b088681862646631685b62041975ef46ffc1ac8efef1b93fd5aff02210cfb72e5b5d9391133803318cb05eb60b11fa24f5c084806576d7ac51abfc9fde75eb6a6b41672f2d0cdd954efb4e368ef795cf62c6d94cb849a6efa828722d6d51bb1d6c8c52c54075dc1b8a3095d83e61e954476143d5fa3c7b7bc3a5abf4f01b18104f0ad6f408821ba3b4c0272f526e5ae2991f925a4f5eaf811aceda0125667e7490fcdcf6d08a8130f5ed68e7e554e5ff35d3264a625e464ce170c2c3c2b4a1693b5cbd910690f7a1fff34ecaf3e1b3bd489c0765cbe3dc0196f2a4a0ead3661948e917aa650c15cff4f57f4fbb3ca380d7f0f3c4f0f6e602827202aea54849af7a956598a2704839dbe8ae67beb26c2a8e63d13bab049d67efe2cc41f4ab93aa6f8961148cb5379ff08d9778aee54638412eb2d1410d3f763bca09216719015bfb80f5f1e86cf0adc2fe873e11526e71aa6dfb5cb2dfa0039337744f6c412c1e297523897deaad66d17956172fe13c33da5feafda85b6916066711650d77eac1af2ebca7aac76cecdf68280faba0e6b0ee32a55b1ebd8f051442f63a10bff24fa566e7e0270d9e33a62977ab849a044ef5e364edd20d43100f7f43819060dad0cca24868a69cc553aec66d515d23f94ec1a886d7c36684f044ea8c7a3eb93e91ed96268b45ac96836afe0d6a3693de3ed7858e8d70997262f08c12d60a941a064205bd2509c224f0d54ef8cddfdc3ea4d986e167dd1890f53baef24a88104274e99a75ae34c516584da84a8cb4d6b6a9da859770bc83ddfa5b74e51090aee2f88c47332ad3660cbc88af2b746678ca271e5b3f8fb3b005d9966e51b0ada77bf51699185caebfb26e2f0e27cb06a7b85e7ca318adb50e68912dedeb4696447281385c013edcb39f561623133afabd6a27ba0b365f36d1ef3afea05cb1bcc657727a4c1f113a71ad3924c54c699ced3a0f367ec017c0eaeaeddb768a113394a6e8c0a6e43fb9b98c838b8ba2f37f2ec2fe63725c483a71a496fcc26a8aecf75d9c956b182904c315893bc2b847b59cad66740843eec97b68f70c85c55ce935a3fb6a6b77e9736e3b548917c982b989bf88901cdb847d838a29b5d3447e63be3e37586ecbb558514f7b3b5c9ce259c183e25febdf2bb9910fc0ede28c0fdbb7ae6109b1551fae8de11cbb8ea7d08b8bcb7fb251265d36f4a6f109124ae8d5a31570a1a3999dd925854f671d8ac2c131739f096171a7347f0820e88a6298f64df60baf372a7a3cdbeb8a18995153ddeed8e1d0285982108f1c78cadf1bc9bf9b7baf0d5495b99aa8f094f8136ad5cae534941ca38754862b037da72e777b9809df70c913c32c0d17a6bb71025209ee58fd3ad8369b209fd8839dc409e76039ff18a927d228670a65ec170f1f97654d931d0b84fbcf2615095f6a9dca1b631ad78a475caab0a6f5064a4db081fbe6d8053a9b66f05704130c7cd95627cd88f899a29a7bc897f0cdf335f355b897cec678e53d57bb71a304168db91531c5cc337436cfff4dd12485149bc681f9ea04e385705cb95efb4d76965232b4b0c3fa2be80a1c72477aa4826d9ddc5913d2df7d8e435aa296deb3cdd7bfa31e1138fb13d6a2f406865370f6142e74c9631dbeb00d039d673ee2085bd36197b8317cff1cdce79edbec9701b03304b757c21063c3f7b45fc085339f869de796514bda3d745edce8ee4552f3b23f15cf4e41cb1510668a01f239d6e1feb0c7330634d3e2b85bef21e9f2d31e7f44910f49a7aad312ba42982df03fb89d6a896284582499043e7de746695466a5dafd4de9684995b592fbcebd3163b6192602d9b9fddc230e540bfc03d57c63fda0bf827d7dd927f8573d5642a74ed8d999c795f425335de0bf82a4b8af2b18adc99f999df7c88933bbbed3298a0ef3177cc6c7d3bf45a35b7095ed559bce14689d3fba5e4cbe16bf1b6c9d284aec8029ba47966fa89cacd96327fef7367d0e9a5ca0b48599312efb7e29c9ccf768c9d4bd3da1f332c45052a9a99d3a255239af340f7113666becf598469f29e3d0f84e6e6778992e78c70f4f2c428018026e71b32d4062fb1d70ee31e5fb8203344ee20c94b98fd7ce52cafbe42c6a8b2dbb4498fe08655a8d865561cdd6189be43844c379dfd62176e0d8db83be8eed4ff229505b3246c20f50b740bb091917201c4925cf1d4d8cdf1b77930b7f757137e4991f1c3b1a4cfaf53e0803d20a6ed8364abf2d685c9b32b00fdf9329151039628530f610e64c40c9cf496a61ae1e2d3087d11b1856d1914e3eccca7a1111e09b713d7cf0500a3f33d6512d6f36351b2fd0c370175863ca124bf8722f3264dfbc600ea346e132f71576db819f7ab25165f4de384728e78d57d0348677019deadf35bf58997e8de89effe1261eba4a94f1de092b2272fb9989c928d9bb8ef673189f9ab6d7ae5c82eba033cdac7a1a99a635a5f67c2cde7b15a04d805eae906202227a9dfdfffe192f6e0ce73a1b64b027ac89acf2fe3665ec0f8deae4e7b05870beba472d5eedb0d4e58bc4df2d9def3fdc28b8b43c4fb1393118a0eeda37ff3954b016d33104b3586aaaf73f60cfb7e35ed4e594049ce2d7cd28a2d44631da11e54856c2208e4b60eafc05f510f5d431d8a602a2ab41a936f5e7281f565be887a7d93ac678652963b99b6d76aea3211db4d50534f390805058cb50ed25998b915bf779e2f4b831ae5a830f88052e71c231df204c5339a2f0cd6e95ff6960ec371fd1ecb3f616a44f5b79488336d6ba8b2142a7c750633d930f2f56f582aaa99ceda91d7a3d5e07ad36c2d68226ce21dac101e62187bfcf4faa847a78165acbd6ab32fd5f41803fae957fd75993d22dd9f39125261397ed037c666792acb3337fa264d4e8bfb0598a3285df9ee9501ca67e0ade3a2766fb612e11f6a0ee7d45d21cb84c71ae9dd6e6506d2e16ecd6f2fe1a122f27be3ba02c23d6135182fc3134783adeb0fd39cfa539dee61bd0772eb73ee271739b910a96d47464d58536cc380925db6a86053db23f061c9e75bcffa685397025f34ca23125d7e29993812152a2a5b7c7b863a85af5980aad117372e01acddf066105daf42d1eddc2dea6d470d0583209ddeaddc88dcad9062eb954ae1cc05876c50338e10178e16543520130716062e3170ca50dd57d32688101c811a5f84fc408b5c2352017389fdbd12ec5e86eafb6eafd3267fffa56504ee3da74efb54f304a5b5eeda2f23528f86c0b8c0e4bf375bbd6426c940ba350914275143ab04d465b1949ec103622c7dc654cfd41a7844f45d460ca67270b6e383efd1eb65b2519b2d9550f746a0002dffe89765b577790225587a2f79dd21a38a51b54f267ffcf051b3678b27c4838c6b9270e66d51ab3785e93fc42650b4d2a0732d0f69995417a66aebdc615b5f47e72ce4c0ed191ce344e57251b0c4856e0447c2773802ef63b7faa22da83a7b258acbe1b63dbeb94e05f56371ec3b8c8d03f0f3b70bc5c93b60a4a23ff7520006b1e4534f581ed000401cf8d7608c1db40c9a90c0954182532669a332e5bd13c9a15efb3a16cd31a3cf7412583925ab5a1f78a2347bbb340f24f4d1862be7085b68c6042a0556002298e53dd6d86224469a99771f0c1e13e84073b76ceb0b472ad9f0dd7934ac61b8 关注公众号，获取密码。"},{"title":"todo","path":"/wiki/cpp/cpp-todo.html","content":"计算机基础实战课 Linux 201: 问题调试"},{"title":"index","path":"/wiki/cpp/index.html","content":"工具DeepWikihttps://deepwiki.com/PlantUMLhttps://plantuml.com/zh/CS 自学指南https://csdiy.wiki/TemplateRepoCxxVS Code C++项目模板Linux Manpagesman 手册Linux 内核源码在线版Linux工具快速教程https://github.com/me115/linuxtools_rstHelloGitHub发现和分享有趣、入门级开源项目的平台 C++恋恋风辰的官方博客https://llfc.club/homeCppGuide社区https://cppguide.cn/c++自救指南后端自救手册c++全栈知识体系https://stibel.icu/阿荣的个人网站https://www.arong-xu.com/ linux开发内功修炼https://kfngxl.cn/熊喵君的博客https://pandaychen.github.io/文先生的博客https://wenfh2020.com/ArthurChiao's Bloghttps://arthurchiao.art/articles-zh/Linux 201 进阶教程中国科学技术大学 Linux 用户协会 other技术文章摘抄https://learn.lianglianglee.com/深入高可用系统原理与设计https://github.com/isno/theByteBookTCP/IP详解 卷1：协议在线阅读版（全网唯一）无处不在的小土个人很喜欢的博客"},{"title":"interview","path":"/wiki/cpp/interview.html","content":"CVLapisCVhttps://github.com/BingyanStudio/LapisCV 八股阿秀的学习笔记https://interviewguide.cn/小林codinghttps://xiaolincoding.com/卡码笔记https://notes.kamacoder.com/CS_Offerhttps://github.com/selfboot/CS_Offer 刷题代码随想录https://github.com/youngyangyang04/leetcode-master 面试反问面试官技术面试最后反问面试官的话"},{"title":"编译与运行","path":"/wiki/cpp/tws-build.html","content":"开发环境 WSL2 + Ubuntu-24.04 mysql-8.0.43 MySQL 安装与配置 mysql-server 安装 sudo apt-get updatesudo apt-get install mysql-server# 查看 mysql 的版本mysql --version 客户端库开发包安装，提供头文件和链接库 sudo apt-get install libmysqlclient-dev 数据库建立登录 MySQL 服务# 远程mysql -h localhost -P 3306 -u root -p# 本机mysql -u root -p 可能会遇到如下报错信息： ERROR 1698 (28000): Access denied for user root@localhost 这是因为MySQL默认使用了 UNIX auth_socket 插件进行认证。解决方案可参考：stackoverflow。 这里使用回答中推荐的第2种方案，即创建一个与系统用户一致的新的数据库用户： 注意：tws 可修改为自定义用户名 $ sudo mysql -u rootmysql USE mysql;mysql CREATE USER tws@localhost IDENTIFIED BY ;mysql GRANT ALL PRIVILEGES ON *.* TO tws@localhost;mysql FLUSH PRIVILEGES;mysql exit;$ sudo service mysql restart 之后登录 MySQL 服务就可以使用如下命令： $ mysql -u tws -p# 默认没有密码，回车即可登录 建立数据库$ mysql -u tws -p# 建立 twsdb 库mysql create database twsdb;# 创建 user 表mysql USE twsdb;mysql CREATE TABLE user( username char(50) NULL, passwd char(50) NULL)ENGINE=InnoDB;# 添加数据mysql INSERT INTO user(username, passwd) VALUES(admin, 123456); 编译代码修改 修改 main.cpp 中的如下内容: //需要修改的数据库信息,登录名,密码,库名string user = tws;string passwd = ;string databasename = twsdb; build$ chmod +x build.sh$ ./build.sh 运行run./server 服务访问 访问地址: http://127.0.0.1:9006/ 用户名: admin 密码：123456 其它MySQL 常用命令# 启动、关闭、重启 MySQL服务sudo service mysql startsudo service mysql stopsudo service mysql restart# 查看MySQL服务状态sudo service mysql status MySQL 用户认证方式查询$ sudo mysql -u rootmysql USE mysql;mysql SELECT User, Host, plugin FROM mysql.user;+------------------+-----------+-----------------------+| User | Host | plugin |+------------------+-----------+-----------------------+| debian-sys-maint | localhost | caching_sha2_password || mysql.infoschema | localhost | caching_sha2_password || mysql.session | localhost | caching_sha2_password || mysql.sys | localhost | caching_sha2_password || root | localhost | auth_socket || tws | localhost | auth_socket |+------------------+-----------+-----------------------+6 rows in set (0.00 sec) MySQL 删除用户mysql DROP USER tws@localhost;"},{"title":"功能梳理","path":"/wiki/cpp/tws-run.html","content":"00dd9c2c5c86dd0e1f8ce0e685de9f4ff0bd2a56b95edad86511c5d02f488f316760d7dce49fb836b51504758de8a211bcd2581eb7031339f7b407da5ff4892311b90f8085c0eb62976161580f45d9decaffdd630d0b7e470339139dd2bf6d39da932996dacfd2d0ac9ee14301c9aa0b551c4d96c7623025beaec65e203deb4cf73224719b44c3e4ea14b6bccb8ff50ffb7941f8393e53bdcbfdf526a403f8e5f8995133dfd83d3d6cb0b8a541804bceaa7f4c67d5db1dcb6f6a953b2c1ccaa42314d19667556223745996bc816d7e5698a572ded5593ef5e60eaebe1c202dafb1e6c7f41fac7c9fee6b8d711e30338dda764fc1239c4778854a251070b4834ca10cad61ae4a7d9976f56d0562a9548686a618c58319b5720b6004e6ce86de71e959ed53745df52a383d410ac18730d8b8ad1cec042e1e11b012cf8c631485a9dc49c6993bb17245ac555775f488fa21 Hey, password is required here."},{"title":"压测","path":"/wiki/cpp/tws-webbench.html","content":"保证 server 运行./server 压测$ cd test_pressure/webbench-1.5./webbench -c 500 -t 5 http://127.0.0.1:9006/Webbench - Simple Web Benchmark 1.5Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.Benchmarking: GET http://127.0.0.1:9006/1000 clients, running 5 sec.Speed=220188 pages/min, 411152 bytes/sec.Requests: 18349 susceed, 0 failed. QPS 是什么： QPS（Queries Per Second，每秒查询率）是衡量系统吞吐量的核心指标，代表服务器每秒能处理的有效请求数量。 QPS 如何计算： QPS = 总有效请求数 ÷ 总耗时（秒） 因此，上述压测的 QPS 18349 5 3669. webbench 原理 父进程 fork 若干个子进程，每个子进程在用户要求时间或默认的时间内，对目标 web 循环发出实际访问请求 父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息 子进程在时间到后结束；父进程在所有子进程退出后，统计并给用户显示最后的测试结果，然后退出"},{"title":"WSL 常用命令","path":"/wiki/cpp/wsl-cmd.html","content":"列出所有已安装的WSL发行版wsl --list --verbose 卸载某个WSL发行版wsl --unregister Ubuntu-18.04"},{"title":"介绍","path":"/wiki/cpp/tws.html","content":"项目地址： https://github.com/qinguoyi/TinyWebServer 参考资料： https://deepwiki.com/qinguoyi/TinyWebServer 小白视角：一文读懂社长的TinyWebServer(Raw_Version) ZWiley的随记: WebServer项目"},{"title":"WSL 开发环境配置","path":"/wiki/cpp/wsl-dev.html","content":"可根据需要选择安装 sudo apt install git cmake gdb build-essential clang clang-tidy \\ clang-format pkg-config tcpdump tshark"},{"title":"bpftrace","path":"/wiki/ebpf/bpftrace.html","content":"项目地址bpftracehttps://github.com/bpftrace/bpftrace 列出可用的跟踪点和 kprobesbpftrace -l *execve* bpftrace -e kprobe:do_execve @[comm] = count(); 列出 libc.so.6 里所有的 USDT 探针bpftrace -l usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:* | grep setjmp 读取 libc.so.6 文件中的 NOTE 段内容 readelf --notes /usr/lib/x86_64-linux-gnu/libc.so.6 | grep -A10 setjmp 使用场景参考：libbpf-bootstrap-usdt"},{"title":"WSL 安装","path":"/wiki/cpp/wsl-install.html","content":"1. 以管理员身份打开 Windows PowerShell 启用 WSL 功能 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用虚拟机功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 2. 重启计算机3. 下载并安装 WSL 2 的 Linux 内核更新包 打开 PowerShell，运行以下命令 wsl --update 4. 设置 WSL 2 为默认版本 打开 PowerShell，运行以下命令 wsl --set-default-version 2 5. 通过 Microsoft Store 安装 Ubuntu 或其他 Linux 发行版 开始使用 WSL"},{"title":"bpftool","path":"/wiki/ebpf/bpftool.html","content":"项目地址bpftoolhttps://github.com/libbpf/bpftool FEATURE 获取可用当前内核版本中每种程序类型的辅助函数的列表 bpftool feature MAP查看加载到内核中的 mapbpftool map list 165: array name hello.bss flags 0x400 key 4B value 4B max_entries 1 memlock 4096B btf_id 254166: array name hello.rodata flags 0x80 key 4B value 15B max_entries 1 memlock 4096B btf_id 254 frozen 查看 map 的内容bpftool map dump name hello.bss [ value: .bss: [ counter: 11127 ] ] PROG将程序加载到内核中bpftool prog load hello.bpf.o /sys/fs/bpf/hello 查看发生的重定位bpftool -d prog load hello.bpf.o /sys/fs/bpf/hello 查看已加载的程序bpftool prog list BTF生成内核头文件bpftool btf dump file /sys/kernel/btf/vmlinux format c vmlinux.h 查看加载到内核中的所有 BTF 数据bpftool btf list 查看某个 BTF 数据的内容bpftool btf dump id id 查看特定 map 关联的 BTF 类型bpftool btf dump map name config 查看特定程序关联的 BTF 类型Usage: bpftool btf show | list [id BTF_ID] bpftool btf dump BTF_SRC [format FORMAT] [root_id ROOT_ID] bpftool btf help BTF_SRC := id BTF_ID | prog PROG | map MAP [key | value | kv | all] | file FILE FORMAT := raw | c [unsorted] MAP := id MAP_ID | pinned FILE | name MAP_NAME PROG := id PROG_ID | pinned FILE | tag PROG_TAG | name PROG_NAME OPTIONS := -j|--json [-p|--pretty] | -d|--debug | -B|--base-btf bpftool btf dump prog id 51bpftool btf dump prog name hello 查看目标文件中的 BTF 数据bpftool btf dump file hello-buffer-config.bpf.o NET将程序从网络接口 eth0 分离（detach）bpftool net detach xdp dev eth0 查看网卡已挂载的 BPF 程序ip link show 1: lo: LOOPBACK,UP,LOWER_UP mtu 65536 xdpgeneric qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 prog/xdp id 124 name ping tag 3c91b2e4d4590b11 jited 列出挂载到网络栈的 BPF 程序bpftool net list PERF查看附加到 perf 相关事件的程序bpftool perf show bpftool perf list"},{"title":"WSL2 安装 BPF 工具链","path":"/wiki/ebpf/ebpf-install.html","content":"https://cardioid-line.github.io/ubuntu-an-zhuang-bcc-zhi-nan/"},{"title":"时间线","path":"/wiki/ebpf/ebpf-timeline.html","content":"todo BPF ring buffer：使用场景、核心设计及程序示例 BPF 进阶笔记 2025.11.21 - now 运行 libbpf-bootstrap 中的示例代码，回顾 《Learning eBPF》 中的相关内容 Learning eBPF: 03. Anatomy of an eBPF Program Learning eBPF: 05. CO-RE, BTF, and Libbpf 2025.11.04 - 2025.11.19 通读 《Learning eBPF》"},{"title":"index","path":"/wiki/ebpf/ebpf.html","content":"web eBPF.io eBPF Docs github bcc btfhub bcc: libbpf-tools Tutorial libbpf-bootstrap eunomia-bpf: eBPF Developer Tutorial blog Linux Extended BPF (eBPF) Tracing Tools 👍 Head First eBPF 酷壳: eBPF 介绍 (2022) Learning eBPF the Hard Way: 从 nginx eBPF 的实现说起 (2025) BPF 学习路径总结 (2021) Linux超能力BPF技术介绍及学习分享 (2020) eBPF技术实践白皮书 (2023) GREEN MEMORY: eBPF学习笔记 (2021) 👍 觅梦随笔: #EBPF (2025) 👍 selfboot: #eBPF (2023) eBPF 核心技术与实战 (2022) 性能调优：性能调优工具eBPF和调优方法 bookLearning eBPF Learning eBPF (2023) Learning eBPF Chinese version (⭐26) online version Learning eBPF Chinese version (⭐2)"},{"title":"00. Running the example code","path":"/wiki/ebpf/learning-ebpf-00.html","content":"项目地址：https://github.com/lizrice/learning-ebpf env WSL2 Ubuntu 24.04 sudo apt-get install git cmake gdb build-essential sudo apt-get install clang clang-tidy clang-format pkg-configsudo apt-get install llvmsudo apt-get install libclang-devsudo apt-get install zlib1g-devsudo apt-get install libelf-dev Install this repogit clone --recurse-submodules https://github.com/lizrice/learning-ebpfcd learning-ebpf Building libbpf and installing header filescd libbpf/srcmake install cd ../.. Building bpftoolcd ..git clone --recurse-submodules https://github.com/libbpf/bpftool.gitcd bpftool/src make install"},{"title":"01. What Is eBPF, and Why Is It Important?","path":"/wiki/ebpf/learning-ebpf-01.html","content":"eBPF 是一种革命性的内核技术，允许开发者编写自定义代码并动态加载到内核中，从而改变内核的行为。这种技术使得新一代高性能网络、可观察性和安全工具成为可能。 使用 eBPF 可以做的事情包括但不限于： 几乎对系统的任何方面的性能追踪 具有内置可见性的高性能网络 检测并（可选地）阻止恶意活动 eBPF’s Roots: The Berkeley Packet Filter我们今天所说的 “eBPF” 起源于 BSD 数据包过滤器 (BSD Packet Filter)，最早在 1993 年的一篇论文中提出。 该论文讨论了一种能够运行过滤器的伪机器，这些过滤器是用来决定是否接受或拒绝网络数据包的程序。这些程序是用 BPF 指令集编写的，这是一组通用的 32 位指令，与汇编语言非常相似。 ldh [12]jeq #ETHERTYPE IP, L1, L2L1: ret #TRUEL2: ret #0 这段简短的代码过滤掉不是互联网协议（IP 协议）的数据包。 该过滤器的输入是一个以太网数据包，第一条指令（ldh）从该数据包的第 12 字节开始加载一个 2 字节的值。 指令（jeq）将该值与代表 IP 数据包的值进行比较。如果匹配，则执行跳转到标记为 L1 的指令，并通过返回一个非零值（这里标识为 #TRUE）来接受数据包。 如果不匹配，则数据包不是 IP 数据包，通过返回 0 来拒绝该数据包。 您可以想象（或参考该论文找到示例）更复杂的过滤程序。重要的是，过滤器的作者可以编写自己的自定义程序在内核中执行，而这正是 eBPF 的核心功能。 BPF 是指 “Berkeley Packet Filter”，它首次引入 Linux 是在 1997 年的内核版本 2.1.75 中，作为一种高效的捕获数据包的方法用于 tcpdump 工具。 2012 年，seccomp-bpf 在内核版本 3.5 中引入。这使得 BPF 程序可以用来决定是否允许用户空间应用程序进行系统调用。"},{"title":"02. eBPF’s “Hello World”","path":"/wiki/ebpf/learning-ebpf-02.html","content":"NOTE:Since eBPF is so powerful, it requires special privileges to use it. Privileges are automatically assigned to the root user, so the easiest way to run eBPF programs is as root, perhaps by using sudo. 2.1 BCC’s “Hello World”int hello(void *ctx) bpf_trace_printk(Hello World!); return 0; All the eBPF program does is use a helper function, bpf_trace_printk(), to write a message. the bpf_trace_printk() helper function in the kernel always sends output to the same predefined pseudofile location: /sys/kernel/debug/tracing/trace_pipe. 2.2 Running “Hello World”2.3 BPF Mapsa much better way to get information out of an eBPF program 2.3.1 Hash Table MapTypical uses include the following: User space writing configuration information to be retrieved by an eBPF program An eBPF program storing state, for later retrieval by another eBPF program (or a future run of the same program) An eBPF program writing results or metrics into a map, for retrieval by the user space app that will present results BPF_HASH(counter_table);int hello(void *ctx) u64 uid; u64 counter = 0; u64 *p; uid = bpf_get_current_uid_gid() 0xFFFFFFFF; p = counter_table.lookup(uid); if (p != 0) counter = *p; counter++; counter_table.update(uid, counter); return 0; 2.3.2 Perf and Ring Buffer MapsPerf MapsBPF_PERF_OUTPUT(output); struct data_t int pid; int uid; char command[16]; char message[12];; int hello(void *ctx) struct data_t data = ; char message[12] = Hello World; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); bpf_probe_read_kernel(data.message, sizeof(data.message), message); output.perf_submit(ctx, data, sizeof(data)); return 0; Ring Buffer2.3.3 Function Callsinlined function 2.3.4 Tail Callstail calls can call and execute another eBPF program and replace the execution context, similar to how the execve() system call operates for regular processes. Tail calls allow for calling a series of functions without growing the stack. This is particularly useful in eBPF where the stack is limited to 512 bytes. Tail calls are made using the bpf_tail_call() helper function, which has the following signature: long bpf_tail_call(void *ctx, struct bpf_map *prog_array_map, u32 index) This helper is somewhat unusual in that if it succeeds, it never returns. The helper could fail, for example, if the indicated program doesn’t exist in the map, in which case the calling program carries on executing. BPF_PROG_ARRAY(syscall, 500);int hello(struct bpf_raw_tracepoint_args *ctx) int opcode = ctx-args[1]; syscall.call(ctx, opcode); bpf_trace_printk(Another syscall: %d, opcode); return 0;int hello_exec(void *ctx) bpf_trace_printk(Executing a program); return 0;int hello_timer(struct bpf_raw_tracepoint_args *ctx) int opcode = ctx-args[1]; switch (opcode) case 222: bpf_trace_printk(Creating a timer); break; case 226: bpf_trace_printk(Deleting a timer); break; default: bpf_trace_printk(Some other timer operation); break; return 0;int ignore_opcode(void *ctx) return 0; 2.4 Summarytodo 2.5 Exercisestodo"},{"title":"03. Anatomy of an eBPF Program","path":"/wiki/ebpf/learning-ebpf-03.html","content":"3.1 The eBPF Virtual MachineJIT (just-in-time) compilation 3.1.1 eBPF RegistersThe eBPF virtual machine uses 10 general-purpose registers, numbered 0 to 9. Register 10 is used as a stack frame pointer (and can only be read, but not written). include/uapi/linux/bpf.h /* Register numbers */enum BPF_REG_0 = 0, // The return value from the function\tBPF_REG_1, // The context argument to an eBPF program\tBPF_REG_2,\tBPF_REG_3,\tBPF_REG_4,\tBPF_REG_5,\tBPF_REG_6,\tBPF_REG_7,\tBPF_REG_8,\tBPF_REG_9,\tBPF_REG_10,\t__MAX_BPF_REG,; Before calling a function from eBPF code, the arguments to that function are placed in Register 1 through Register 5 (not all the registers are used if there are fewer than five arguments). 3.1.2 eBPF Instructions include/uapi/linux/bpf.h struct bpf_insn __u8\tcode; /* opcode */\t__u8\tdst_reg:4;\t/* dest register */\t__u8\tsrc_reg:4;\t/* source register */\t__s16\toff; /* signed offset */\t__s32\timm; /* signed immediate constant */; This bpf_insn structure is 64 bits (or 8 bytes) long. When loaded into the kernel, the bytecode of an eBPF program is represented by a series of these bpf_insn structures. 3.2 eBPF “Hello World” for a Network Interface#include linux/bpf.h#include bpf/bpf_helpers.hint counter = 0;SEC(xdp)int hello(struct xdp_md *ctx) bpf_printk(Hello World %d, counter); counter++; return XDP_PASS;char LICENSE[] SEC(license) = Dual BSD/GPL; XDP_PASS: This is the verdict indicating to the kernel that it should process this network packet as normal. 3.3 Compiling an eBPF Object File Makefile: %.bpf.o: %.bpf.c\tclang \\ -target bpf \\ -I/usr/include/$(shell uname -m)-linux-gnu \\ -g \\ -O2 -o $@ -c $ 3.4 Inspecting an eBPF Object File$ llvm-objdump -S hello.bpf.o 3.5 Loading the Program into the Kernel$ bpftool prog load hello.bpf.o /sys/fs/bpf/hello$ ls /sys/fs/bpfhello 3.6 Inspecting the Loaded Program$ bpftool prog list $ bpftool prog show id 540 --pretty id: 540, type: xdp, name: hello, tag: d35b94b4c0c10efb, gpl_compatible: true, loaded_at: 1659461987, uid: 0, bytes_xlated: 96, jited: true, bytes_jited: 148, bytes_memlock: 4096, map_ids: [165,166 ], btf_id: 254 3.6.1 The BPF Program TagThe ID can vary every time you load or unload the program, but the tag will remain the same. bpftool prog show id 540bpftool prog show name hellobpftool prog show tag d35b94b4c0c10efbbpftool prog show pinned /sys/fs/bpf/hello 3.6.2 The Translated Bytecode$ bpftool prog dump xlated name helloint hello(struct xdp_md * ctx):; bpf_printk(Hello World %d, counter); 0: (18) r6 = map[id:165][0]+0 2: (61) r3 = *(u32 *)(r6 +0) 3: (18) r1 = map[id:166][0]+0 5: (b7) r2 = 15 6: (85) call bpf_trace_printk#-78032; counter++; 7: (61) r1 = *(u32 *)(r6 +0) 8: (07) r1 += 1 9: (63) *(u32 *)(r6 +0) = r1; return XDP_PASS; 10: (b7) r0 = 2 11: (95) exit 3.6.3 The JIT-Compiled Machine Code$ bpftool prog dump jited name helloint hello(struct xdp_md * ctx):bpf_prog_d35b94b4c0c10efb_hello:; bpf_printk(Hello World %d, counter); 0: hint #34 4: stp x29, x30, [sp, #-16]! 8: mov x29, sp c: stp x19, x20, [sp, #-16]! 10: stp x21, x22, [sp, #-16]! 14: stp x25, x26, [sp, #-16]! 18: mov x25, sp 1c: mov x26, #0 20: hint #36 24: sub sp, sp, #0 28: mov x19, #-140733193388033 2c: movk x19, #2190, lsl #16 30: movk x19, #49152 34: mov x10, #0 38: ldr w2, [x19, x10] 3c: mov x0, #-205419695833089 40: movk x0, #709, lsl #16 44: movk x0, #5904 48: mov x1, #15 4c: mov x10, #-6992 50: movk x10, #29844, lsl #16 54: movk x10, #56832, lsl #32 58: blr x10 5c: add x7, x0, #0; counter++; 60: mov x10, #0 64: ldr w0, [x19, x10] 68: add x0, x0, #1 6c: mov x10, #0 70: str w0, [x19, x10]; return XDP_PASS; 74: mov x7, #2 78: mov sp, sp 7c: ldp x25, x26, [sp], #16 80: ldp x21, x22, [sp], #16 84: ldp x19, x20, [sp], #16 88: ldp x29, x30, [sp], #16 8c: add x0, x7, #0 90: ret 3.7 Attaching to an Event$ bpftool net attach xdp id 540 dev eth0 view all the network-attached eBPF programs: $ bpftool net listxdp:eth0(2) driver id 540tc:flow_dissector: $ ip link trace output: $ cat /sys/kernel/debug/tracing/trace_pipe or: $ bpftool prog tracelog 3.8 全局变量eBPF map 是一种可以从 eBPF 程序或者用户空间访问的数据结构。 同一程序的不同流程可以多次访问同一个 map，多个程序也可以访问同一个 map。由于这些特性，eBPF map 可以作为全局变量使用。 NOTE:eBPF 在 2019 年才支持全局变量。 查看加载到内核中的 map $ bpftool map list165: array name hello.bss flags 0x400 key 4B value 4B max_entries 1 memlock 4096B btf_id 254166: array name hello.rodata flags 0x80 key 4B value 15B max_entries 1 memlock 4096B btf_id 254 frozen 查看 map 的内容 在从 C 程序编译的目标文件中，bss 段通常保存全局变量 $ bpftool map dump name hello.bss[ value: .bss: [ counter: 11127 ] ] 只有当 BTF 信息可用时，bpftool 才能美观地打印出 map 中的字段名；而要包含该 BTF 信息，需在编译时添加 -g 标志。 $ bpftool map dump name hello.rodata[ value: .rodata: [ hello.____fmt: Hello World %d ] ] 3.9 Detaching the Program 将程序从网络接口分离（detach） $ bpftool net detach xdp dev eth0 列出挂载到网络栈的 BPF 程序 $ bpftool net listxdp:tc:flow_dissector:netfilter: 但是，程序仍加载在内核中： $ bpftool prog show name hello395: xdp name hello tag 9d0e949f89f1a82c gpl loaded_at 2022-12-19T18:20:32+0000 uid 0 xlated 48B jited 108B memlock 4096B map_ids 4 3.10 Unloading the Program目前，还没有 bpftool prog load 的反向命令（至少在撰写本文时没有），可以通过删除固定的伪文件来从内核中移除该程序： $ rm /sys/fs/bpf/hello$ bpftool prog show name hello 3.11 BPF to BPF Callsa very simple function that extracts the syscall opcode from the tracepoint arguments: static __attribute((noinline)) int get_opcode(struct bpf_raw_tracepoint_args *ctx) return ctx-args[1]; The eBPF function that calls this function looks like this: SEC(raw_tp)int hello(struct bpf_raw_tracepoint_args *ctx) int opcode = get_opcode(ctx); bpf_printk(Syscall: %d, opcode); return 0; $ bpftool prog load hello-func.bpf.o /sys/fs/bpf/hello$ bpftool prog list name hello893: raw_tracepoint name hello tag 3d9eb0c23d4ab186 gpl loaded_at 2023-01-05T18:57:31+0000 uid 0 xlated 80B jited 208B memlock 4096B map_ids 204 btf_id 302 The interesting part of this exercise is inspecting the eBPF bytecode to see the get_opcode() function $ bpftool prog dump xlated name helloint hello(struct bpf_raw_tracepoint_args * ctx):; int opcode = get_opcode(ctx); # 1 0: (85) call pc+7#bpf_prog_cbacc90865b1b9a5_get_opcode; bpf_printk(Syscall: %d, opcode); 1: (18) r1 = map[id:193][0]+0 3: (b7) r2 = 12 4: (bf) r3 = r0 5: (85) call bpf_trace_printk#-73584; return 0; 6: (b7) r0 = 0 7: (95) exitint get_opcode(struct bpf_raw_tracepoint_args * ctx): # 2; return ctx-args[1]; 8: (79) r0 = *(u64 *)(r1 +8); return ctx-args[1]; 9: (95) exit 3.12 Summarytodo 3.13 Exercisestodo"},{"title":"04. The bpf() System Call","path":"/wiki/ebpf/learning-ebpf-04.html","content":"the eBPF code running in the kernel does not use syscalls to access maps. eBPF programs use helper functions to read and write to maps bpf()’s signature: int bpf(int cmd, union bpf_attr *attr, unsigned int size); cmd, specifies which command to perform. attr, whatever data is needed to specify the parameters for the command size, how many bytes of data there are in attr struct user_msg_t // 1 char message[12];;BPF_HASH(config, u32, struct user_msg_t); // 2BPF_PERF_OUTPUT(output); // 3struct data_t // 4 int pid; int uid; char command[16]; char message[12];;int hello(void *ctx) // 5 struct data_t data = ; struct user_msg_t *p; char message[12] = Hello World; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); p = config.lookup(data.uid); // 6 if (p != 0) bpf_probe_read_kernel(data.message, sizeof(data.message), p-message); else bpf_probe_read_kernel(data.message, sizeof(data.message), message); output.perf_submit(ctx, data, sizeof(data)); return 0; the bpf() system calls that are used when it runs $ strace -e bpf ./hello-buffer-config.py 4.1 Loading BTF Data loading a blob of BTF data into the kernel the return code from the bpf() system call (3 in my example) is a file descriptor that refers to that data bpf(BPF_BTF_LOAD, btf=\\237\\353\\1\\0... , 40) = 3 BTF allows eBPF programs to be portable across different kernel versions so that you can compile a program on one machine and use it on another, which might be using a different kernel version and hence have different kernel data structures. 4.2 Creating Maps creates an eBPF map bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_PERF_EVENT_ARRAY, key_size=4, value_size=4, max_entries=22, ... map_name=output, ..., 80) = 4 bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_HASH, key_size=4, value_size=13, max_entries=10240, ... map_name=config, ... btf_fd=3, ..., 80) = 5 4.3 Loading a Programbpf(BPF_PROG_LOAD, prog_type=BPF_PROG_TYPE_KPROBE, insn_cnt=47, insns=0x7408c9814000, license=GPL, ... prog_name=hello, ... expected_attach_type=BPF_CGROUP_INET_INGRESS, prog_btf_fd=3, ..., 152) = 6 4.4 Modifying a Map from User Spaceb[config][ct.c_int(0)] = ct.create_string_buffer(bHey root!)b[config][ct.c_int(501)] = ct.create_string_buffer(bHi user 501!) You can see these entries being defined in the map through syscalls like this: bpf(BPF_MAP_UPDATE_ELEM, map_fd=5, key=0x7408c92a9020, value=0x7408c92a8520, flags=BPF_ANY, 32) = 0 use bpftool to view the map’s contents bpftool map dump name config [ key: 0, value: message: Hey root! , key: 501, value: message: Hi user 501! ] 4.5 BPF Program and Map References reference counts When there are no references left to a BPF program, the kernel removes the program. An additional reference is created when you pin a program to the filesystem. 4.5.1 Pinningbpftool prog load hello.bpf.o /sys/fs/bpf/hello These pinned objects aren’t real files persisted to disk. They are held in memory, which means they will not remain in place over a system reboot. Programs that are attached within the network stack or cgroups (short for “control groups”) aren’t associated with any user space process, so they stay in place even after the user space program that loads them exits. ip link set dev eth0 xdp obj hello.bpf.o sec xdp 4.5.2 BPF LinksAnother way to create a reference to a BPF program BPF links provide a layer of abstraction between an eBPF program and the event it’s attached to. 4.6 Additional Syscalls Involved in eBPF4.6.1 Initializing the Perf Buferbpf(BPF_MAP_UPDATE_ELEM, map_fd=4, key=0x770d75d708a0, value=0x770d75d70520, flags=BPF_ANY, 32) = 0 strace to show a few more syscalls when running this example, strace -e bpf,perf_event_open,ioctl,ppoll ./hello-buffer-config.py 4.6.2 Attaching to Kprobe Eventsa file descriptor representing that particular event perf_event_open(type=0x8 /* PERF_TYPE_??? */, ..., ...) = 7 the value 6 to indicate that it’s a kprobe type of perf event $ cat /sys/bus/event_source/devices/kprobe/type attaching a Berkeley Packet Filter (BPF) program to an existing kprobe tracepoint event: ioctl(7, PERF_EVENT_IOC_SET_BPF, 6) = 0 turns the kprobe event on: ioctl(7, PERF_EVENT_IOC_ENABLE, 0) = 0 4.6.3 Setting Up and Reading Perf EventsNOTE:与使用的处理器的核心数量有关 perf_event_open(type=PERF_TYPE_SOFTWARE, size=0 /* PERF_ATTR_SIZE_??? */, config=PERF_COUNT_SW_BPF_OUTPUT, ..., -1, X, -1, PERF_FLAG_FD_CLOEXEC) = 8ioctl(Y, PERF_EVENT_IOC_ENABLE, 0) = 0bpf(BPF_MAP_UPDATE_ELEM, map_fd=4, key=0x7644407f88a0, value=0x7644407f8520, flags=BPF_ANY, 32) = 0 User space code can then use ppoll() on all four of these output stream file descriptors so that it can get the data output ppoll([fd=8, events=POLLIN, fd=9, events=POLLIN, fd=10, events=POLLIN,fd=11, events=POLLIN], 4, NULL, NULL, 0) = 1 ([fd=8, revents=POLLIN]) You won’t see the return code written to the screen until something triggers execve(), which causes the eBPF program to write data that user space retrieves using this ppoll() call. 4.7 Ring Bufersring buffers are preferred over perf buffers partly for performance reasons The bpf() syscall that creates the output ring buffer map: bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_RINGBUF, key_size=0, value_size=0, max_entries=4096, ..., map_name=output, ..., 80) = 4 For a ring buffer, there’s just the one file descriptor shared across all CPU cores. 4.8 Reading Information from a Mapan extract of the bpf() syscalls that bpftool makes while reading the contents of the config map: strace -e bpf bpftool map dump name config 4.8.1 Finding a Mapbpftool walks through all the maps looking for any with the name config bpf(BPF_MAP_GET_NEXT_ID, start_id=0, ..., 12) = 0bpf(BPF_MAP_GET_FD_BY_ID, map_id=25, ..., 12) = 3bpf(BPF_OBJ_GET_INFO_BY_FD, info=bpf_fd=3, ..., 16) = 0bpf(BPF_MAP_GET_NEXT_ID, start_id=25, ..., 12) = 0bpf(BPF_MAP_GET_FD_BY_ID, map_id=26, ..., 12) = 3bpf(BPF_OBJ_GET_INFO_BY_FD, info=bpf_fd=3, ..., 16) = 0 4.8.2 Reading Map Elementsbpf(BPF_MAP_GET_NEXT_KEY, map_fd=3, key=NULL, next_key=0x5897d6dd81c0, 24) = 0bpf(BPF_MAP_LOOKUP_ELEM, map_fd=3, key=0x5897d6dd81c0, value=0x5897d6dd81e0, flags=BPF_ANY, 32) = 0 [ key: 0, value: message: Hey root! bpf(BPF_MAP_GET_NEXT_KEY, map_fd=3, key=0x5897d6dd81c0, next_key=0x5897d6dd81c0, 24) = -1 ENOENT (No such file or directory) ]+++ exited with 0 +++ 4.9 Summarytodo 4.10 Exercisestodo QA 我在运行 strace -e bpf,perf_event_open,ioctl,ppoll ./hello-buffer-config.py 时，并没有看到 ppoll 的相关调用 可能调用的是 poll poll([fd=8, events=POLLIN, fd=9, events=POLLIN, ...], 22, -1) = 1 ([fd=23, revents=POLLIN])"},{"title":"05. CO-RE, BTF, and Libbpf","path":"/wiki/ebpf/learning-ebpf-05.html","content":"compile once, run everywhere (CO-RE) It allows eBPF programs to include information about the data structure layouts they were compiled with, and it provides a mechanism for adjusting how fields are accessed if the data structure layout is different on the target machine where they run. 5.1 BCC’s Approach to PortabilityTo address portability across kernels, BCC took the approach of compiling eBPF code at runtime, in situ on the destination machine. 5.2 CO-RE Overview BTF BTF is a format for expressing the layout of data structures and function signatures. Linux kernels from 5.4 onward support BTF. Kernel headers you can use bpftool to generate a header file called vmlinux.h from a running system, containing all the data structure information about a kernel that a BPF program might need. Compiler support The Clang compiler with the -g flag The GCC compiler version 12 Library support for data structure relocations libbpf was the original C library that includes this relocation capability the Cilium eBPF library provides the same capability for Go programmers Aya does it for Rust Optionally, a BPF skeleton If you’re writing the user space code in C, you can generate the skeleton with bpftool gen skeleton. 5.3 BPF Type FormatBTF information describes how data structures and code are laid out in memory. 5.3.1 BTF Use Casesbpftool used BTF information to format the output of map dumps. BTF information also includes the line and function information that enables bpftool to interleave source code within the output from translated or JITed program dumps. ( Chapter 3) the source code information interleaved with the verifier log output. (Chapter 6) BTF information is also required for BPF spin locks. 5.3.2 Listing BTF Information with bpftoollists all the BTF data loaded into the kernel: bpftool btf list 1: name [vmlinux] size 6050732B2: name [tun] size 78483B3: name [ip_tables] size 54242B4: name [llc] size 37035B5: name [stp] size 36698B6: name [bridge] size 526851B7: name [br_netfilter] size 87947B8: name [autofs4] size 28681B9: name [configfs] size 49125B10: name [sch_fq_codel] size 56146B11: name [ac] size 556B12: name [battery] size 10709B13: name [crc32c_intel] size 505B14: name [irqbypass] size 943B15: name [kvm] size 210513B16: name [kvm_intel] size 66832B17: name [intel_rapl_common] size 12653B18: name [intel_rapl_msr] size 10427B28: name anon size 40669B pids bpftool(1749) The first entry in the list is vmlinux, and it corresponds to the vmlinux file I mentioned earlier that holds the BTF information about the currently running kernel. 5.3.3 BTF Types$ cd learning-ebpf/chapter4$ ./hello-buffer-config.py $ bpftool btf list51: name anon size 2292B prog_ids 50 map_ids 16 pids hello-buffer-co(3510) $ bpftool prog show name hello50: kprobe name hello tag ce68c6b13b45c753 gpl loaded_at 2025-11-11T11:01:07+0800 uid 0 xlated 392B jited 216B memlock 4096B map_ids 16,15 btf_id 51 pids hello-buffer-co(3510) Knowing the ID of the BTF information, you can inspect its contents with the command bpftool btf dump id . $ bpftool btf dump id 51 struct user_msg_t char message[13];;BPF_HASH(config, u32, struct user_msg_t); [1] TYPEDEF u32 type_id=2[2] TYPEDEF __u32 type_id=3[3] INT unsigned int size=4 bits_offset=0 nr_bits=32 encoding=(none) All three of these types are synonyms for a 32-bit unsigned integer type. [4] STRUCT user_msg_t size=13 vlen=1 message type_id=6 bits_offset=0[5] INT char size=1 bits_offset=0 nr_bits=8 encoding=SIGNED[6] ARRAY (anon) type_id=5 index_type_id=7 nr_elems=13[7] INT __ARRAY_SIZE_TYPE__ size=4 bits_offset=0 nr_bits=32 encoding=(none)[8] STRUCT ____btf_map_config size=20 vlen=2 key type_id=1 bits_offset=0 value type_id=4 bits_offset=32 5.3.4 Maps with BTF Informationmaps are created using the bpf(BPF_MAP_CREATE) syscall. The ____btf_map_config structure that you just saw defined isn’t used by the kernel for the map definition; it’s just used by BCC on the user space side. 5.3.5 BTF Data for Functions and Function Prototypesint hello(void *ctx) [11] FUNC_PROTO (anon) ret_type_id=12 vlen=1 ctx type_id=10[12] INT int size=4 bits_offset=0 nr_bits=32 encoding=SIGNED[13] FUNC hello type_id=11 linkage=static 5.3.6 Inspecting BTF Data for Maps and Programsinspect the BTF types associated with a particular map bpftool btf dump map name config inspect the BTF information related to a particular program bpftool btf dump prog id 51bpftool btf dump prog name hello 5.4 Generating a Kernel Header Fileas BTF-enabled tools can generate an appropriate header file from the BTF information included with the kernel. This header file is conventionally called vmlinux.h, and you can generate it with bpftool like this: bpftool btf dump file /sys/kernel/btf/vmlinux format c vmlinux.h This file defines all the kernel’s data types, so including this generated vmlinux.h file in your eBPF program source supplies the definitions of any Linux data structures you might need. BTF information in the form of the syskernelbtfvmlinux file has been included in the Linux kernel since version 5.4. 5.5 CO-RE eBPF ProgramsNOTE:在 learning-ebpfchapter5 目录下执行如下命令: bpftool btf dump file syskernelbtfvmlinux format c vmlinux.h hello-bufer-config.bpf.c, which implements the eBPF program that runs in the kernel hello-bufer-config.c that loads the program and displays output 5.5.1 Header FilesThe first few lines of hello-bufer-config.bpf.c specify the header files that it needs: #include vmlinux.h#include bpf/bpf_helpers.h#include bpf/bpf_tracing.h#include bpf/bpf_core_read.h#include hello-buffer-config.h Kernel header information: If you’re going to use any BPF helper functions from libbpf, you’ll need to include either vmlinux.h or linuxtypes.h to get the definitions for types like u32, u64, and so on, that the BPF helper source refers to. The vmlinux.h file is derived from the kernel source headers, but it doesn’t include #define’d values from them. if your eBPF program parses Ethernet packets, There is a series of constant values that you’ll need to duplicate in your own code, if you don’t include the if_ether.h file that defines these values for the kernel. Headers from libbpf: To use any BPF helper functions in your eBPF code, you’ll need to include the header files from libbpf that give you their definitions. At the time of this writing, it is common to see eBPF projects including libbpf as a submodule and buildinginstalling from source. If you include it as a submodule, you’ll simply need to run make install from the libbpfsrc directory. Application-speciic headers: It’s very common to have an application-specific header file that defines any structures that are used by both the user space and eBPF parts of your app. 5.5.2 Deining Mapsstruct __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY); __uint(key_size, sizeof(u32)); __uint(value_size, sizeof(u32)); output SEC(.maps);struct user_msg_t char message[12];;struct __uint(type, BPF_MAP_TYPE_HASH); __uint(max_entries, 10240); __type(key, u32); __type(value, struct user_msg_t); my_config SEC(.maps); __uint, __type, __array 定义在头文件 bpf_helpers.h 中定义： #define __uint(name, val) int (*name)[val]#define __type(name, val) typeof(val) *name#define __array(name, val) typeof(val) *name[] 这些宏在基于 libbpf 的程序中通常遵循惯例使用，而且它们能让 map 定义的可读性稍好一些。 5.5.3 eBPF Program SectionsUse of libbpf requires each eBPF program to be marked with a SEC() macro that defines the program type: libbpf can make life even easier for you with the k(ret)syscall section name, which tells the loader to attach to the kprobe in the architecture-specific function automatically SEC(ksyscall/execve)int BPF_KPROBE_SYSCALL(hello, const char *pathname) struct data_t data = ; struct user_msg_t *p; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); bpf_probe_read_user_str(data.path, sizeof(data.path), pathname); p = bpf_map_lookup_elem(my_config, data.uid); if (p != 0) bpf_probe_read_kernel_str(data.message, sizeof(data.message), p-message); else bpf_probe_read_kernel_str(data.message, sizeof(data.message), message); bpf_perf_event_output(ctx, output, BPF_F_CURRENT_CPU, data, sizeof(data)); return 0; The ctx variable does exist, hidden within the BPF_KPROBE_SYSCALL macro definition inside bpfbpf_tracing.h, in libbpf, where you’ll also find some commentary about this. 5.5.4 Memory Access with CO-REeBPF programs for tracing have restricted access to memory, via a BPF helper function from the bpf_probe_read_*() family. the eBPF verifier generally won’t let you simply read memory through a pointer as you usually can in C (e.g., x p-y) if you wanted to do something like d a-b-c-d, you could write the following code: struct b_t *b;struct c_t *c;bpf_core_read(b, 8, a-b);bpf_core_read(c, 8, b-c);bpf_core_read(d, 8, c-d); But it’s much more compact to use: d = BPF_CORE_READ(a, b, c, d); 5.5.5 License Deinitionchar LICENSE[] SEC(license) = Dual BSD/GPL; 5.6 Compiling eBPF Programs for CO-RE5.6.1 Debug InformationYou have to pass the -g flag to Clang so that it includes debug information, which is necessary for BTF the -g flag also adds DWARF debugging information to the output object file, you can reduce the size of the object by running the following command to strip it out llvm-strip -g object file 5.6.2 OptimizationThe -O2 optimization flag (level 2 or higher) is required for Clang to produce BPF bytecode that will pass the verifier. by default, Clang will output callx to call helper functions, but eBPF doesn’t support calling addresses from registers. 5.6.3 Target ArchitectureThe libbpf header file bpfbpf_tracing.h defines several macros that are platform specific, such as BPF_KPROBE and BPF_KPROBE_SYSCALL. you’ll need to also tell the compiler what the target architecture is. You can do this by setting -D __TARGET_ARCH_($ARCH) where $ARCH is an architecture name like arm64, amd64, and so on. 5.6.4 MakeileThe following is an example Makefile instruction for compiling CO-RE objects: hello-buffer-config.bpf.o: %.o: %.c clang \\ -target bpf \\ -D __TARGET_ARCH_$(ARCH) \\ -I/usr/include/$(shell uname -m)-linux-gnu \\ -Wall \\ -O2 -g \\ -c $ -o $@ llvm-strip -g $@ 5.6.5 BTF Information in the Object File .BTF, which contains the data and string information .BTF.ext, which covers function and line information readelf -S hello-buffer-config.bpf.o | grep BTF [ 8] .BTF PROGBITS 0000000000000000 000003b0 [ 9] .rel.BTF REL 0000000000000000 000010a8 [10] .BTF.ext PROGBITS 0000000000000000 00000ca4 [11] .rel.BTF.ext REL 0000000000000000 000010f8 examine the BTF data from an object file: bpftool btf dump file hello-buffer-config.bpf.o 5.7 BPF Relocationslibbpf 库使 eBPF 程序适应其运行的目标内核上的数据结构体布局，即使该布局与编译代码的内核不同。为此，libbpf 需要 Clang 在编译过程中生成的 BPF CO-RE 重定位信息。 可以通过 linux/bpf.h 头文件中 struct bpf_core_relo 的定义了解有关重定位如何工作的更多信息： struct bpf_core_relo __u32 insn_off; __u32 type_id; __u32 access_str_off; enum bpf_core_relo_kind kind;; eBPF 程序的 CO-RE 重定位数据，会为每条需要重定位的指令配备一个此类结构体。 假设某条指令要将一个寄存器的值设置为某个结构体中某个字段的值，那么该指令对应的 bpf_core_relo 结构体（通过 insn_off 字段来标识）会对该结构体的 BTF 类型（type_id 字段）进行编码，同时还会指明该字段相对于此结构体的访问方式（access_str_off 字段）。 内核数据结构的重定位数据会由 Clang 自动生成，并编码到 ELF 目标文件中。正是在 vmlinux.h 文件开头附近找到的下一行代码，促使 Clang 执行了这一操作： #pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record) preserve_access_index: 指示 Clang 为类型定义生成 BPF CO-RE 重定位信息。 clang attribute push: 将应用于所有后续的类型定义，直至文件末尾出现 clang attribute pop 为止。这意味着 Clang 会为 vmlinux.h 中定义的所有类型都生成对应的重定位信息。 当加载 BPF 程序时，可通过 bpftool 工具并添加 -d 参数开启调试信息，来查看重定位操作的执行过程。 bpftool -d prog load hello.bpf.o /sys/fs/bpf/hello 会看到类似下面的输出信息： libbpf: CO-RE relocating [22] struct pt_regs: found target candidate [134] struct pt_regs in [vmlinux]libbpf: prog hello: relo #0: byte_off [22] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #0: matching candidate #0 byte_off [134] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #0: patched insn #5 (ALU/ALU64) imm 112 - 112libbpf: prog hello: relo #1: byte_off [22] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #1: matching candidate #0 byte_off [134] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #1: patched insn #6 (LDX/ST/STX) off 112 - 112libbpf: prog hello: relo #2: byte_off [22] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #2: matching candidate #0 byte_off [134] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #2: patched insn #48 (LDX/ST/STX) off 112 - 112 5.8 CO-RE User Space Codeyou’ll want to build this functionality into a dedicated user space program that you supply as an executable. 5.9 The Libbpf Library for User SpaceThis library provides functions that wrap the bpf() and related syscalls that you met in Chapter 4 to perform operations like loading programs into the kernel and attaching them to events, or accessing map information from user space. The conventional and easiest way to use these abstractions is through auto-generated BPF skeleton code. 5.9.1 BPF SkeletonsYou can use bpftool to auto-generate this skeleton code from existing eBPF objects in ELF file format, like this: bpftool gen skeleton hello-buffer-config.bpf.o hello-buffer-config.skel.h Loading programs and maps into the kernel skel = hello_buffer_config_bpf__open_and_load(); These two phases can easily be handled separately, as the skeleton code provides separate name__open() and name__load() functions. This gives you the option to manipulate the eBPF information before loading it. skel = hello_buffer_config_bpf__open();if (!skel) // Error ...skel-data-c = 10;err = hello_buffer_config_bpf__load(skel); Accessing existing mapssometimes you might want to write an eBPF program that reuses an existing map Another common reason to use a map is to share information between two different eBPF programs struct bpf_map_info info = ; unsigned int len = sizeof(info); int findme = bpf_obj_get(/sys/fs/bpf/findme);if (findme = 0) printf(No FD ); else bpf_obj_get_info_by_fd(findme, info, len); printf(name %s , info.name); To try this out you can create a map using bpftool, like this: bpftool map create /sys/fs/bpf/findme type array key 4 value 32 entries 4 name findme Attaching to eventsattaches the program to the execve syscall function err = hello_buffer_config_bpf__attach(skel); If you didn’t define the attachment point fully, there are a whole series of libbpf functions, such as bpf_program__attach_kprobe, bpf_program__attach_xdp, and so on, for attaching different program types. Managing an event buferpb = perf_buffer__new(bpf_map__fd(skel-maps.output), 8, handle_event, lost_event, NULL, NULL); The handle_event argument is a callback function that gets called when new data arrives in the perf buffer lost_event gets called if there isn’t enough room in the perf buffer for the kernel to write a data entry Finally, the program has to poll the perf buffer repeatedly: while (true) err = perf_buffer__poll(pb, 100); ... The 100 is a timeout in milliseconds. to clean up I free the perf buffer and destroy the eBPF programs and maps in the kernel perf_buffer__free(pb);hello_buffer_config_bpf__destroy(skel); 5.9.2 Libbpf Code Examples The libbpf-bootstrap project is intended to help you get off the ground with a set of example programs. The BCC project has many of the original BCC-based tools migrated to a libbpf version. You’ll find them in the libbpf-tools directory. 5.10 SummaryIn this chapter you saw how CO-RE achieves this by encoding type information into the compiled object file and using relocations to rewrite instructions as they are loaded into the kernel. 5.11 Exercisestodo"},{"title":"06. The eBPF Veriier","path":"/wiki/ebpf/learning-ebpf-06.html","content":"the verifier works on eBPF bytecode, not directly on the source. That bytecode depends on the output from the compiler. 6.1 The Verification ProcessAs it goes along it keeps track of the state of each register in a structure called bpf_reg_state. This structure includes a field called bpf_reg_type, which describes what type of value is held in that register. NOT_INIT, indicating that the register has not yet been set to a value. SCALAR_VALUE, indicating that the register has been set to a value that doesn’t represent a pointer Several PTR_TO_* types, indicating that the register holds a pointer to something. PTR_TO_CTX: The register holds a pointer to the context passed as the argument to a BPF program. PTR_TO_PACKET: The register points to a network packet (held in the kernel as skb-data). PTR_TO_MAP_KEY or PTR_TO_MAP_VALUE There are several other PTR_TO_* types, and you can find the full set enumerated in the linuxbpf.h header file. 6.2 The Verifier LogWhen the verification of a program fails, the verifier generates a log showing how it reached the conclusion that the program is invalid. If you’re using bpftool prog load, the verifier log gets output to stderr. When you’re writing a program with libbpf, you can use the function libbpf_set_print() to set a handler that will display (or do something else useful with) any errors. When an eBPF program is called, Register 1 always holds the context argument passed to the program. Register 0 is used for the return value from a helper function and also for the return value from an eBPF program. Register 10 always holds a pointer to the eBPF stack frame (and the eBPF program can’t modify it). 6.3 Visualizing Control Flowbpftool prog dump xlated name kprobe_exec visual out.dotdot -Tpng out.dot out.png 6.4 Validating Helper FunctionsYou’re not allowed to call directly from eBPF programs to any kernel function, but eBPF provides a number of helper functions that enable programs to access information from the kernel. Different helper functions are valid for different BPF program types. 6.5 Helper Function Argumentsconst struct bpf_func_proto bpf_map_lookup_elem_proto = .func = bpf_map_lookup_elem,\t.gpl_only\t= false,\t.pkt_access\t= true,\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\t.arg1_type\t= ARG_CONST_MAP_PTR,\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,; This structure defines the constraints for arguments to and return values from the helper function. 6.6 Checking the LicenseThe verifier also checks that if you are using a BPF helper function that’s licensed under GPL, your program also has a GPL-compatible license. 6.7 Checking Memory Accessan XDP program is only permitted to access the memory locations that make up that network packet. SEC(xdp)int xdp_load_balancer(struct xdp_md *ctx) void *data = (void *)(long)ctx-data; void *data_end = (void *)(long)ctx-data_end;... 6.8 Checking Pointers Before Dereferencing ThemThe eBPF verifier requires all pointers to be checked before they are dereferenced so that this type of crash can’t happen. Some helper functions incorporate the pointer check for you. long bpf_probe_read_kernel(void *dst, u32 size, const void *unsafe_ptr) The third argument to this function is called unsafe_ptr. This is an example of a BPF helper function that helps programmers write safe code by handling checks for you. 6.9 Accessing ContextEvery eBPF program is passed some context information as an argument, but depending on the program and attachment type, it may be allowed to access only some of that context information. 6.10 Running to CompletionIf the verifier hasn’t reached the end of the BPF program before it has processed this many instructions, it rejects the program. 6.11 LoopsFrom version 5.3 onward the verifier follows branches backward as well as forward as part of its process of checking all the possible execution paths. This means it can accept some loops, provided the execution path remains within the limit of one million instructions. In version 5.17 a new helper function, bpf_loop(), was introduced that makes it much easier for the verifier not only to accept loops but also to do it in a much more efficient way. There’s also a helper function bpf_for_each_map_elem() that calls a provided callback function for each item in a map. 6.12 Checking the Return CodeThe return code from an eBPF program is stored in Register 0 (R0). Register 0 is also used to hold the return code from a helper function. After returning from a helper function in an eBPF program, Register 0 is no longer uninitialized. 6.13 Invalid InstructionsThe verifier checks that the instructions in a program are valid bytecode instructions—for example, using only known opcodes. 6.14 Unreachable InstructionsThe verifier also rejects programs that have unreachable instructions. Oftentimes, these will get optimized out by the compiler anyway. 6.15 SummaryThe verifier keeps track of the types and possible range of values for each register to ensure that eBPF programs are safe to run. 6.16 Exercisestodo"},{"title":"07. eBPF Program and Attachment Types","path":"/wiki/ebpf/learning-ebpf-07.html","content":"There are currently around 30 program types enumerated in uapilinuxbpf.h, and more than 40 attachment types. 7.1 Program Context ArgumentsAll eBPF programs take a context argument that is a pointer, but the structure it points to depends on the type of event that triggered it. Defining different types of programs allows the verifier to ensure that the contextual information is handled appropriately and to enforce rules about what helper functions are permissible. 7.2 Helper Functions and Return Codesthe verifier checks that all helper functions used by a program are compatible with its program type. The program type also determines the meaning of the return code from the program. Again using XDP as an example, the return code value tells the kernel what to do with the packet once the eBPF program has finished processing it—which could involve passing it to the network stack, dropping it, or redirecting it to a different interface. get a list of which helper functions are available for each program type in your version of the kernel: bpftool feature 7.3 Kfuncsbe able to access some internal functions from eBPF programs. This can be achieved using the mechanism called BPF kernel functions, or kfuncs Kfuncs allow internal kernel functions to be registered with the BPF subsystem so that the verifier will allow them to be called from eBPF programs. the type of an eBPF program determines what events it can be attached to, which in turn defines the type of context information it receives. The program type also defines the set of helper functions and kfuncs it can call. 7.4 Tracing附加到 kprobes、tracepoints、raw tracepoints、fentryfexit probes 和 perf events 的程序，都是为了内核中的 eBPF 程序能够高效的将跟踪信息传递到用户空间中。 查看附加到 perf 相关事件的程序： bpftool perf show 7.4.1 Kprobes and Kretprobes几乎可以将 kprobe 程序附加到内核的任何位置。 通常情况下，使用 kprobes 附加到函数的入口，使用 kretprobes 附加到函数的出口，但也可以使用 kprobes 附加到函数入口后的某个指定偏移量。 bpftool perf list Attaching kprobes to syscall entry points 附加到系统调用 execve() 的 kprobe SEC(ksyscall/execve)int BPF_KPROBE_SYSCALL(kprobe_sys_execve, const char *pathname) Attaching kprobes to other kernel functions kprobes 也可以附加到内核中的任何非内联函数 SEC(kprobe/do_execve)int BPF_KPROBE(kprobe_do_execve, struct filename *filename) filename 是根据内核中 do_execve 的函数原型确定。由于参数在内存中按顺序排列，可以忽略最后 n 个参数，但如果想使用后面的参数，则不能忽略列表中靠前的参数。 int do_execve(struct filename *filename, const char __user *const __user *__argv, const char __user *const __user *__envp) Kretprobes 与 kprobes 非常相似，不同之处在于它们在函数返回时触发，并且可以访问返回值而不是参数。 7.4.2 FentryFexit从内核版本 5.5 开始（适用于 x86 处理器；BPF trampoline 支持在 Linux 6.0 之前不适用于 ARM 处理器），引入了一种更高效的机制来跟踪进入和退出内核函数的方式以及 BPF trampoline 的概念。 fentryfexit 现在是首选的跟踪进入或退出内核函数的方法。 SEC(fentry/do_execve)int BPF_PROG(fentry_execve, struct filename *filename) fentry 和 fexit 的附加点设计得比 kprobes 更高效，且 fexit hook 可以访问函数的输入参数，而 kretprobe 不能。 在 libbpf-bootstrap 的示例中 可以看到两个等效的示例： kprobe.bpf.c SEC(kretprobe/do_unlinkat)int BPF_KRETPROBE(do_unlinkat_exit, long ret) fentry.bpf.c SEC(fexit/do_unlinkat)int BPF_PROG(do_unlinkat_exit, int dfd, struct filename *name, long ret) 7.4.3 TracepointsTracepoints 是内核开发者预先在代码中设置的、可用于触发事件记录的特定位置，在不同内核版本之间具有稳定性。 查看内核上可用的跟踪子系统集合： cat /sys/kernel/tracing/available_events 如下所示，当内核开始处理系统调用 ececve() 时，tracepoint syscalls:sys_enter_execve 会被触发。 SEC(tp/syscalls/sys_enter_execve)int tp_sys_enter_execve(struct my_syscalls_enter_execve *ctx) BTF 可以帮助我们处理 tracepoint 的上下文(context)。 但是在 BTF 不可用的情况下，以下是一些应对措施：每个 tracepoint 都有一个格式（format），用来描述从跟踪点中被追踪输出的字段（fields）。 以下是 execve() 系统调用入口处跟踪点的格式说明： cat /sys/kernel/tracing/events/syscalls/sys_enter_execve/format name: sys_enter_execveID: 761format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:const char * filename; offset:16; size:8; signed:0; field:const char *const * argv; offset:24; size:8; signed:0; field:const char *const * envp; offset:32; size:8; signed:0;print fmt: filename: 0x%08lx, argv: 0x%08lx, envp: 0x%08lx, ((unsigned long)(REC-filename)), ((unsigned long)(REC-argv)), ((unsigned long)(REC-envp)) 可以使用上述信息定义一个名为 my_syscalls_enter_execve 的结构体： NOTE:eBPF 程序不允许访问前四个字段。 struct my_syscalls_enter_execve unsigned short common_type; unsigned char common_flags; unsigned char common_preempt_count; int common_pid;\tlong syscall_nr;\tvoid *filename_ptr;\tlong argv_ptr;\tlong envp_ptr;; 附加到该跟踪点的 eBPF 示例程序，可以将指向此类型的指针用作其上下文(context)参数，然后就可以访问这个结构体的内容了。 int tp_sys_enter_execve(struct my_syscalls_enter_execve *ctx) struct data_t data = ; ... bpf_probe_read_user(data.path, sizeof(data.path), ctx-filename_ptr); 当使用跟踪点（tracepoint）程序类型时，传递给 eBPF 程序的结构体已由一组原始参数映射而来。 为获得更优性能，可以通过原始跟踪点（raw tracepoint）eBPF 程序类型直接访问这些原始参数。此时，段定义（section definition）应以 raw_tp（或 raw_tracepoint）开头，而非 tp。 SEC(raw_tp/sched_process_exec)int raw_tp_exec(struct bpf_raw_tracepoint_args *ctx) struct data_t data = ; bpf_probe_read_kernel(data.message, sizeof(data.message), raw_tp_exec_msg); data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_perf_event_output(ctx, output, BPF_F_CURRENT_CPU, data, sizeof(data)); return 0; 7.4.4 BTF-Enabled Tracepoints在 BTF 支持下，在 vmlinux.h 中会定义一个与传递给跟踪点 eBPF 程序的上下文结构体相匹配的结构体。 eBPF 程序应该使用 SEC(tp_btf/tracepoint name)，其中跟踪点名称是 /sys/kernel/tracing/available_events 中列出的可用事件之一。 SEC(tp_btf/sched_process_exec)int handle_exec(struct trace_event_raw_sched_process_exec *ctx) 结构名称与跟踪点名称匹配，前缀为 trace_event_raw_ 。 7.4.5 User Space Attachmentsuprobes 和 uretprobes 用于挂载到用户态函数的入口和出口。用户态静态定义跟踪点 user statically defined tracepoints (USDTs) 用于挂载应用程序代码或用户态库中指定的跟踪点。这些都是用 BPF_PROG_TYPE_KPROBE 类型。 如果你正在使用 libbpf，那么 SEC() 宏可用于为这些用户态探测程序 (user space probes) 定义自动挂载点。具体格式可参考 Program Types and ELF Sections。 比如，将用户态入口探测（uprobe）挂载到 OpenSSL 中 SSL_write() 函数的起始处： SEC(uprobe/usr/lib/aarch64-linux-gnu/libssl.so.3/SSL_write) 一些例子： bashreadline.bpf.c funclatency.c usdt_sample.md 7.4.6 LSMBPF_PROG_TYPE_LSM 程序附加到 Linux 安全模块 (LSM) API，这是内核中的一个稳定接口，最初供内核模块用来强制执行安全策略。 BPF_PROG_TYPE_LSM 程序使用 bpf(BPF_RAW_TRACEPOINT_OPEN) 附加，并且在许多方面它们被视为跟踪程序。 BPF_PROG_TYPE_LSM 程序的一个有趣特征是返回值会影响内核的行为方式。非零返回值表示安全检查未通过，因此内核不会继续执行要求完成的任何操作。这与忽略返回值的 perf 相关程序类型有显着差异。 7.5 NetworkingThese program types all require CAP_NET_ADMIN and CAP_BPF, or CAP_SYS_ADMIN, capabilities to be permitted. The context passed to these types of programs is the network message in question, although the type of structure depends on the data the kernel has at the relevant point in the network stack. Layer 7 covers formats intended for applications to use, such as HTTP, DNS, or gRPC; TCP is at Layer 4; IP is at Layer 3; and Ethernet and WiFi are at Layer 2. 7.5.1 Sockets BPF_PROG_TYPE_SOCKET_FILTER was the first program type to be added to the kernel. It’s used to filter a copy of socket data that can be sent to an observability tool such as tcpdump. A socket is specific to a Layer 4 (TCP) connection. BPF_PROG_TYPE_SOCK_OPS allows eBPF programs to intercept various operations and actions that take place on a socket, and to set for that socket parameters such as TCP timeout values. BPF_PROG_TYPE_SK_SKB programs are used in conjunction with a special map type that holds a set of references to sockets to provide what’s known as sockmap operations: redirecting traffic to different destinations at the socket layer. 7.5.2 Traic ControleBPF programs can be attached to provide custom filters and classifiers for network packets for both ingress and egress traffic. 7.5.3 XDPXDP (eXpress Data Path) The roughly equivalent command for loading and attaching the program to eth0 would be this: ip link set dev eth0 xdp obj hello.bpf.o sec xdp Removing the XDP program with ip link can be done like this: ip link set dev eth0 xdp off 7.5.4 Flow DissectoreBPF programs of type BPF_PROG_TYPE_FLOW_DISSECTOR can implement custom packet dissection. 7.5.5 Lightweight TunnelsThe family of BPF_PROG_TYPE_LWT_* program types can be used to implement network encapsulation in eBPF programs. 7.5.6 Cgroups control groups Cgroups are a concept in the Linux kernel that restricts the set of resources a given process or group of processes can have access to. Attaching eBPF programs to a cgroup allows for custom behavior that only applies to that cgroup’s processes. a BPF_CGROUP_SYSCTL program type that can be attached to sysctl commands affecting a particular cgroup. BPF_PROG_TYPE_CGROUP_SOCK and BPF_PROG_TYPE_CGROUP_SKB. eBPF programs can determine whether a given cgroup is permitted to perform a requested socket operation or data transmission. 7.5.7 Infrared ControllersPrograms of type BPF_PROG_TYPE_LIRC_MODE2 can be attached to the file descriptor for an infrared controller device to provide decoding for infrared protocols. 7.6 BPF Attachment TypesThe attachment type offers more fine-grained control over where a program can be attached in the system. For example, XDP programs are attached to XDP hooks in the network stack. The attachment type is involved in deciding which helper functions are valid, and it also restricts access to parts of the context information in some cases. You can also see which program types need an attachment type to be specified, and which attachment types are valid, in the kernel function bpf_prog_load_check_attach (defined in bpfsyscall.c). For example case BPF_PROG_TYPE_CGROUP_SOCK: switch (expected_attach_type) case BPF_CGROUP_INET_SOCK_CREATE: case BPF_CGROUP_INET_SOCK_RELEASE: case BPF_CGROUP_INET4_POST_BIND: case BPF_CGROUP_INET6_POST_BIND: return 0; default: return -EINVAL; 7.7 SummaryIf you want to write code that responds to a particular event, you’ll need to determine the program type(s) that are appropriate for hooking onto that event. The context passed into the program depends on the program type, and the kernel may also respond differently to the return code from your program, depending on its type. 7.8 Exercisestodo"},{"title":"09. eBPF for Security","path":"/wiki/ebpf/learning-ebpf-09.html","content":"9.1 Security Observability Requires Policy and Contexta security tool needs to be able to distinguish between events that are expected under normal circumstances and events that suggest malicious activity might be taking place. Policies have to take into account not just normal behavior when systems are fully functional, but also the expected error path behavior. Defining what is and isn’t expected behavior is the job of a policy. The more contextual information that’s available to the investigator, the more likely they will be able to find out the root cause of the event and determine whether it was an attack, which components were affected, how and when the attack took place, and who was responsible. 9.2 Using System Calls for Security EventsSystem calls (or syscalls) are the interface between user space applications and the kernel. 9.2.1 SeccompSECure COMPuting seccomp is used to limit the set of syscalls a process can use to a very small subset: read(), write(), _exit(), and sigreturn(). seccomp-bpf: Instead of having a fixed subset of syscalls that it permits, this mode of seccomp uses BPF code to filter the syscalls that are and aren’t allowed. The outcome is one of a set of possible actions that include: Allowing the syscall to go ahead Returning an error code to the user space application Killing the thread Notifying a user space application (seccomp-unotify) (as of kernel version 5.0) Generating Seccomp ProilesIn the early days, seccomp profiles were generally compiled using strace to gather the set of syscalls an application calls. There are a couple of tools that do this, using eBPF to gather information about all the syscalls being called: Inspektor Gadget includes a seccomp profiler that allows you to generate a custom seccomp profile for the containers in a Kubernetes pod. Red Hat created a seccomp profiler in the form of an OCI runtime hook. Syscall-Tracking Security Toolsthe CNCF project Falco, which provides security alerts Users can define rules to determine what events are security relevant, and Falco can generate alerts in a variety of formats when events happen that don’t match the policies defined in these rules. BPF_PROBE(raw_syscalls/, sys_enter, sys_enter_args)BPF_PROBE(raw_syscalls/, sys_exit, sys_exit_args) Since eBPF programs can be loaded dynamically and can detect events triggered by preexisting processes, tools like Falco can apply policies to application workloads that are already running. Unfortunately there is a problem with this approach of using syscall entry points for security tooling: there is a Time Of Check to Time Of Use (TOCTOU) issue. When an eBPF program is triggered at the entry point to a system call, it can access the arguments that user space has passed to that system call. If those arguments are pointers, the kernel will need to copy the pointed-to data into its own data structures before acting on that data. there is a window of opportunity for an attacker to modify this data, after it has been inspected by the eBPF program but before the kernel copies it. The Sysmon for Linux tool addresses the TOCTOU window by attaching to both the entry and exit points for syscalls. if the syscall returns a file descriptor, the eBPF program attached to the exit can retrieve correct information about the object that the file descriptor represents by looking into the related process’s file descriptor table. 9.3 BPF LSMThe LSM interface provides a set of hooks that each occur just before the kernel is about to act on a kernel data structure. The function called by a hook can make a decision about whether to allow the action to go ahead. Here’s a trivial example of an eBPF program attached to an LSM hook. This example is called during the processing of a chmod command SEC(lsm/path_chmod)int BPF_PROG(path_chmod, const struct path *path, umode_t mode) bpf_printk(Change mode of file name %s , path-dentry-d_iname); return 0; LSM BPF was added in kernel version 5.7 9.4 Cilium TetragonTetragon is part of the Cilium project. Tetragon’s approach is to build a framework for attaching eBPF programs to arbitrary functions in the Linux kernel. Tetragon is designed for use in a Kubernetes environment, and the project defines a custom Kubernetes resource type called a TracingPolicy. spec: kprobes: - call: fd_install... matchArgs: - index: 1 operator: Prefix values: - /etc/... 9.4.1 Attaching to Internal Kernel FunctionsThe “fd” stands for “file descriptor,” and the comment in the source code for this function tells us this function “Install[s] a file pointer in the fd array.” This happens when a file is opened, and it’s called after the file’s data structure has been populated in the kernel. 9.4.2 Preventative SecurityIn kernel versions 5.3 and up, there is a BPF helper function called bpf_send_signal(). Tetragon uses this function to implement preventative security. If a policy defines a Sigkill action, any matching events will cause Tetragon eBPF code to generate a SIGKILL signal that terminates the process that was attempting the out-of-policy action. Sigkill policies need to be used with care, because an incorrectly configured policy could result in terminating applications unnecessarily, but it’s an incredibly powerful use of eBPF for security purposes. 9.5 Network SecurityNetwork security tools are very often used in a preventative mode, dropping packets rather than just auditing malicious activity. Firewalling and DDoS protection are a natural fit for eBPF programs attached early in the ingress path for network packets. And with the possibility of XDP programs offloaded to hardware, malicious packets may never even reach the CPU! For implementing more sophisticated network policies, such as Kubernetes policies determining which services are allowed to communicate with one another, eBPF programs that attach to points in the network stack can drop packets if they are determined to be out of policy. 9.6 SummaryIn this chapter you saw how eBPF’s use in security has evolved from low-level checks on system calls to much more sophisticated use of eBPF programs for security policy checks, in-kernel event filtering, and runtime enforcement."},{"title":"08. eBPF for Networking","path":"/wiki/ebpf/learning-ebpf-08.html","content":"eBPF 允许开发者构建满足特定需求的网络功能，而无需将这些功能强制推行给所有上游内核用户。 基于 eBPF 的网络工具现在被广泛使用，并已被证明在大规模应用中非常有效。 Cilium 自 2017 年以来，所有进出 Facebook 的数据包都经过了 XDP 程序的处理 Cloudflare 使用 eBPF 来进行 DDoS（分布式拒绝服务）保护 8.1 Packet Drops有几种涉及丢弃特定传入数据包和允许其他数据包的网络安全功能。 防火墙 根据源、目的 IP 地址以及端口号，逐个数据包决定是否允许数据包。 DDoS 防护 可能要跟踪来自特定来源的数据包的到达速度，检测数据包内容的某些特征，以确定攻击者或一组攻击者正试图用流量淹没接口。 致命数据包漏洞 (packet-of-death vulnerabilities) 传统上，当发现这种内核漏洞时，需要安装修复的新内核，这需要停机维护。 能检测并丢弃这些恶意数据包的 eBPF 程序可以动态安装，在不影响机器上运行的任何应用程序的情况下立即保护主机。 8.1.1 XDP Program Return Codes网络数据包的到达会触发 XDP 程序。程序会检查数据包，检查完毕后，返回值会给出一个决策(verdict)，指出下一步该如何处理该数据包： XDP_PASS 数据包应以正常方式发送到网络协议栈（就像没有 XDP 程序时的执行流程） XDP_DROP 立即丢弃数据包 XDP_TX 将数据包从其到达的同一接口发送回去 XDP_REDIRECT 将数据包从不同的网络接口发送回去 XDP_ABORTED 丢弃数据包，但它的使用意味着出现错误或出现意外情况，而不是 “正常” 决定丢弃数据包 决定是否丢弃数据包的 XDP 程序大致如下： SEC(xdp)int hello(struct xdp_md *ctx) bool drop; drop = examine packet and decide whether to drop it; if (drop) return XDP_DROP; else return XDP_PASS; 每当一个入站网络数据包到达其所连接的接口时，XDP 程序就会被触发。ctx 参数是一个指向 xdp_md 结构体的指针，该结构体保存了传入数据包的元数据。 8.1.2 XDP Packet Parsingxdp_md 结构体的定义如下： struct xdp_md __u32 data; __u32 data_end; __u32 data_meta; /* Below access go through struct xdp_rxq_info */ __u32 ingress_ifindex; /* rxq-dev-ifindex */ __u32 rx_queue_index; /* rxq-queue_index */ __u32 egress_ifindex; /* txq-dev-ifindex */; 不要被前三个字段的 __u32 类型所迷惑，因为它们实际上是指针。 data 字段指示数据包在内存中的起始位置，data_end 表示数据包的结束位置。 数据包前面的内存中还有一个区域，位于 data_meta 和 data 之间，用于存储有关该数据包的元数据。该区域可用于协调多个 eBPF 程序，这些程序可能会在数据包通过网络协议栈的不同位置处理同一个数据包。 hello ping示例代码中有一个名为 ping() 的 XDP 程序，每当检测到 ping (ICMP) 数据包时，它就会简单地生成一行跟踪信息。该程序的代码如下： SEC(xdp)int ping(struct xdp_md *ctx) long protocol = lookup_protocol(ctx); if (protocol == 1) // ICMP bpf_printk(Hello ping); return XDP_PASS; 运行方式如下： $ cd learning-ebpf/chapter8$ makebpftool net detach xdp dev lorm -f /sys/fs/bpf/hellobpftool prog load hello.bpf.o /sys/fs/bpf/hellobpftool net attach xdp pinned /sys/fs/bpf/hello dev lo $ ping localhost $ cat /sys/kernel/tracing/trace_pipe ping-62820 [001] ..s21 177285.227847: bpf_trace_printk: Hello ping ping-62820 [001] ..s21 177285.228119: bpf_trace_printk: Hello ping ping-62820 [001] ..s21 177286.232176: bpf_trace_printk: Hello ping ping-62820 [001] ..s21 177286.232185: bpf_trace_printk: Hello ping 每秒有两行跟踪信息，是因为回环接口同时接收 ping 请求和 ping 响应。 通过添加如下代码，在协议匹配时返回 XDP_DROP，可以实现丢弃 ping 数据包： if (protocol == 1) // ICMP bpf_printk(Hello ping);+ return XDP_DROP; 在这个 XDP 程序中，大部分工作都是在一个名为 lookup_protocol() 的函数中完成的，该函数用于确定第 4 层协议类型。这只是一个示例，并不是解析网络数据包的高质量实现！ 接收到的网络数据包由一串字节组成，其布局如图所示： ethhdr 和 iphdr 的定义如下： struct ethhdr unsigned char\th_dest[ETH_ALEN];\t/* destination eth addr\t*/\tunsigned char\th_source[ETH_ALEN];\t/* source ether addr\t*/\t__be16 h_proto; /* packet type ID field\t*/ __attribute__((packed));struct iphdr #if defined(__LITTLE_ENDIAN_BITFIELD)\t__u8\tihl:4, version:4;#elif defined (__BIG_ENDIAN_BITFIELD)\t__u8\tversion:4, ihl:4;#else#error\tPlease fix asm/byteorder.h#endif\t__u8\ttos;\t__be16\ttot_len;\t__be16\tid;\t__be16\tfrag_off;\t__u8\tttl;\t__u8\tprotocol;\t__sum16\tcheck;\t__be32\tsaddr;\t__be32\tdaddr;\t/*The options start here. */; lookup_protocol() 函数接收 ctx 结构体作为参数，该结构体保存数据包在内存中的位置信息，并返回它在 IP 报头中找到的协议类型。代码如下： // Returns the protocol byte for an IP packet, 0 for anything else// static __always_inline unsigned char lookup_protocol(struct xdp_md *ctx)unsigned char lookup_protocol(struct xdp_md *ctx) unsigned char protocol = 0; // 记录网络数据包的起始位置和结束位置 void *data = (void *)(long)ctx-data; void *data_end = (void *)(long)ctx-data_end; // 以太网报头开始 struct ethhdr *eth = data; // 验证器要求明确检查这个网络数据包足够容纳以太网报头 if (data + sizeof(struct ethhdr) data_end) return 0; // Check that its an IP packet if (bpf_ntohs(eth-h_proto) == ETH_P_IP) // Return the protocol of this packet // 1 = ICMP // 6 = TCP // 17 = UDP // 如果是 IP 数据包，则 IP 报头紧跟在以太网报头之后 struct iphdr *iph = data + sizeof(struct ethhdr); // 验证器要求明确检查这个网络数据包足够容纳 IP 报头 if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) = data_end) protocol = iph-protocol; return protocol; bpf_ntohs() 函数可确保两个字节按照主机序排列。网络协议是大端字节序，但大多数处理器是小端字节序，这意味着它们以不同的顺序保存多字节值。此函数将从网络序转换为主机序（如有必要）。 NOTE:当从长度超过一个字节的网络数据包中提取字段信息时，都应该使用 bpf_ntohs()。 8.2 Load Balancing and ForwardingXDP 程序不仅限于检查数据包的内容，还可以修改数据包的内容。 如图所示，这是一组在同一主机上运行的容器。有一个客户端、一个负载均衡器和两个后端，每个后端都在自己的容器中运行。负载均衡器接收来自客户端的流量并将其转发到任意一个后端容器。 示例代码仅用于学习，请勿用于生产环境。 SEC(xdp_lb)int xdp_load_balancer(struct xdp_md *ctx) // 定位数据包中的以太网报头，然后定位 IP 报头。 void *data = (void *)(long)ctx-data; void *data_end = (void *)(long)ctx-data_end; struct ethhdr *eth = data; if (data + sizeof(struct ethhdr) data_end) return XDP_ABORTED; if (bpf_ntohs(eth-h_proto) != ETH_P_IP) return XDP_PASS; struct iphdr *iph = data + sizeof(struct ethhdr); if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) data_end) return XDP_ABORTED; // 这次它将只处理 TCP 数据包，将收到的任何其他数据包传递给网络协议栈，就好像什么也没发生一样。 if (iph-protocol != IPPROTO_TCP) return XDP_PASS; // 检查源 IP 地址。 if (iph-saddr == IP_ADDRESS(CLIENT)) // 在后端 A 和 B 之间生成伪随机选择。 char be = BACKEND_A; if (bpf_get_prandom_u32() % 2) be = BACKEND_B; // 更新目标 IP 和 MAC 地址，以匹配所选的后端... iph-daddr = IP_ADDRESS(be); eth-h_dest[5] = be; // 如果该数据包不是来自客户端，就认为它是发给客户端的响应。 else // 更新目标 IP 和 MAC 地址以匹配客户端。 iph-daddr = IP_ADDRESS(CLIENT); eth-h_dest[5] = CLIENT; // 无论该数据包流向何处，都需要更新源地址，以便该数据包看起来像是源自负载均衡器。 iph-saddr = IP_ADDRESS(LB); eth-h_source[5] = LB; iph-check = iph_csum(iph); return XDP_TX; 8.3 XDP Offloading有一些网卡支持完整的 XDP 卸载 (XDP Offloading) 功能，它们确实可以在自己的处理器上运行 eBPF 程序来处理传入的数据包。 这就意味着，从同一物理接口丢弃或重定向回来的数据包（如本章前面的数据包丢弃和负载均衡示例），主机内核永远不会看到，主机上的 CPU 周期也不会用于处理这些数据包，因为所有工作都是在网卡上完成的。 即使物理网卡不支持完整的 XDP 卸载，许多 NIC 驱动程序也支持 XDP 钩子，这可以最大限度地减少 eBPF 程序处理数据包所需的内存复制。 8.4 Traic Control (TC)当网络数据包到达这一附加点时，它将以 sk_buff 的形式存在于内核内存中，sk_buff 在整个内核的网络协议栈都有使用。 在 TC 子系统中附加的 eBPF 程序会接收一个指向 sk_buff 结构体的指针作为上下文参数。 NOTE:您可能想为什么 XDP 程序不在其上下文中使用 sk_buff 结构。答案是，XDP 钩子发生在网络数据到达网络协议栈之前以及 sk_buff 结构体建立之前。 TC 子系统旨在调节网络流量的调度方式。例如，您可能希望限制每个应用程序的可用带宽，以便它们都能获得公平的机会。但在调度单个数据包时，带宽并不是一个非常有意义的术语，因为它是指发送或接收的平均数据量。某个特定的应用程序可能非常容易有突发流量，或者另一个应用程序可能对网络延迟非常敏感，因此 TC 可以对数据包的处理方式和优先级进行更精细的控制。 延伸阅读： Understanding tc “direct action” mode for BPF 引入 eBPF 程序是为了对 TC 内使用的算法进行自定义控制。但由于 eBPF 程序具有操纵、丢弃或重定向数据包的功能，因此也可用作复杂网络行为的构建模块。 网络协议栈中给定的网络数据流有两个方向：入口（ingress，从网络接口进入）或出口（egress，向网络接口输出）。eBPF 程序可以附加在任一方向上，并只影响该方向上的流量。 NOTE:与 XDP 不同， TC 可以附加多个 eBPF 程序，并按顺序进行处理。 传统的流量控制分为： 分类器 (classifers)：根据某些规则对数据包进行分类 单独的操作 (separate actions)：根据分类器的输出决定如何处理数据包。 可以有一系列分类器，它们都被定义为 qdisc 或排队规则（queuing discipline）的一部分。 eBPF 程序是作为分类器附加在程序上的，但它们也可以决定在同一程序中采取什么行动。该操作由程序的返回值（其值在 linux/pkt_cls.h 中定义）表示： TC_ACT_SHOT: 告诉内核丢弃数据包 TC_ACT_UNSPEC: 就像 eBPF 程序尚未在此数据包上运行一样（因此它将被传递到序列中的下一个分类器（如果有）） TC_ACT_OK: 告诉内核将数据包传递到网络协议栈的下一层 TC_ACT_REDIRECT: 将数据包发送到不同网络设备的入口或出口路径 示例1：只是生成一行跟踪信息，然后告诉内核丢弃数据包： int tc_drop(struct __sk_buff *skb) bpf_trace_printk([tc] dropping packet ); return TC_ACT_SHOT; 示例2：丢弃 ICMP (ping) 请求数据包 int tc(struct __sk_buff *skb) void *data = (void *)(long)skb-data; void *data_end = (void *)(long)skb-data_end; if (is_icmp_ping_request(data, data_end)) struct iphdr *iph = data + sizeof(struct ethhdr); struct icmphdr *icmp = data + sizeof(struct ethhdr) + sizeof(struct iphdr); bpf_trace_printk([tc] ICMP request for %x type %x , iph-daddr, icmp-type); return TC_ACT_SHOT; return TC_ACT_OK; sk_buff 结构体具有指向数据包数据开始和结束的指针，这与 xdp_md 结构体非常相似，数据包的解析过程也大致相同。同样，要通过验证，必须明确检查对数据的任何访问是否在 data 和 data_end 之间的范围内。 既然 XDP 已经实现了同样的功能，为什么还要在 TC 层实现这样的功能呢？ 可以使用 TC 程序处理出口流量，而 XDP 只能处理入口流量。 由于 XDP 会在数据包到达时立即触发，此时并不存在与数据包相关的 sk_buff 内核数据结构。如果 eBPF 程序对内核为该数据包创建的 sk_buff 感兴趣或想对其进行操作，那么 TC 附加点是合适的。 延伸阅读： BPF and XDP Reference Guide 示例3：识别收到的 ping 请求，并作出 ping 响应。 int tc_pingpong(struct __sk_buff *skb) void *data = (void *)(long)skb-data; void *data_end = (void *)(long)skb-data_end; if (!is_icmp_ping_request(data, data_end)) return TC_ACT_OK; struct iphdr *iph = data + sizeof(struct ethhdr); struct icmphdr *icmp = data + sizeof(struct ethhdr) + sizeof(struct iphdr); swap_mac_addresses(skb); swap_ip_addresses(skb); // Change the type of the ICMP packet to 0 (ICMP Echo Reply) (was 8 for ICMP Echo request) update_icmp_type(skb, 8, 0); // sends a clone of the packet back through the interface (skb-ifindex) on which it was received. bpf_clone_redirect(skb, skb-ifindex, 0); //the original packet should be dropped return TC_ACT_SHOT; 如今，许多网络功能都是由用户空间服务处理的，但如果用 eBPF 程序来替代，很可能会大大提高性能。在内核中处理的数据包不需要通过协议栈的所有部分；数据包不需要传输到用户空间进行处理，而响应也不需要传回内核。更重要的是，两者可以并行运行——eBPF 程序可以为任何需要复杂处理而自己又无法处理的数据包返回 TC_ACT_OK，这样它就可以正常传递到用户空间服务。 8.5 Packet Encryption and DecryptionIn many cases an application will encrypt data using a library like OpenSSL or BoringSSL that lives in user space. If you want to trace out this data in its unencrypted form, you can use an eBPF program attached to the right place in the user space code. 8.5.1 User Space SSL LibrariesAn application using OpenSSL sends data to be encrypted by making a call to a function called SSL_write() and retrieves cleartext data that was received over the network in encrypted form using SSL_read(). https://github.com/pixie-io/pixie-demos/tree/main/openssl-tracer static int process_SSL_data(struct pt_regs* ctx, uint64_t id, enum ssl_data_event_type type, const char* buf) int len = (int)PT_REGS_RC(ctx); if (len 0) return 0; struct ssl_data_event_t* event = create_ssl_data_event(id); if (event == NULL) return 0; event-type = type; // This is a max function, but it is written in such a way to keep older BPF verifiers happy. event-data_len = (len MAX_DATA_SIZE ? (len (MAX_DATA_SIZE - 1)) : MAX_DATA_SIZE); bpf_probe_read(event-data, event-data_len, buf); tls_events.perf_submit(ctx, event, sizeof(struct ssl_data_event_t)); return 0; 8.6 eBPF and Kubernetes NetworkingIn Kubernetes environments, applications are deployed in pods. Each pod is a group of one or more containers that share kernel namespaces and cgroups, isolating pods from each other and from the host machine they are running on. eBPF enables replacing iptables and conntrack with a more efficient solution for managing network rules and connection tracking. 8.6.1 Avoiding iptablespods – and their IP addresses – come and go dynamically, and each time a pod is added or removed, the iptables rules have to be rewritten in their entirety, and this impacts performance at scale. Cilium uses eBPF hash table maps to store network policy rules, connection tracking, and load balancer lookup tables, which can replace iptables for kube-proxy. 8.6.2 Coordinated Network Programsflat networking mode, in which Cilium allocates IP addresses for all the pods in a cluster from the same CIDR and directly routes traffic between them. Different eBPF programs get invoked to handle traffic depending on whether a packet is destined for a local container, the local host, another host on this network, or a tunnel. 8.6.3 Network Policy EnforcementCilium uses Kubernetes identities to determine whether a given network policy rule applies. In the same way labels define which pods are part of a service in Kubernetes, labels also define Cilium’s security identity for the pod. eBPF hash tables, indexed by these service identities, make for very efficient rule lookups. 8.6.4 Encrypted Connectionstransparent encryption. It’s called “transparent” because it takes place entirely at the network layer. There are two in-kernel encryption protocols in common usage, IPsec and WireGuard. they set up a secure tunnel between two machines. The CNI can choose to connect the eBPF endpoint for a pod via this secure tunnel. eBPF is now enabling a new approach that builds on transparent encryption but uses TLS for the initial certificate exchange and endpoint authentication so that the identities can represent individual applications rather than the nodes they are running on. 8.7 Summarytodo 8.8 Exercises and Further Readingtodo"},{"title":"10. eBPF Programming","path":"/wiki/ebpf/learning-ebpf-10.html","content":"eBPF programming consists of two parts: Writing eBPF programs that run in the kernel Writing the user space code that manages and interacts with eBPF programs 10.1 BpftraceThe bpftrace command-line tool converts programs written in this high-level language into eBPF kernel code and provides some output formatting for the results within the terminal. a nice tutorial that takes you from writing a simple “Hello World” script up to writing more sophisticated scripts that can trace out data read from within kernel data structures. list the available tracepoints and kprobes on a machine with the -l option bpftrace -l *execve* it’s possible to attach to a kprobe called do_execve. bpftrace -e kprobe:do_execve @[comm] = count(); The @[comm] = count(); part is the script attached to that event. opensnoop.bt reports on files being opened. /usr/sbin/opensnoop.bt 10.2 Language Choices for eBPF in the KerneleBPF programs can be written directly in eBPF bytecode, but in practice, most are compiled to bytecode from either C or Rust. These languages have compilers that support eBPF bytecode as a target output. eBPF bytecode isn’t a suitable target for all compiled languages. BPF programs are required to be single threaded, so any concurrency features in a language couldn’t be used. 10.3 BCC PythonLuaC++10.4 C and LibbpfIf you’re comfortable with programming in C, using libbpf can make a lot of sense. To write your own libbpf programs in C, the best place to start is libbpf-bootstrap. libxdp that builds on libbpf to allow for easier development and management of XDP programs. the XDP Tutorial 10.5 Go10.5.1 GobpfPossibly the first serious Golang implementation. However, it hasn’t been actively maintained for a while. 10.5.2 Ebpf-goThe eBPF Go library included as part of the Cilium project is widely used. 10.5.3 LibbpfgoThe libbpfgo project by Aqua Security implements a Go wrapper around libbpf’s C code, providing utilities for loading and attaching programs and using Go-native features like channels for receiving events. 10.6 Rust10.6.1 Libbpf-rsLibbpf-rs is part of the libbpf project, and provides a Rust wrapper around the libbpf C code so that you can write the user space parts of eBPF code in Rust. 10.6.2 RedbpfRedbpf is a set of Rust crates that interface with libbpf, developed as part of foniod, an eBPF-based security monitoring agent. 10.6.3 AyaAya is built in Rust directly to the syscall level, so it doesn’t depend on libbpf. 10.6.4 Rust-bccRust-bcc provides Rust bindings that mimic the BCC project’s Python bindings, along with some Rust implementations of some of the BCC set of tracing tools. 10.7 Testing BPF ProgramsThere’s a bpf() command, BPF_PROG_RUN, that allows for running an eBPF program from user space for test purposes. You can also get information about eBPF program performance with some built-in statistics information. Run the following command to enable it: sysctl -w kernel.bpf_stats_enabled=1 10.8 Multiple eBPF ProgramsAn eBPF program is a function attached to an event in the kernel. Many applications need to track more than one event to achieve their goals. 10.9 Summaryan up-to-date list of the major language projects around eBPF 10.10 Summarytodo"},{"title":"env","path":"/wiki/ebpf/libbpf-bootstrap-00.html","content":"Githublibbpf-bootstraphttps://github.com/libbpf/libbpf-bootstrap DeepWikideepwikihttps://deepwiki.com/libbpf/libbpf-bootstrap Env WSL2 Ubuntu 24.04 BuildingInstall Dependenciessudo apt install clang libelf1 libelf-dev zlib1g-dev Getting the source codegit clone --recurse-submodules https://github.com/libbpf/libbpf-bootstrap.git C Examples$ git submodule update --init --recursive # check out libbpf$ cd examples/c$ make$ sudo ./bootstrapTIME EVENT COMM PID PPID FILENAME/EXIT CODE00:21:22 EXIT python3.8 4032353 4032352 [0] (123ms)00:21:22 EXEC mkdir 4032379 4032337 /usr/bin/mkdir00:21:22 EXIT mkdir 4032379 4032337 [0] (1ms)00:21:22 EXEC basename 4032382 4032381 /usr/bin/basename00:21:22 EXIT basename 4032382 4032381 [0] (0ms)00:21:22 EXEC sh 4032381 4032380 /bin/sh00:21:22 EXEC dirname 4032384 4032381 /usr/bin/dirname00:21:22 EXIT dirname 4032384 4032381 [0] (1ms)00:21:22 EXEC readlink 4032387 4032386 /usr/bin/readlink^C"},{"title":"minimal","path":"/wiki/ebpf/libbpf-bootstrap-01.html","content":"运行$ cd examples/c$ make minimal$ sudo ./minimal $ sudo cat /sys/kernel/debug/tracing/trace_pipe ...-3840345 [010] d... 3220701.101143: bpf_trace_printk: BPF triggered from PID 3840345. ...-3840345 [010] d... 3220702.101265: bpf_trace_printk: BPF triggered from PID 3840345. QA你可能会发现`sudocat/sys/kernel/debug/tracing/trace_pipe`没有任何的输出信息。这是因为在 WSL 中运行的进程处于一个 PID 命名空间（PID namespace）内，因此从用户空间（userspace）获取的 PID 是该命名空间内的 PID，而通过 eBPF 代码中的 bpf_get_current_pid_tgid 函数获取的 PID 则是全局 PID（global PID）。 以下是我的分析和调试过程： 使用 strace 确认 sys_enter_write 是否被调用，通过以下命令重新运行 minimal # 使用 root 用户$ strace ./minimal 可以看到如下输出信息，确认 sys_enter_write 被调用： execve(./minimal, [./minimal], 0x7ffc2c4a8660 /* 35 vars */) = 0...write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0 在 handle_tp 的函数入口和函数返回前，通过 bpf_printk 增加打印信息，确认函数的执行流程 SEC(tp/syscalls/sys_enter_write)int handle_tp(void *ctx)+ bpf_printk(handle_tp );\tint pid = bpf_get_current_pid_tgid() 32;\tif (pid != my_pid)+ bpf_printk(pid != my_pid ); return 0;\tbpf_printk(BPF triggered from PID %d. , pid);\treturn 0; 通过查找代码库的 Issues ，我发现如下两条相关信息： libbpflibbpf-bootstrap#75 microsoftWSL#8461 实际上代码库已经给出了解决方案😅，那就是使用 minimal_ns 。 代码梳理这是一个实用的最小化 BPF 应用程序示例。该示例不使用也不依赖 BPF CO-RE（BPF 编译时重定位）技术，因此可在相当老旧的内核版本上运行。 它会安装一个跟踪点（tracepoint）处理程序，该处理程序每秒触发一次。示例中使用 bpf_printk() 这个 BPF 辅助函数与外部环境进行通信。 The BPF side minimal.bpf.c #include linux/bpf.h#include bpf/bpf_helpers.h #include linux/bpf.h 导入了一些基础的、必要的 BPF 相关的类型和常量，以便使用内核侧的 BPF API。 #include bpf/bpf_helpers.h 由 libbpf 提供的，包含了大多数常用的宏、常量和 BPF helper 的定义，几乎会在每个 BPF 应用中用到。 char LICENSE[] SEC(license) = Dual BSD/GPL; LICENSE 变量定义了你的 BPF 代码的 license。在内核开发中，明确 license 是必须的。一些 BPF 功能对于不兼容 GPL 的代码是不可用的。 int my_pid = 0; 定义了一个全局变量，BPF 代码可以读取和更新它。这样的全局变量能够从用户侧读写。这个特性是从 Linux 5.5 之后才支持的。它也经常用于在内核中的 BPF 代码和用户侧的控制代码之间传递数据。 SEC(tp/syscalls/sys_enter_write)int handle_tp(void *ctx) ... 定义了一个 tracepoint BPF 程序，每次用户空间的应用调用了系统调用 write() 的时候，就会触发它。 在同一个 BPF C 程序文件中，可能有多个 BPF 程序。他们可以是不同类型的，有着不同的 SEC() 宏。在同一个 BPF C 代码文件中的所有的 BPF 程序共享所有的全局状态，例如上面例子中的 my_pid 变量，如果使用了 BPF map，它也是共享的。这常常用在 BPF 程序的协作中。 下面看下 BPF 程序 handle_tp 在做什么： int pid = bpf_get_current_pid_tgid() 32;if (pid != my_pid)\treturn 0; 这部分获取了 PID，或者说是内核术语中的 “TGID” ，它存储在 bpf_get_current_pid_tgid() 返回值的高 32 位。 接着，查看触发了 write() 系统调用的进程是否是我们的 minimal 进程。 全局变量 my_pid 是通过下面的用户空间的代码进行初始化的，它会被初始化成真实的 PID 值。 bpf_printk(BPF triggered from PID %d. , pid); 这就是 BPF 中的 printf(“Hello, world! ”)。它输出格式化的字符串到一个特殊的文件，叫作 /sys/kernel/debug/tracing/trace_pipe。 bpf_printk() 和 trace_pipe 文件一般不在生产环境中使用，它们是用来辅助 BPF 程序的 debug 的，帮助开发者知道自己的代码到底干了些什么事情。 The user-space side minimal.c #include minimal.skel.h 这里导入了 BPF 代码 minimal.bpf.c 中的 BPF skeleton。 它是在 Makefile中的某一步，由 bpftool 自动生成的文件，像这样： bpftool gen skeleton minimal.bpf.o minimal.skel.h 它高度抽象了 minimal.bpf.c 的结构，也简化了 BPF 代码部署的逻辑，将编译出的 BPF 目标代码嵌入到了头文件中，该头文件又会被用户空间的代码所引用。你的应用程序的二进制文件中不会有其他多余的文件了，只导入它就好了。 关于 BPF skeleton 的更多信息可以参考: Learning eBPF: 5.9 The Libbpf Library for User Spacehttps://gaoyangu.github.io/wiki/ebpf/learning-ebpf-05/#5-9-The-Libbpf-Library-for-User-Space minimal 应用的 main() 函数在做什么： static int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)\treturn vfprintf(stderr, format, args);int main(int argc, char **argv)\tstruct minimal_bpf *skel;\tint err;\t/* Set up libbpf errors and debug info callback */\tlibbpf_set_print(libbpf_print_fn); libbpf_set_print() 提供了一个自定义的回调给所有的 libbpf 日志输出。它允许捕获有用的 libbpf 调试日志。默认情况下，libbpf 将只打印错误级别的信息。调试日志则会帮助我们更快地定位问题。 /* Open BPF application */skel = minimal_bpf__open();if (!skel) fprintf(stderr, Failed to open BPF skeleton );\treturn 1;/* ensure BPF program only handles write() syscalls from our process */skel-bss-my_pid = getpid();/* Load verify BPF programs */err = minimal_bpf__load(skel);if (err) fprintf(stderr, Failed to load and verify BPF skeleton );\tgoto cleanup; 使用自动生成的 BPF skeleton，加载 BPF 程序到内核中，然后让 BPF verifier 校验它是否合法，如果这步成功了，你的 BPF 代码就是正确的。 我们需要与 BPF 传递我们的用户态程序的 PID，以便它能够过滤掉不相关的进程触发的 write() 事件。上面的代码会直接设置映射过的内存区域的 BPF 全局变量 my_pid。 关于 my_pid 存储在 bss 段的原因，可参考： c语言内存分配https://gaoyangu.github.io/wiki/ebpf/sections/ /* Attach tracepoint handler */err = minimal_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton );\tgoto cleanup; 将 handle_tp BPF 程序附加到对应的内核跟踪点（tracepoint）上。这一操作会 “激活” 该 BPF 程序，此后每当有 write() 系统调用被触发时，内核便会在内核上下文中执行我们自定义的 BPF 代码。 for (;;) /* trigger our BPF program */\tfprintf(stderr, .);\tsleep(1); 周期性地（每秒）调用 fprintf(stderr, .)，从而触发 write() 系统调用。 cleanup:\tminimal_bpf__destroy(skel);\treturn -err; 在内核和用户空间清除所有的资源。也有一些类型的 BPF 程序，会在内核中一直保持活跃，即使它自己的用户空间的进程已经结束了。"},{"title":"minimal_ns","path":"/wiki/ebpf/libbpf-bootstrap-02.html","content":"描述:如何获取 namespace 中的进程ID minimal_ns 与 minimal 功能相同，但其适用于命名空间环境。 minimal 在存在命名空间的环境中（如容器或 WSL2）无法正常工作，原因是该环境下进程的 “感知 PID”（perceived pid）并非进程的 “实际 PID”（actual pid）。 代码梳理The BPF side minimal_ns.bpf.c SEC(“tpsyscallssys_enter_write”)SEC(tp/syscalls/sys_enter_write)int handle_tp(void *ctx) bpf_get_ns_current_pid_tgidint my_pid = 0;unsigned long long dev;unsigned long long ino;bpf_get_ns_current_pid_tgid(dev, ino, ns, sizeof(ns));if (ns.pid != my_pid)\treturn 0; The user-space side minimal_ns.c procselfnspid/* ensure BPF program only handles write() syscalls from our process */if (stat(/proc/self/ns/pid, sb) == -1) fprintf(stderr, Failed to acquire namespace information); return 1;skel-bss-dev = sb.st_dev;skel-bss-ino = sb.st_ino;skel-bss-my_pid = getpid(); stat(/proc/self/ns/pid, sb) 用于获取当前进程所属的「PID 命名空间（PID Namespace）」的元数据，通过返回的 struct stat 结构体中的 st_ino（inode 号），识别当前进程的 PID 命名空间归属（判断两个进程是否在同一个 PID 命名空间）。"},{"title":"minimal_Legacy","path":"/wiki/ebpf/libbpf-bootstrap-03.html","content":"描述:SEC(.maps)的使用方式 在 2019 年才增加了对全局变量的支持，在此之前只能使用 eBPF map 来实现。 minimal_Legacy 可在不支持全局变量的更老旧内核上运行。全局变量 my_pid 已替换为一个仅含一个元素的数组，用于存储进程 ID（pid）。 在包含 bpf_helpers.h 头文件之前，若未定义 BPF_NO_GLOBAL_DATA 宏，则 bpf_printk 函数会使用全局变量。 代码梳理The BPF sideSEC(“.maps”)typedef unsigned int u32;typedef int pid_t;/* Create an array with 1 entry instead of a global variable * which does not work with older kernels */struct __uint(type, BPF_MAP_TYPE_ARRAY);\t__uint(max_entries, 1);\t__type(key, u32);\t__type(value, pid_t); my_pid_map SEC(.maps); SEC(“tpsyscallssys_enter_write”)SEC(tp/syscalls/sys_enter_write)int handle_tp(void *ctx) bpf_map_lookup_elemu32 index = 0;pid_t *my_pid = bpf_map_lookup_elem(my_pid_map, index);if (!my_pid || *my_pid != pid)\treturn 1; The user-space sidebpf_map__update_elempid_t pid;unsigned index = 0;/* ensure BPF program only handles write() syscalls from our process */pid = getpid();err = bpf_map__update_elem(skel-maps.my_pid_map, index, sizeof(index), pid, sizeof(pid_t), BPF_ANY);if (err 0) fprintf(stderr, Error updating map with pid: %s , strerror(err)); goto cleanup;"},{"title":"bootstrap","path":"/wiki/ebpf/libbpf-bootstrap-04.html","content":"描述:适用于生产环境下的BPF应用的通用基础模板 bootstrap 是一个简单但适用于生产环境下的 BPF 应用。它依赖 BPF CO-RE，同时要求内核编译时配置 CONFIG_DEBUG_INFO_BTF=y。 它会跟踪进程的启动和退出事件，并输出相关数据，包括文件名、进程 ID（PID）、父进程 ID（PPID），以及进程的退出状态和生命周期。 它展示了几个典型的 BPF 功能的使用方式: 协调工作的 BPF 程序 用于维护状态的 BPF map 用于向用户空间发送数据的 BPF ring buffer 用于实现应用程序行为参数化的全局变量 利用 BPF CO-RE 和 vmlinux.h 头文件，从内核的 task_struct 结构体中读取额外的进程信息 运行 显示存活时间至少 50ms 的进程 $ ./bootstrap -d 50TIME EVENT COMM PID PPID FILENAME/EXIT CODE10:38:01 EXIT tail 48249 48247 [0] (133ms)10:38:01 EXIT tail 48327 48325 [0] (52ms)10:38:01 EXIT tail 48365 48363 [0] (52ms)10:38:01 EXIT manpath 48416 48193 [0] (53ms)10:38:38 EXIT ping 48530 48193 [0] (5654ms) 开启 libbpf 的 debug 日志 $ ./bootstrap -v The BPF side头文件#include vmlinux.h#include bpf/bpf_helpers.h#include bpf/bpf_tracing.h#include bpf/bpf_core_read.h#include bootstrap.h vmlinux.h 头文件中包含了 BPF 程序可能需要的、与某个内核相关的所有数据结构信息。它是在 libbpf-bootstrap 项目里预先生成的，开发者也可以自动使用 bpftool 生成，具体可参考 gen_vmlinux_h.sh。 TIPS:只使用 libbpf 提供的 vmlinux.h 头文件就可以，如果同时包含其它内核头文件，会出现重复定义的问题。 Read-only global variableconst volatile unsigned long long min_duration_ns = 0; const volatile 表示该变量不论是在 BPF side，还是在 user-space side，都是只读的。如果不使用 volatile，Clang 就可能假设该变量的值为 0，并将其彻底移除。 BPF mapsBPF_MAP_TYPE_HASHstruct __uint(type, BPF_MAP_TYPE_HASH);\t__uint(max_entries, 8192);\t__type(key, pid_t);\t__type(value, u64); exec_start SEC(.maps); 定义一个名为 exec_start，类型为 BPF_MAP_TYPE_HASH 的哈希表。最大容纳 8192 个元素，key 是 pid_t 类型，value 是 u64 类型，用于存储进程运行事件的纳秒粒度的时间戳。 SEC(“tpschedsched_process_exec”)SEC(tp/sched/sched_process_exec)int handle_exec(struct trace_event_raw_sched_process_exec *ctx) bpf_map_update_elempid_t pid;u64 ts;/* remember time exec() was executed for this PID */pid = bpf_get_current_pid_tgid() 32;ts = bpf_ktime_get_ns();bpf_map_update_elem(exec_start, pid, ts, BPF_ANY); 在哈希表中添加，更新元素。 BPF_ANY: 添加一个新的键（key），或者更新已有的键值对 BPF_NOEXIST：仅当键（key）不存在时才会执行更新操作，以防止覆盖已有的数据。 BPF_EXIST：仅当键（key）已存在时才会执行更新操作，以确保仅对已有键进行更新，而不创建新的键 SEC(“tpschedsched_process_exit”)SEC(tp/sched/sched_process_exit)int handle_exit(struct trace_event_raw_sched_process_template *ctx) bpf_map_lookup_elem在另一个 BPF 程序 (handle_exit) 中，从同一个 BPF map 中查询元素，然后删除它。 start_ts = bpf_map_lookup_elem(exec_start, pid);if (start_ts) duration_ns = bpf_ktime_get_ns() - *start_ts;else if (min_duration_ns) return 0;bpf_map_delete_elem(exec_start, pid); BPF ring bufferBPF_MAP_TYPE_RINGBUFstruct __uint(type, BPF_MAP_TYPE_RINGBUF);\t__uint(max_entries, 256 * 1024); rb SEC(.maps); 定义一个名为 rb，类型为 BPF_MAP_TYPE_RINGBUF 的环形缓冲区。 bpf_ringbuf_reserve/* reserve sample from BPF ringbuf */e = bpf_ringbuf_reserve(rb, sizeof(*e), 0);if (!e) return 0; bpf_ringbuf_reserve 用于在环形缓冲区申请连续的内存块，第一个参数为指向环形缓冲区的指针，第二个参数为要在环形缓冲区中预留的字节数，第三个参数必须为 0。 BPF_CORE_READ/* fill out the sample with data */task = (struct task_struct *)bpf_get_current_task();e-exit_event = false;e-pid = pid;e-ppid = BPF_CORE_READ(task, real_parent, tgid);bpf_get_current_comm(e-comm, sizeof(e-comm)); BPF_CORE_READ 用于简化 BPF CO-RE 可重定位读取操作，尤其适用于指针追踪步骤较少的场景。BPF_CORE_READ(task, real_parent, tgid) 相当于 task-real_parent-tgid。 ctx-__data_loc_filenamefname_off = ctx-__data_loc_filename 0xFFFF;bpf_probe_read_str(e-filename, sizeof(e-filename), (void *)ctx + fname_off); libbpf 访问 tracepoint 上下文字段的格式： __data_loc_some_field。（低 16 位偏移 + 高 16 位长度） 0xFFFF 用于提取低 16 位的偏移量。 参考： Learning eBPF: 7.4.3 Tracepointshttps://gaoyangu.github.io/wiki/ebpf/learning-ebpf-07/#7-4-3-Tracepoints 每个跟踪点（tracepoint）都有一个格式（format），该格式用于描述从该跟踪点中会被跟踪输出的字段： $ cat /sys/kernel/tracing/events/sched/sched_process_exec/formatname: sched_process_execID: 317format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1;signed:0; field:int common_pid; offset:4; size:4; signed:1; field:__data_loc char[] filename; offset:8; size:4; signed:0; field:pid_t pid; offset:12; size:4; signed:1; field:pid_t old_pid; offset:16; size:4; signed:1;print fmt: filename=%s pid=%d old_pid=%d, __get_str(filename), REC-pid, REC-old_pid bpf_ringbuf_submit/* successfully submit it to user-space for post-processing */bpf_ringbuf_submit(e, 0); bpf_ringbuf_submit 会使环形缓冲区中预留的数据变为可读取状态。 0：发送自适应的新数据可用通知 BPF_RB_NO_WAKEUP：不发送新数据可用通知 BPF_RB_FORCE_WAKEUP：无条件发送新数据可用通知 The user-space sideopen load/* Load and verify BPF application */skel = bootstrap_bpf__open();if (!skel) fprintf(stderr, Failed to open and load BPF skeleton ); return 1;/* Parameterize BPF code with minimum duration parameter */skel-rodata-min_duration_ns = env.min_duration_ms * 1000000ULL;/* Load verify BPF programs */err = bootstrap_bpf__load(skel);if (err) fprintf(stderr, Failed to load and verify BPF skeleton ); goto cleanup; 只读全局变量需要在 BPF skeleton 加载到内核之前完成设置，因此需要分 __open 和 __load 两步进行。当 BPF skeleton 完成 __load 之后，不论是在 BPF side，还是在 user-space side 都只能读该变量。 attach/* Attach tracepoints */err = bootstrap_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton ); goto cleanup; ring_buffer__newstruct ring_buffer *rb = NULL;rb = ring_buffer__new(bpf_map__fd(skel-maps.rb), handle_event, NULL, NULL);if (!rb) err = -1; fprintf(stderr, Failed to create ring buffer ); goto cleanup; 环形缓冲区（ring buffer） 指的是一种循环缓冲区，其中 eBPF 程序作为生产者，用户空间（userspace）作为消费者。尽管返回值的数据类型是 struct ring_buffer *，但它实际上是用于管理多个环形缓冲区的管理器。 ring_buffer__poll/* Process events */while (!exiting) err = ring_buffer__poll(rb, 100 /* timeout, ms */); /* Ctrl-C will cause -EINTR */ if (err == -EINTR) err = 0; break; if (err 0) printf(Error polling perf buffer: %d , err); break; 轮询属于环形缓冲区管理器（ring buffer manager）的任一环形缓冲区（ring buffer）上的可用数据。 若存在可用数据，已注册的回调函数（callback functions）将被调用； 若不存在可用数据，该函数会等待 timeout_ms（毫秒）以等待数据到达，并在此期间处于阻塞（block）状态。 clean_upcleanup: /* Clean up */ ring_buffer__free(rb); bootstrap_bpf__destroy(skel); todousing argp API (part of libc) for command-line argument parsing"},{"title":"bootstrap_legacy","path":"/wiki/ebpf/libbpf-bootstrap-05.html","content":"描述:BPF_MAP_TYPE_PERF_EVENT_ARRAY 的使用方式。 bootstrap_legacy 会将环形缓冲区映射（ring buffer maps）替换为性能事件数组（perf event array，对应 BPF 映射类型 BPF_MAP_TYPE_PERF_EVENT_ARRAY），以实现与旧版内核的兼容性。 运行$ ./bootstrap_legacyTIME EVENT COMM PID PPID FILENAME/EXIT CODE17:26:53 EXEC sh 24694 22237 /bin/sh17:26:53 EXEC grep 24696 24694 /usr/bin/grep17:26:53 EXEC ls 24695 24694 /usr/bin/ls17:26:53 EXIT ls 24695 24694 [2] (5ms)17:26:53 EXIT grep 24696 24694 [0] (6ms)17:26:53 EXIT sh 24694 22237 [0] (8ms) The BPF sideBPF mapsBPF_MAP_TYPE_PERF_EVENT_ARRAYstruct __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\t__uint(key_size, sizeof(u32));\t__uint(value_size, sizeof(u32)); perf_buffer SEC(.maps); SEC(“tpschedsched_process_exec”)SEC(tp/sched/sched_process_exec)int handle_exec(struct trace_event_raw_sched_process_exec *ctx) SEC(“tpschedsched_process_exit”)SEC(tp/sched/sched_process_exit)int handle_exit(struct trace_event_raw_sched_process_template *ctx) bpf_perf_event_output/* use perf event output to send data to user-space for post-processing */bpf_perf_event_output(ctx, perf_buffer, BPF_F_CURRENT_CPU, e, sizeof(e)); eBPF map 的数据存入索引，有两种索引指定方式： 手动指定索引并经掩码处理：BPF_F_INDEX_MASK 是 “索引掩码”，用于过滤 修正传入的映射索引值 自动使用当前 CPU 核心索引：BPF_F_CURRENT_CPU 表示 “当前 CPU”，是便捷定位当前运行 CPU 核心索引的预设标志 每个性能事件（perf event）都创建于特定的 CPU 之上。此辅助函数（helper）仅能写入与 eBPF 程序运行在同一 CPU 上的性能事件；若手动指定的索引对应的性能事件位于其他 CPU，运行时会返回 -EOPNOTSUPP 错误。 因此，除非有充分的合理理由，否则建议使用 BPF_F_CURRENT_CPU 标志，并以 “CPU 索引与映射（map）索引保持一致” 的方式填充 BPF_MAP_TYPE_PERF_EVENT_ARRAY 类型的映射。 The user-space sideperf_buffer__new/* Set up perf buffer polling */perf_buffer = perf_buffer__new(bpf_map__fd(skel-maps.perf_buffer), 8, handle_event, NULL, NULL, NULL);if (!perf_buffer) err = -1; fprintf(stderr, Failed to create perf event buffer ); goto cleanup; 8 表示的是 number of memory pages，每个 page 是 4KB，因此总大小： 8 pages x 4096 bytepage 32KB。即设置 per-CPU buffer 为 32KB。 perf_buffer__pollwhile (!exiting) err = perf_buffer__poll(perf_buffer, 100 /* timeout, ms */); /* Ctrl-C will cause -EINTR */ if (err == -EINTR) err = 0; break; if (err 0) printf(Error polling perf buffer: %d , err); break; clean_upcleanup:\t/* Clean up */\tperf_buffer__free(perf_buffer);\tbootstrap_legacy_bpf__destroy(skel);"},{"title":"uprobe","path":"/wiki/ebpf/libbpf-bootstrap-06.html","content":"uprobe 是处理用户态入口探测与退出探测的示例，对应的两种探测类型分别是 uprobe（用户态入口探测）和 uretprobe（用户态返回探测）。 它会将 uprobe 和 uretprobe 类型的 BPF 程序，分别挂载到自身的函数（uprobed_add() 和 uprobed_sub()）上，并通过 bpf_printk() 宏，分别记录这些函数的输入参数与返回结果。用户态函数每秒会触发一次。 运行./uprobelibbpf: loading object uprobe_bpf from buffer... $ cat /sys/kernel/debug/tracing/trace_pipe uprobe-16616 [001] ...11 349920.493709: bpf_trace_printk: uprobed_add ENTRY: a = 22, b = 23 uprobe-16616 [001] ...11 349920.493797: bpf_trace_printk: uprobed_add EXIT: return = 45 uprobe-16616 [001] ...11 349920.493818: bpf_trace_printk: uprobed_sub ENTRY: a = 484, b = 22 uprobe-16616 [001] ...11 349920.493824: bpf_trace_printk: uprobed_sub EXIT: return = 462 addNOTE:仅声明探针类型，需要在加载时绑定目标 The BPF side 探针本身不绑定任何目标程序函数，灵活性高（可复用探针跟踪不同程序）。 SEC(“uprobe”)SEC(uprobe)int BPF_KPROBE(uprobe_add, int a, int b)\tbpf_printk(uprobed_add ENTRY: a = %d, b = %d, a, b);\treturn 0; BPF_KPROBE 是一个宏。在编写挂载在函数起始处的 kprobe（内核探针）程序时使用。 uprobe_add 是函数名，int a, int b 为函数的参数。 SEC(“uretprobe”)SEC(uretprobe)int BPF_KRETPROBE(uretprobe_add, int ret)\tbpf_printk(uprobed_add EXIT: return = %d, ret);\treturn 0; BPF_KRETPROBE 是一个宏。在编写挂载在函数返回的 kprobe（内核探针）程序时使用。 The user-space sideuprobed_add__attribute__((noinline)) 和 asm volatile (); 都是为了防止编译器将函数内联(inline)。 __attribute__((noinline)) int uprobed_add(int a, int b)\tasm volatile ();\treturn a + b; LIBBPF_OPTSLIBBPF_OPTS(bpf_uprobe_opts, uprobe_opts); 使用 LIBBPF_OPTS 声明一个类型是 bpf_uprobe_opts，变量名为 uprobe_opts 的结构体。 struct bpf_uprobe_opts /* size of this struct, for forward/backward compatibility */ size_t sz; size_t ref_ctr_offset; __u64 bpf_cookie; bool retprobe; const char *func_name; enum probe_attach_mode attach_mode; size_t :0;; bpf_program__attach_uprobe_opts/* Attach tracepoint handler */uprobe_opts.func_name = uprobed_add;uprobe_opts.retprobe = false;/* uprobe/uretprobe expects relative offset of the function to attach* to. libbpf will automatically find the offset for us if we provide the* function name. If the function name is not specified, libbpf will try* to use the function offset instead.*/skel-links.uprobe_add = bpf_program__attach_uprobe_opts(skel-progs.uprobe_add, 0 /* self pid */, /proc/self/exe, 0 /* offset for function */, uprobe_opts /* opts */);if (!skel-links.uprobe_add) err = -errno; fprintf(stderr, Failed to attach uprobe: %d , err); goto cleanup; skel-progs.uprobe_add：要附加的 BPF 程序。此处为 uprobe.bpf.c 中定义的 uprobe_add 函数。 0 /* self pid */：附加 uprobe 的进程 ID。 0 表示当前进程，-1 表示所有进程。 /proc/self/exe：包含函数符号的二进制文件的路径。 0 /* offset for function */：函数符号在二进制文件中的 offset。 uprobe_opts /* opts */：options。 subNOTE:显式绑定目标程序和函数 The BPF sideSEC(“uprobeprocselfexe:uprobed_sub”)SEC(uprobe//proc/self/exe:uprobed_sub)int BPF_KPROBE(uprobe_sub, int a, int b)\tbpf_printk(uprobed_sub ENTRY: a = %d, b = %d, a, b);\treturn 0; uprobe/ 后紧跟着目标程序绝对路径，/proc/self/exe 表示绑定当前进程。再用 : 后加函数名 uprobed_sub。 无需加载时指定额外目标，探针直接绑定到指定程序的指定函数。 支持跟踪系统库函数，自定义程序函数 SEC(“uretprobeprocselfexe:uprobed_sub”)SEC(uretprobe//proc/self/exe:uprobed_sub)int BPF_KRETPROBE(uretprobe_sub, int ret)\tbpf_printk(uprobed_sub EXIT: return = %d, ret);\treturn 0; The user-space sideuprobed_sub__attribute__((noinline)) int uprobed_sub(int a, int b)\tasm volatile ();\treturn a - b; uprobe_bpf__attach由于已经在 SEC 中提供了目标程序的绝对路径和函数名，uprobe_sub/uretprobe_sub 只需 attach 即可。 /* Let libbpf perform auto-attach for uprobe_sub/uretprobe_sub * NOTICE: we provide path and symbol info in SEC for BPF programs */err = uprobe_bpf__attach(skel);if (err) fprintf(stderr, Failed to auto-attach BPF skeleton: %d , err); goto cleanup; call funcfor (i = 0;; i++) /* trigger our BPF programs */ fprintf(stderr, .); uprobed_add(i, i + 1); uprobed_sub(i * i, i); sleep(1); cleanupcleanup:\tuprobe_bpf__destroy(skel);"},{"title":"usdt","path":"/wiki/ebpf/libbpf-bootstrap-07.html","content":"usdt 是使用 USDT 探针的一个示例。它会将 USDT 类型的 BPF 程序挂载到 libc:setjmp 探针上，该探针会在用户态程序调用 setjmp 函数时被触发（每秒触发一次），并通过 bpf_printk() 宏记录 USDT 探针的参数。 USDT (user statically defined tracepoint，用户态静态定义跟踪点) 用于挂载应用程序代码或用户态库中指定的跟踪点。 setjmp() 是 C 标准库 setjmp.h 中的一个宏，用于保存当前的程序执行状态，以便在稍后的某个时候通过 longjmp() 来返回到该状态。 运行$ ./usdtlibbpf: loading object usdt_bpf from buffer... $ cat /sys/kernel/debug/tracing/trace_pipeusdt-25683 [006] ...11 2624.434591: bpf_trace_printk: USDT manual attach to libc:setjmp: arg1 = 55d480464080, arg2 = 0, arg3 = 55d48041549dusdt-25683 [006] ...11 2625.434730: bpf_trace_printk: USDT manual attach to libc:setjmp: arg1 = 55d480464080, arg2 = 0, arg3 = 55d48041549d autoThe BPF sideusdt.bpf.h#include vmlinux.h#include bpf/bpf_helpers.h#include bpf/bpf_tracing.h#include bpf/usdt.bpf.h usdt.bpf.h 定义了一组用于处理用户空间静态跟踪点（USDT）的宏和函数。 SEC(“usdtlibc.so.6:libc:setjmp”)SEC(usdt/libc.so.6:libc:setjmp)int BPF_USDT(usdt_auto_attach, void *arg1, int arg2, void *arg3)\tpid_t pid = bpf_get_current_pid_tgid() 32;\tif (pid != my_pid) return 0;\tbpf_printk(USDT auto attach to libc:setjmp: arg1 = %lx, arg2 = %d, arg3 = %lx, arg1, arg2, arg3);\treturn 0; BPF_USDTBPF_USDT 与 BPF_PROG 类似，但是专用于 USDT 探针。 USDT 程序本质上是一种用户态入口探测（uprobe），其设计用途是挂载到 USDT 跟踪点上。这类跟踪点能够传递参数，但与遵循 ABI（应用程序二进制接口）的函数参数不同，跟踪点的参数可存在于进程内的任意位置。跟踪点会使用 GAS（GNU 汇编器）操作数来描述这些参数，而该宏则允许你将程序中的这些参数定义为 “如同普通参数一样实际传递给程序” 的形式。 args如何确认函数参数的数量和类型？比如此处的 void *arg1, int arg2, void *arg3。 要跟踪的 setjmp 是 libc 里的函数，因此在指定的 libc.so.6 里列出所有 USDT探针，确认是否存在 setjump 相关的探针。 $ bpftrace -l usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:* | grep setjmpusdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:setjmp 读取 libc.so.6 文件中的 NOTE 段内容，NOTE 段通常包含调试信息、静态探针描述等元数据。 $ readelf --notes /usr/lib/x86_64-linux-gnu/libc.so.6 | grep -A10 setjmp Name: setjmp Location: 0x0000000000044f15, Base: 0x00000000001d6720, Semaphore: 0x0000000000000000 Arguments: 8@%rdi -4@%esi 8@%rax stapsdt 0x0000003b NT_STAPSDT (SystemTap probe descriptors) Provider: libc Name: longjmp Location: 0x00000000000450f3, Base: 0x00000000001d6720, Semaphore: 0x0000000000000000 Arguments: 8@%rdi -4@%esi 8@%rdx stapsdt 0x00000042 NT_STAPSDT (SystemTap probe descriptors) Provider: libc Name: longjmp_target 其中： Provider 标识程序名 Name 标识探测点的名称 Location 记录了探测点的位置（在程序中的地址偏移） Arguments 为探针的参数列表（格式为大小@寄存器或内存位置）。 参数列表中： 8@%rdi：第一个参数占 8 字节，位于 %rdi 寄存器； 指向 jmp_buf 上下文缓冲区的指针 -4@%esi：第二个参数占 4 字节，位于 %esi 寄存器； -4 表示 “取 % esi 寄存器的低 4 字节”； libc 的 setjmp 本质是 sigsetjmp(env, 0) 的封装（默认不保存信号掩码），% esi 是第二个参数 savesigs，表示是否保存信号掩码（0 不保存，非 0 保存） 8@%rax：第三个参数占 8 字节，位于 %rax 寄存器。 libc 内部的 jmp_buf 扩展数据指针（指向 jmp_buf 关联的辅助信息）。 The user-space sideusdt_bpf__openstruct usdt_bpf *skel;skel = usdt_bpf__open();if (!skel) fprintf(stderr, Failed to open BPF skeleton ); return 1; usdt_bpf__loadskel-bss-my_pid = getpid();err = usdt_bpf__load(skel);if (!skel) fprintf(stderr, Failed to load BPF skeleton ); return 1; usdt_bpf__attacherr = usdt_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton ); goto cleanup; tiggerstatic jmp_buf env;static void usdt_trigger()\tsetjmp(env); while (!exiting) /* trigger our BPF programs */ usdt_trigger(); fprintf(stderr, .); sleep(1); cleanupcleanup:\tusdt_bpf__destroy(skel); manualThe BPF sideSEC(“usdt”)SEC(usdt)int BPF_USDT(usdt_manual_attach, void *arg1, int arg2, void *arg3)\tbpf_printk(USDT manual attach to libc:setjmp: arg1 = %lx, arg2 = %d, arg3 = %lx, arg1, arg2, arg3);\treturn 0; The user-space sidebpf_program__attach_usdt与 bpf_program__attach_uprobe_opts 的作用类似，用于 USDT（用户态静态定义跟踪点）的挂载，而非挂载到用户态函数的入口或出口。 /** Manually attach to libc.so we find.* We specify pid here, so we dont have to do pid filtering in BPF program.*/skel-links.usdt_manual_attach = bpf_program__attach_usdt( skel-progs.usdt_manual_attach, getpid(), libc.so.6, libc, setjmp, NULL);if (!skel-links.usdt_manual_attach) err = errno; fprintf(stderr, Failed to attach BPF program `usdt_manual_attach` ); goto cleanup; skel-progs.usdt_manual_attach：要附加的 BPF 程序。此处为 usdt.bpf.c 中定义的 usdt_manual_attach 函数。 getpid()：附加 uprobe 的进程 ID。 0 表示当前进程，-1 表示所有进程。 libc.so.6：包含指定 USDT 探针（用户态静态定义跟踪点探针）的二进制文件路径。 libc：USDT 探针的提供者名称。 setjmp：USDT 探针的名称。 NULL: 修改程序挂载的可选配置。"},{"title":"fentry","path":"/wiki/ebpf/libbpf-bootstrap-08.html","content":"fentry 示例使用 fentry 和 fexit 类型的 BPF 程序进行跟踪。它会将 fentry 和 fexit 跟踪器附加到 do_unlinkat() 函数上，此函数会在文件被删除时被调用，并且会将函数的返回值、进程标识符（PID）以及文件名记录到跟踪管道（trace pipe）中。 与 kprobes 相比，增强了性能和可用性 能够像 c 语言一样直接解引用指针 fexit 不仅可以访问入参，还可以访问返回值；而 kretprobe 只能访问返回值 NOTE:内核版本 5.5 开始支持 fentry 和 fexit 运行$ ./fentry libbpf: loading object fentry_bpf from buffer... $ cat /sys/kernel/debug/tracing/trace_pipe ...-45337 [004] ...11 107881.547637: bpf_trace_printk: fentry: pid = 45337, filename = test_file ...-45337 [004] ...11 107881.547704: bpf_trace_printk: fexit: pid = 45337, filename = test_file, ret = 0 $ cd ~$ touch test_file$ rm -rf test_file The BPF sideSEC(“fentrydo_unlinkat”)SEC(fentry/do_unlinkat)int BPF_PROG(do_unlinkat, int dfd, struct filename *name)\tpid_t pid;\tpid = bpf_get_current_pid_tgid() 32;\tbpf_printk(fentry: pid = %d, filename = %s , pid, name-name);\treturn 0; BPF_PROG(do_unlinkat, int dfd, struct filename *name)BPF 程序的函数签名为 do_unlinkat，输入参数为 dfd 和 name。 args函数的入参 int dfd, struct filename *name 是如何确定的? do_unlinkat 是内核函数，查询Linux 源码可获知该函数具有 dfd 与 name 两个输入参数、返回值为一个 int 类型的值。 SEC(“fexitdo_unlinkat”)SEC(fexit/do_unlinkat)int BPF_PROG(do_unlinkat_exit, int dfd, struct filename *name, long ret)\tpid_t pid;\tpid = bpf_get_current_pid_tgid() 32;\tbpf_printk(fexit: pid = %d, filename = %s, ret = %ld , pid, name-name, ret);\treturn 0; The user-space sideopen_and_load/* Open load and verify BPF application */skel = fentry_bpf__open_and_load();if (!skel) fprintf(stderr, Failed to open BPF skeleton ); return 1; attach/* Attach tracepoint handler */err = fentry_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton ); goto cleanup; whilewhile (!stop) fprintf(stderr, .); sleep(1); cleanupcleanup:\tfentry_bpf__destroy(skel);"},{"title":"kprobe","path":"/wiki/ebpf/libbpf-bootstrap-09.html","content":"kprobe 是一个处理内核空间入口探针（kprobe）和出口（返回）探针（kretprobe）的示例。它会将 kprobe 和 kretprobe 类型的 BPF 程序分别附加到 do_unlinkat() 函数上，并使用 bpf_printk() 记录进程标识符（PID）、文件名以及返回结果。 运行$ ./kprobe libbpf: loading object kprobe_bpf from buffer... $ cat /sys/kernel/debug/tracing/trace_pipe ...-47878 [001] ...21 108736.735085: bpf_trace_printk: KPROBE ENTRY pid = 47878, filename = test_file ...-47878 [001] ...21 108736.735174: bpf_trace_printk: KPROBE EXIT: pid = 47878, ret = 0 $ cd ~$ touch test_file$ rm -rf test_file The BPF sideSEC(“kprobedo_unlinkat”)SEC(kprobe/do_unlinkat)int BPF_KPROBE(do_unlinkat, int dfd, struct filename *name)\tpid_t pid;\tconst char *filename;\tpid = bpf_get_current_pid_tgid() 32;\tfilename = BPF_CORE_READ(name, name);\tbpf_printk(KPROBE ENTRY pid = %d, filename = %s , pid, filename);\treturn 0; 可以看到，与 fentry 相比，此处需要使用 BPF_CORE_READ(name, name) 获取 filename。 传统的五子棋传统的 kprobe/kretprobe 方式，是通过动态符号表（kallsyms）找到函数地址，在入口或返回处插入探针，但只能通过 pt_regs 提供的寄存器信息来获取参数，需要程序员手动解析，并且难以保证类型安全。因此在代码中只能用函数 bpf_probe_read_kernel() 对参数进行安全读取，代码中使用的 BPF_CORE_READ() 宏即是对该函数的封装。 技能五子棋fentry 和 fexit，它们可以在函数的入口和出口处精准 attach，并且不需要手动解析寄存器或做复杂的偏移计算，内核在运行时会直接把真实的参数和返回值传递给 eBPF 程序。 SEC(“kretprobedo_unlinkat”)SEC(kretprobe/do_unlinkat)int BPF_KRETPROBE(do_unlinkat_exit, long ret)\tpid_t pid;\tpid = bpf_get_current_pid_tgid() 32;\tbpf_printk(KPROBE EXIT: pid = %d, ret = %ld , pid, ret);\treturn 0; 可以看到，与fexit 相比，kretprobe 只能访问返回值。 The user-space side用户态程序与 fentry 几乎相同。 open_and_load/* Open load and verify BPF application */skel = kprobe_bpf__open_and_load();if (!skel) fprintf(stderr, Failed to open BPF skeleton ); return 1; attach/* Attach tracepoint handler */err = kprobe_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton ); goto cleanup; whilewhile (!stop) fprintf(stderr, .); sleep(1); cleanupcleanup:\tkprobe_bpf__destroy(skel);"},{"title":"xdp","path":"/wiki/ebpf/libbpf-bootstrap-10.html","content":"xdp 是一个用 Rust 语言（基于 libbpf-rs 库）编写的示例。它会附加到网络设备的入站路径上，记录每个数据包的大小，并返回 XDP_PASS 以允许数据包向上传递到内核的网络协议栈。 前置知识08. eBPF for Networkinghttps://gaoyangu.github.io/wiki/ebpf/learning-ebpf-08/ 运行本文将该代码移植为 C 语言版本。 在 example/c 文件夹下，新建 eBPF 程序 xdppass.bpf.c，用户态程序 xdppass.c。同时需要在 Makefile 文件中添加该 XDP 程序 xdppass。 $ ip link show1: lo: LOOPBACK,UP,LOWER_UP mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: eth0: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether 00:01:02:03:04:05 brd ff:ff:ff:ff:ff:ff NOTE:Linux 不允许同一网卡同时附着多个 XDP 程序，会返回 -EBUSY 忙错误。可使用 bpftool net detach xdp dev eth0 命令将附着在 eth0 的程序 detach。 ./xdppass 1 $ cat /sys/kernel/debug/tracing/trace_pipe\tnode-50447 [003] ..s21 188234.264490: bpf_trace_printk: packet size: 81\tnode-50447 [003] ..s21 188234.264556: bpf_trace_printk: packet size: 66\tnode-50153 [007] ..s21 188236.582558: bpf_trace_printk: packet size: 85 The BPF sidexdppass.bpf.c#include vmlinux.h#include bpf/bpf_helpers.hSEC(xdp)int xdp_pass(struct xdp_md *ctx)\tvoid *data = (void *)(long)ctx-data;\tvoid *data_end = (void *)(long)ctx-data_end;\tint pkt_sz = data_end - data;\tbpf_printk(packet size: %d, pkt_sz);\treturn XDP_PASS;char __license[] SEC(license) = GPL; The user-space sidexdppass.c用户态程序参考之前的示例代码和 xdppass.c 实现。 #include stdio.h#include unistd.h#include errno.h#include signal.h#include sys/resource.h#include bpf/libbpf.h#include xdppass.skel.hstatic int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)\treturn vfprintf(stderr, format, args);static volatile sig_atomic_t stop;static void sig_int(int signo)\tstop = 1;int main(int argc, char ** argv) struct xdppass_bpf *skel = NULL; int err; int ifindex = 0; /* Set up libbpf errors and debug info callback */\tlibbpf_set_print(libbpf_print_fn); if(argc 1) ifindex = atoi(argv[1]); /* Open load and verify BPF application */ skel = xdppass_bpf__open_and_load(); if (!skel) fprintf(stderr, Failed to open BPF skeleton ); return 1; skel-links.xdp_pass = bpf_program__attach_xdp(skel-progs.xdp_pass, ifindex); if (!skel-links.xdp_pass) err = -errno; fprintf(stderr, Failed to attach XDP program to ifindex %d , ifindex); goto cleanup; err = xdppass_bpf__attach(skel);\tif (err) fprintf(stderr, Failed to auto-attach BPF skeleton: %d , err); goto cleanup; if (signal(SIGINT, sig_int) == SIG_ERR) fprintf(stderr, cant set signal handler: %s , strerror(errno)); goto cleanup; printf(Successfully started! Please run `sudo cat /sys/kernel/debug/tracing/trace_pipe` to see output of the BPF programs. ); while (!stop) fprintf(stderr, .); sleep(1);\tcleanup: xdppass_bpf__destroy(skel); return -err; other觅梦随笔: eBPF例程——XDP 这篇博文中还实现了几个进阶示例： 数据包解析以太网头 数据包重定向至其他端口 数据包重定向至用户态"},{"title":"tc","path":"/wiki/ebpf/libbpf-bootstrap-11.html","content":"tc（Traffic Control，流量控制）是一个处理入站网络流量的示例。它会在 lo 接口（回环接口）上创建一个队列规则（qdisc），并将 tc_ingress 类型的 BPF 程序附加到该规则上，最终上报进入 lo 接口的 IP 数据包的元数据。 前置知识8.4 Traic Control (TC)https://gaoyangu.github.io/wiki/ebpf/learning-ebpf-08/#8-4-Traic-Control-TC 运行$ ./tclibbpf: loading object tc_bpf from buffer... $ cat /sys/kernel/debug/tracing/trace_pipe node-31445 [006] ..s2. 264002.057570: bpf_trace_printk: Got IP packet: tot_len: 461, ttl: 64 node-31425 [002] ..s2. 264002.059394: bpf_trace_printk: Got IP packet: tot_len: 143, ttl: 64 node-31425 [002] ..s2. 264002.059497: bpf_trace_printk: Got IP packet: tot_len: 52, ttl: 64 The BPF sideSEC(“tc”)#include vmlinux.h#include bpf/bpf_endian.h#include bpf/bpf_helpers.h#include bpf/bpf_tracing.h#define TC_ACT_OK 0#define ETH_P_IP 0x0800 /* Internet Protocol packet\t*/SEC(tc)int tc_ingress(struct __sk_buff *ctx)\tvoid *data_end = (void *)(__u64)ctx-data_end;\tvoid *data = (void *)(__u64)ctx-data;\tstruct ethhdr *l2;\tstruct iphdr *l3;\tif (ctx-protocol != bpf_htons(ETH_P_IP)) return TC_ACT_OK;\tl2 = data;\tif ((void *)(l2 + 1) data_end) return TC_ACT_OK;\tl3 = (struct iphdr *)(l2 + 1);\tif ((void *)(l3 + 1) data_end) return TC_ACT_OK;\tbpf_printk(Got IP packet: tot_len: %d, ttl: %d, bpf_ntohs(l3-tot_len), l3-ttl);\treturn TC_ACT_OK;char __license[] SEC(license) = GPL; l2 + 1l2 是 struct ethhdr * 类型的指针（指向以太网头起始地址），在 C 语言中：结构体指针 +1，偏移的字节数 该结构体的总大小（而非 1 个字节）。 l2 + 1 等价于 data + sizeof(struct ethhdr)，即指向以太网头末尾的下一个字节（也就是 IP 头的起始位置）。l2 + 1 更直观、无需手动计算 sizeof，不易出错。 The user-space sideLO_IFINDEX 环回设备的接口索引，可通过 ip link show 命令查看 #define LO_IFINDEX 1 bpf_tc_hook 定义类型为 bpf_tc_hook ，变量名为 tc_hook 的结构体变量。 struct bpf_tc_hook size_t sz; int ifindex; enum bpf_tc_attach_point attach_point; __u32 parent; size_t :0;;enum bpf_tc_attach_point BPF_TC_INGRESS = 1 0, BPF_TC_EGRESS = 1 1, BPF_TC_CUSTOM = 1 2,; DECLARE_LIBBPF_OPTS(bpf_tc_hook, tc_hook, .ifindex = LO_IFINDEX, .attach_point = BPF_TC_INGRESS); bpf_tc_opts 定义类型为 bpf_tc_opts ，变量名为 tc_opts 的结构体变量。 struct bpf_tc_opts size_t sz; int prog_fd; __u32 flags; __u32 prog_id; __u32 handle; __u32 priority; size_t :0;; DECLARE_LIBBPF_OPTS(bpf_tc_opts, tc_opts, .handle = 1, .priority = 1); prog_fd: 要附加的 BPF 程序的文件描述符。 handle: TC 分类器的句柄。 priority: TC 分类器的优先级。取值范围 [0 - 65535]。 open_and_loadbool hook_created = false;struct tc_bpf *skel;int err;skel = tc_bpf__open_and_load();if (!skel) fprintf(stderr, Failed to open BPF skeleton ); return 1; bpf_tc_hook_create 📌 创建TC钩子，即创建 qdisc /* The hook (i.e. qdisc) may already exists because: * 1. it is created by other processes or users * 2. or since we are attaching to the TC ingress ONLY, * bpf_tc_hook_destroy does NOT really remove the qdisc, * there may be an egress filter on the qdisc */err = bpf_tc_hook_create(tc_hook);if (!err) hook_created = true;if (err err != -EEXIST) fprintf(stderr, Failed to create TC hook: %d , err); goto cleanup; bpf_program__fdtc_opts.prog_fd = bpf_program__fd(skel-progs.tc_ingress); bpf_tc_attach 📌err = bpf_tc_attach(tc_hook, tc_opts);if (err) fprintf(stderr, Failed to attach TC: %d , err); goto cleanup; whilewhile (!exiting) fprintf(stderr, .); sleep(1); bpf_tc_detach 📌 将 eBPF 程序从 TC 钩子上卸载 tc_opts.flags = tc_opts.prog_fd = tc_opts.prog_id = 0;err = bpf_tc_detach(tc_hook, tc_opts);if (err) fprintf(stderr, Failed to detach TC: %d , err); goto cleanup; cleanup 清除之前创建的 TC 钩子 cleanup:\tif (hook_created) bpf_tc_hook_destroy(tc_hook);\ttc_bpf__destroy(skel);"},{"title":"profile (todo)","path":"/wiki/ebpf/libbpf-bootstrap-12.html","content":"profile is an example written in Rust and C using the blazesym symbolization library. It attaches to perf events, sampling on every processor periodically. It shows addresses, symbols, file names, and line numbers of stacktraces (if available)."},{"title":"sockfilter","path":"/wiki/ebpf/libbpf-bootstrap-13.html","content":"sockfilter 是一个用于监控数据包并处理 __sk_buff 结构体的示例。 它会将套接字类型的 BPF 程序附加到 sock_queue_rcv_skb() 函数上，从 BPF_MAP_TYPE_RINGBUF 类型的映射中获取信息，然后在标准输出中打印协议类型、源 IP 地址、源端口、目的 IP 地址和目的端口。 目前，该示例已涵盖了 uapi/linux/in.h 头文件中定义的大部分 IPv4 协议，若需查看支持的协议列表，可参考示例代码 examples/c/sockfilter.c 中的 ipproto_mapping 映射表。 前置知识 socket ringbuf 运行$ ./sockfilterinterface: lo protocol: TCP 127.0.0.1:60196(src) - 127.0.0.1:40705(dst)interface: lo protocol: TCP 127.0.0.1:40705(src) - 127.0.0.1:60196(dst) 或者： $ ./sockfilter -i lointerface: lo protocol: TCP 127.0.0.1:60196(src) - 127.0.0.1:40705(dst)interface: lo protocol: TCP 127.0.0.1:40705(src) - 127.0.0.1:60196(dst) struct so_event该结构体在 BPF 程序和用户态程序中都可以使用。 struct so_event __be32 src_addr;\t__be32 dst_addr;\tunion __be32 ports; __be16 port16[2];\t;\t__u32 ip_proto;\t__u32 pkt_type;\t__u32 ifindex;; __be32 be： 大端序 32：32位 相对应的，__le32 表示小端序 32 位整数。 The BPF side头文件#include sockfilter.h#define IP_MF 0x2000#define IP_OFFSET 0x1FFF BPF_MAP_TYPE_RINGBUF定义 BPF_MAP_TYPE_RINGBUF 类型的 BPF map，用于将内核收集到的事件信息传送给用户态程序 struct __uint(type, BPF_MAP_TYPE_RINGBUF);\t__uint(max_entries, 256 * 1024); rb SEC(.maps); ip_is_fragment inline 判断是否为 IP 分片包 static inline int ip_is_fragment(struct __sk_buff *skb, __u32 nhoff)\t__u16 frag_off;\tbpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, frag_off), frag_off, 2);\tfrag_off = __bpf_ntohs(frag_off);\treturn frag_off (IP_MF | IP_OFFSET); bpf_skb_load_bytes Helper function bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, frag_off), frag_off, 2); 该辅助函数提供了一种简便的方式从数据报中加载数据。它可用于从 skb 关联的数据包中，将偏移量 nhoff + offsetof(struct iphdr, frag_off) 处开始的 2 字节数据，加载到 frag_off 所指向的缓冲区中。 自 Linux 4.7 版本开始，该辅助函数的使用场景已基本被 direct packet access 替代，通过 skb-data 和 skb-data_end 即可操作数据包数据。不过，若需要一次性从数据包中读取大量数据到 eBPF 栈中，该辅助函数仍有实用价值。 __bpf_ntohs结合查到的资料，__bpf_ntohs 仅出现在 Linux 内核源码中 BPF 子系统的实现里，是 BPF 字节序转换的底层内部实现。bpf_ntohs 是封装后的公开稳定 API，更推荐使用这个。 SEC(“socket”) 附加该 eBPF 程序到 socket 收到数据包之前 SEC(socket)int socket_handler(struct __sk_buff *skb) struct so_event *e; __u8 verlen; __u16 proto; __u32 nhoff = ETH_HLEN; bpf_skb_load_bytes(skb, 12, proto, 2); proto = bpf_ntohs(proto); if (proto != ETH_P_IP) return 0; if (ip_is_fragment(skb, nhoff)) return 0; bpf_ringbuf_reserve/* reserve sample from BPF ringbuf */e = bpf_ringbuf_reserve(rb, sizeof(*e), 0);if (!e) return 0; bpf_ringbuf_submitbpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, protocol), e-ip_proto, 1);if (e-ip_proto != IPPROTO_GRE) bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, saddr), (e-src_addr), 4); bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, daddr), (e-dst_addr), 4);bpf_skb_load_bytes(skb, nhoff + 0, verlen, 1);bpf_skb_load_bytes(skb, nhoff + ((verlen 0xF) 2), (e-ports), 4);e-pkt_type = skb-pkt_type;e-ifindex = skb-ifindex;bpf_ringbuf_submit(e, 0); return 允许该数据包继续传递到socket， 返回值的意义是截取数据包的前多少字节传递到socket return skb-len; The user-space sideenv 要监听的端口 static struct env const char *interface; env; ipproto_mapping 协议格式与协议名的映射表， 来源可参考 static const char *ipproto_mapping[IPPROTO_MAX] = [IPPROTO_IP] = IP, [IPPROTO_ICMP] = ICMP, [IPPROTO_IGMP] = IGMP,\t[IPPROTO_IPIP] = IPIP, [IPPROTO_TCP] = TCP, [IPPROTO_EGP] = EGP,\t[IPPROTO_PUP] = PUP, [IPPROTO_UDP] = UDP, [IPPROTO_IDP] = IDP,\t[IPPROTO_TP] = TP, [IPPROTO_DCCP] = DCCP, [IPPROTO_IPV6] = IPV6,\t[IPPROTO_RSVP] = RSVP, [IPPROTO_GRE] = GRE, [IPPROTO_ESP] = ESP,\t[IPPROTO_AH] = AH, [IPPROTO_MTP] = MTP, [IPPROTO_BEETPH] = BEETPH,\t[IPPROTO_ENCAP] = ENCAP, [IPPROTO_PIM] = PIM, [IPPROTO_COMP] = COMP,\t[IPPROTO_SCTP] = SCTP, [IPPROTO_UDPLITE] = UDPLITE, [IPPROTO_MPLS] = MPLS,\t[IPPROTO_RAW] = RAW; open_raw_sockstatic int open_raw_sock(const char *name)\tstruct sockaddr_ll sll;\tint sock;\tsock = socket(PF_PACKET, SOCK_RAW | SOCK_NONBLOCK | SOCK_CLOEXEC, htons(ETH_P_ALL));\tif (sock 0) fprintf(stderr, Failed to create raw socket ); return -1; memset(sll, 0, sizeof(sll));\tsll.sll_family = AF_PACKET;\tsll.sll_ifindex = if_nametoindex(name);\tsll.sll_protocol = htons(ETH_P_ALL);\tif (bind(sock, (struct sockaddr *)sll, sizeof(sll)) 0) fprintf(stderr, Failed to bind to %s: %s , name, strerror(errno)); close(sock); return -1; return sock; sockaddr_llsockaddr_ll 是 Linux 系统特有的套接字地址结构体，隶属于 AF_PACKET 地址族，专门用于描述数据链路层（二层） 的地址和帧属性，是用户空间程序直接操作链路层数据包（如以太网帧）的核心接口。 handle_eventstatic inline void ltoa(uint32_t addr, char *dst)\tsnprintf(dst, 16, %u.%u.%u.%u, (addr 24) 0xFF, (addr 16) 0xFF, (addr 8) 0xFF, (addr 0xFF));static int handle_event(void *ctx, void *data, size_t data_sz)\tconst struct so_event *e = data;\tchar ifname[IF_NAMESIZE];\tchar sstr[16] = , dstr[16] = ;\tif (e-pkt_type != PACKET_HOST) return 0;\tif (e-ip_proto 0 || e-ip_proto = IPPROTO_MAX) return 0;\tif (!if_indextoname(e-ifindex, ifname)) return 0;\tltoa(ntohl(e-src_addr), sstr);\tltoa(ntohl(e-dst_addr), dstr);\tprintf(interface: %s\\tprotocol: %s\\t%s:%d(src) - %s:%d(dst) , ifname, ipproto_mapping[e-ip_proto], sstr, ntohs(e-port16[0]), dstr, ntohs(e-port16[1]));\treturn 0; open_and_loadstruct ring_buffer *rb = NULL;struct sockfilter_bpf *skel;int err, prog_fd, sock;env.interface = lo;/* Cleaner handling of Ctrl-C */signal(SIGINT, sig_handler);signal(SIGTERM, sig_handler);/* Load and verify BPF programs*/skel = sockfilter_bpf__open_and_load();if (!skel) fprintf(stderr, Failed to open and load BPF skeleton ); return 1; ring_buffer__new/* Set up ring buffer polling */rb = ring_buffer__new(bpf_map__fd(skel-maps.rb), handle_event, NULL, NULL);if (!rb) err = -1; fprintf(stderr, Failed to create ring buffer ); goto cleanup; SO_ATTACH_BPF 📌/* Create raw socket for localhost interface */sock = open_raw_sock(env.interface);if (sock 0) err = -2; fprintf(stderr, Failed to open raw socket ); goto cleanup;/* Attach BPF program to raw socket */prog_fd = bpf_program__fd(skel-progs.socket_handler);if (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, prog_fd, sizeof(prog_fd))) err = -3; fprintf(stderr, Failed to attach to raw socket ); goto cleanup; ring_buffer__poll/* Process events */while (!exiting) err = ring_buffer__poll(rb, 100 /* timeout, ms */); /* Ctrl-C will cause -EINTR */ if (err == -EINTR) err = 0; break; if (err 0) fprintf(stderr, Error polling perf buffer: %d , err); break; sleep(1); cleanupcleanup:\tring_buffer__free(rb);\tsockfilter_bpf__destroy(skel);"},{"title":"task_iter","path":"/wiki/ebpf/libbpf-bootstrap-14.html","content":"task_iter 是一个使用 BPF 迭代器（BPF Iterators）的示例程序。该示例会遍历主机上的所有任务（task），并获取这些任务的进程标识符（pid）、进程名称、内核栈（kernel stack）以及任务状态（state）。 用户可将某个进程标识符作为可执行文件的第一个参数传入，此举会过滤掉所有不属于该指定进程的任务。注：你可以使用 BlazeSym 工具对内核栈追踪信息（kernel stacktraces）进行符号化解析（类似 profile 示例中的做法），但为简化代码，相关实现代码已被省略。 前置知识 BPF 迭代器 seq_file NOTE:《Learning eBPF》 中并没有关于 BPF 迭代器的内容。 运行$ ./task_iterTask Info. Pid: 290. Process Name: systemd. Kernel Stack Len: 5. State: INTERRUPTIBLETask Info. Pid: 291. Process Name: init-systemd(Ub. Kernel Stack Len: 5. State: INTERRUPTIBLETask Info. Pid: 361. Process Name: init. Kernel Stack Len: 8. State: unknownTask Info. Pid: 361. Process Name: init. Kernel Stack Len: 6. State: INTERRUPTIBLE struct task_info#define TASK_COMM_LEN 16#define MAX_STACK_LEN 127struct task_info pid_t pid;\tpid_t tid;\t__u32 state;\tchar comm[TASK_COMM_LEN];\tint kstack_len;\t__u64 kstack[MAX_STACK_LEN];; The BPF sideBPF_MAP_TYPE_PERCPU_ARRAY 📌这是 BPF_MAP_TYPE_ARRAY 映射类型的 per-CPU variant。 这种 per-CPU 版本的 map 会为为每个逻辑 CPU 分配独立的数组。当通过大部分辅助函数(helper function)访问该映射时，会隐式访问当前 eBPF 程序所在 CPU 对应的那个数组。 由于程序执行期间会禁用抢占机制，因此不会有其他程序能并发访问同一块内存。这一特性确保了永远不会出现任何竞态条件，同时也因无需阻塞和同步逻辑而提升了性能，但其代价是会产生较大的内存占用。 struct __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\t__uint(max_entries, 1);\t__type(key, __u32);\t__type(value, struct task_info); task_info_buf SEC(.maps); value 的类型基本不做限制，但 key 必须为 32 位无符号整数。 get_task_state跨 Linux 内核版本（5.14 前后）安全获取 task_struct 的进程状态字段（5.14 内核将 state 重命名为 __state） Linux 5.13: task_struct Linux 5.14: task_struct struct task_struct___post514 unsigned int __state; __attribute__((preserve_access_index));struct task_struct___pre514 long state; __attribute__((preserve_access_index));static __u32 get_task_state(void *arg)\tif (bpf_core_field_exists(struct task_struct___pre514, state)) struct task_struct___pre514 *task = arg; return task-state; else struct task_struct___post514 *task = arg; return task-__state; preserve_access_index__attribute__((preserve_access_index)) 是 BPF CO-RE（Compile Once – Run Everywhere）的必需属性： 告诉 Clang 编译器为结构体字段生成「访问索引」（access index），BPF 加载器会利用这个索引结合内核 BTF 信息，自动适配不同内核版本的内存布局； 若缺少该属性，自定义结构体无法和内核真实 task_struct 做字段映射，会导致 BPF_VERIFIER 校验失败。 相关阅读： 5.7 BPF Relocationshttps://gaoyangu.github.io/wiki/ebpf/learning-ebpf-05/#5-7-BPF-Relocations bpf_core_field_exists 📌用于查询待加载程序的目标内核中是否存在某个结构体字段。 SEC(“itertask”)遍历内核中的任务。 SEC(iter/task)int get_tasks(struct bpf_iter__task *ctx) 可以在 vmlinux.h 中找到 bpf_iter__task 结构体的定义： struct bpf_iter__task union struct bpf_iter_meta *meta;\t;\tunion struct task_struct *task;\t;; seq_file 为上层开发者提供的类似【迭代器】的简易文件读取接口 struct seq_file *seq = ctx-meta-seq;struct task_struct *task = ctx-task;struct task_info *t;long res;if (!task) return 0; bpf_map_lookup_elemt = bpf_map_lookup_elem(task_info_buf, zero);if (!t) return 0;t-pid = task-tgid;t-tid = task-pid;t-state = get_task_state(task); bpf_probe_read_kernel_str 📌bpf_probe_read_kernel_str(t-comm, TASK_COMM_LEN, task-comm); 将以空字符（NUL）结尾的字符串从内核不安全地址 unsafe_ptr复制到目标缓冲区 dst。 bpf_get_task_stack 📌res = bpf_get_task_stack(task, t-kstack, sizeof(__u64) * MAX_STACK_LEN, 0);t-kstack_len = res = 0 ? res : res / sizeof(t-kstack[0]); 在 BPF 程序提供的缓冲区中返回用户栈或内核栈。注：仅当目标任务为当前任务时，才会填充用户栈；其他所有任务都会返回 -EOPNOTSUPP 错误码。 要实现此功能，该辅助函数需要传入 task 参数 —— 这是一个指向 struct task_struct 结构体的有效指针。为存储栈追踪信息，BPF 程序需提供一个大小非负的缓冲区 buf。最后一个参数 flags 用于存放需要跳过的栈帧数量（取值范围为 0 至 255）。 bpf_seq_write 📌bpf_seq_write(seq, t, sizeof(struct task_info)); 将 t 写入 seq 中。 The user-space sideget_task_statestatic const char *get_task_state(__u32 state)\t/* Taken from: * https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L85 * There are a lot more states not covered here but these are common ones. */\tswitch (state) case 0x0000: return RUNNING;\tcase 0x0001: return INTERRUPTIBLE;\tcase 0x0002: return UNINTERRUPTIBLE;\tcase 0x0200: return WAKING;\tcase 0x0400: return NOLOAD;\tcase 0x0402: return IDLE;\tcase 0x0800: return NEW;\tdefault: return unknown; open_and_load/* Open, load, and verify BPF application */skel = task_iter_bpf__open_and_load();if (!skel) fprintf(stderr, Failed to open and load BPF skeleton ); goto cleanup; bpf_iter_attach_opts 📌LIBBPF_OPTS(bpf_iter_attach_opts, opts);union bpf_iter_link_info linfo;pid_t pid_filter = 0;/* Attach BPF iterator program */memset(linfo, 0, sizeof(linfo));linfo.task.pid = pid_filter; /* If the pid is set to zero, no filtering logic is applied */opts.link_info = linfo;opts.link_info_len = sizeof(linfo); bpf_program__attach_iterskel-links.get_tasks = bpf_program__attach_iter(skel-progs.get_tasks, opts);if (!skel-links.get_tasks) err = -errno; fprintf(stderr, Failed to attach BPF skeleton ); goto cleanup;/* Alternatively, if the user doesnt want to provide any option, the following simplified * version can be used: * err = task_iter_bpf__attach(skel); * if (err) *\tfprintf(stderr, Failed to attach BPF skeleton ); *\tgoto cleanup; * */ bpf_iter_createiter_fd = bpf_iter_create(bpf_link__fd(skel-links.get_tasks));if (iter_fd 0) err = -1; fprintf(stderr, Failed to create iter ); goto cleanup; whilewhile (true) ret = read(iter_fd, buf, sizeof(struct task_info)); if (ret 0) if (errno == EAGAIN) continue; err = -errno; break; if (ret == 0) break; if (buf.kstack_len = 0) printf(Error getting kernel stack for task. Task Info. Pid: %d. Process Name: %s. Kernel Stack Error: %d. State: %s , buf.pid, buf.comm, buf.kstack_len, get_task_state(buf.state)); else printf(Task Info. Pid: %d. Process Name: %s. Kernel Stack Len: %d. State: %s , buf.pid, buf.comm, buf.kstack_len, get_task_state(buf.state)); cleanupcleanup:\t/* Clean up */\tclose(iter_fd);\ttask_iter_bpf__destroy(skel);"},{"title":"some file about ebpf","path":"/wiki/ebpf/linux-ebpf-file.html","content":"bpf_helpers.hhttps://elixir.bootlin.com/linux/v5.19.17/source/tools/lib/bpf/bpf_helpers.h 查看 bpf_prink 的输出信息cat /sys/kernel/debug/tracing/trace_pipe 查看内核上可用的跟踪子系统集cat /sys/kernel/tracing/available_events 查看跟踪点描述从中跟踪的字段cat /sys/kernel/tracing/events/syscalls/sys_enter_execve/format"},{"title":"c语言内存分区","path":"/wiki/ebpf/sections.html","content":"内存分区(高地址)栈区堆区未初始化(或初始值为0)的全局变量和静态变量 (.bss)初始化的全局变量和静态变量 (.data)常量区 (.rodata)代码区(低地址) bss: block started by symbol rodata: read-only data 代码sum.c$ cat sum.c int sum(int a, int b) static int val_1; static int val_2 = 0; static int val_3 = 1; static int val_4 = 0; static int val_5 = 2; const static int val_6 = 0; return a + b; 生成可重定位目标文件 sum.o$ g++ -c sum.cpp -o sum.o 查看 sum.o 的段头表$ readelf -S sum.o There are 13 section headers, starting at offset 0x2a0:Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000018 0000000000000000 AX 0 0 1 [ 2] .data PROGBITS 0000000000000000 00000058 0000000000000008 0000000000000000 WA 0 0 4 [ 3] .bss NOBITS 0000000000000000 00000060 000000000000000c 0000000000000000 WA 0 0 4 [ 4] .rodata PROGBITS 0000000000000000 00000060 0000000000000004 0000000000000000 A 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000064 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 00000090 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.pr[...] NOTE 0000000000000000 00000090 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000b0 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000218 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 000000e8 00000000000000f0 0000000000000018 11 9 8 [11] .strtab STRTAB 0000000000000000 000001d8 000000000000003b 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 00000230 000000000000006f 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) .data 大小为 8 字节 在目标文件中占用 8 字节 (00000058 - 00000060) val_3, val_5 .bss 大小为 12 字节 在目标文件中占用 0 字节 (00000060 - 00000060) val_1, val_2, val_4 .rodata 大小为 4 字节 在目标文件中占用 4 字节 (00000060 - 00000064) val_6"},{"title":"内蒙古","path":"/wiki/gallery/gallery.html","content":""},{"title":"gdb","path":"/wiki/linux_tool/gdb.html","content":"启动调试正在运行的进程$ gdb attach 进程ID SIGPIPE 调试过程可能会因为 SIGPIPE 停止，可使用如下命令解决： (gdb) handle SIGPIPE nostop noprint pass 结束调试 且不对当前进程有任何影响 (gdb) detach(gdb) quit 流程控制break 在函数的开头设置断点 (gdb) break func_name 在文件 main.c 的第 10 行设置断点 (gdb) break main.c:10 当变量 counter 的值为 100 时设置断点 (gdb) break main.c:10 if counter == 100 tbreak 设置临时断点（该断点触发一次后，就会自动被删除） (gdb) tbreak func_name run 如果是通过 gdb 可执行文件 的方式，可使用如下命令让程序运行起来： (gdb) run 或者: (gdb) r continue 运行到下一个断点 (gdb) continue 或者： (gdb) c step 执行当前行，并进入函数调用 (gdb) step 或者： (gdb) s next 执行当前行，不进入函数调用 (gdb) next 或者： (gdb) n until 👍 让程序运行到 2774 行 (gdb) until 2774 finish 👍 直接执行完当前函数，并回到上一层的调用处 (gdb) finish 查看print查看变量 i 是变量名 (gdb) print i 修改长度限制 👍字符串变量的长度可能会超过默认长度，如何查看完整的字符串？ 查看长度限制 (gdb) show print elementsLimit on string chars or array elements to print is 200. 将长度限制改为 1000 (gdb) set print elements 1000 或者改为无限制 (gdb) set print elements 0 info查看当前函数的参数(gdb) info args 查看寄存器(gdb) info registers 查看所有线程(gdb) info threads 修改修改变量的值 将 flag 的值修改为 1 (gdb) set variable flag = 1 多线程获取所有线程的堆栈信息(gdb) thread apply all bt"},{"title":"git","path":"/wiki/linux_tool/git.html","content":"123"},{"title":"sqlite","path":"/wiki/linux_tool/sqlite.html","content":"进入交互模式sqlite3 event.db 查看所有表.tables select name from sqlite_master where type=table; 查看表结构.schema event_statistic 查看表数据select * from event_statistic limit 10; 退出交互模式.exit"},{"title":"strace","path":"/wiki/linux_tool/strace.html","content":"123"},{"title":"光猫","path":"/wiki/wlan/cmcc.html","content":"如何获取联通光猫管理员密码 在地址栏 192.168.1.1 后面加上 /backupsettings.conf 把这个文件用记事本打开，找到 Adminpassword 一行后面的就是了"},{"title":"介绍","path":"/wiki/wlan/index.html","content":"131fd7c5506bb654a6cea69bbe40f3df7da318ecb0403b621d8f115b1f8d302bf6a9a4d5270b84db0e87e59dfe247981efcd8281284099f469b4b4e8f634e868e4671607d4a31592aeff9d649d1e0407bd7e1bc1cbf54d87af3576a02bf8498f2fdbb69f3bef66d718f02ef934c3851bd23c8b140d894efd71c93d3642f3d411603562ce7eae6717ce330a06cf6eef7c9fa36333050b55caf8efd91b39b2131d1ca0948aed75e43787b7163c54d62c027a420ed131665238b87de39ae2d8e7ea6de41a1dce92224b92bf589d1873a158e5371aa4880c0094095609838fe2e76e080c6da16ab74a1c3fb0a14928da5d400cae7a12bcbac5d2c250f791b0d46a905a1381a271cb7eadb98ee1a4ba97835872b4e4626f7f80e727fb3d49ac05760febd85438206bdaa6a09be2f192edce456b782bf63d57da24f8155c5a791e52bd98185580ce691b8734808d92a88dbe0fbd732db0e73c764cae2beb80797ca8b8549a8c76a648b2b16c6aa5137e5ffedbff4ee147d5370a5810ccadb61942ad69cdb241911353fd464bdeda402d9e2404ea735852a7ab9e75f56ba829952669402b15f9ec52fd0bdf7d7f3d42d9bb0534a4f92300fa7ee6df8ec6d9ce9824609e3ff230f3c258ff46f17db7c311c9c10da218083eb5c2e403ca9f838a3f6f12f33df838fe76844e1779e468c512c7ce776b1aa612d330eb79054415608982b02000de020ab1ea2c02648772eb593f4624491a5b891cd162e4d443b97876b9546a7d021109b2f3cfcdd5630fd22a942f99cbd3157ab67a087702322dbead0a1a138b435b2f9d042589146bc194902d9c3537ae34d1e31833f91942f651422588db2159b26ab4d559d936f5f1721af6734d4af09768a65b16c6dbde939c2ad0a1e11c468544ca73bf243cecefb148dbe95b67b1468d80cb31b761291734bc708a3ac7ae9753f5a43d91766afbb254e7a389db40c0a71d272b1471ecf95ab18a890f2ca583102cd106b2a05b54a35b70e1934423975409558894b6a5ddf15164d9ad5c2d67134f1020617df33294d76d15bac449b71ed633afbf4f593655f4df7c913309c76c2cad2aee207071e1f0aecb1cbdb712ff5e87049ffbe1027f1af47000a65a71ab1522e2b93164e02d7a774d54294b9d018945bb633bf0114e375758dd0ec034faa896a8b3a715dbec5c5c8168daff0fefc37a516803e2c1354d26123d0fcb94d23a4cb2dd459d1532d89216f9fe744434257971cd4be4dc3013e22b0cafee42b89aa3a52af0c8518701048962258e1375d2e40e07c75b3d7a21f2c51bee8749659ebdc0b694c5fccd75cf860964b83be091c5e020e6a2ce3f5605890c84a5d717d22ce483b18fe614cc2933b455d495c62843ef750b96c066456d8dcd421a90ee61e3994d32df1c8cd2774877dea24302089cf59f1e0987f4c7e76d116e0b5897c6086c71bbc87020f5c7efeec606db70012ac0b2362d8c32223eb8257e03abe7948e9e5ef3cb1969ba05dcd5d20af794bee131bfd0a41228fe3e6e5559d3b6e82a5d9a220910f7a8cab8089739e36933e285fa9c11c288a19a2dae2b8e51e9416c273d23d8761e2a8c9b21d945db73b8b7d483056f8ffe19cfb02becb4ed3d02da0edf91f74aed61fedb53c884924d501e17f0850b314ac207a148de8786d9909e069ecf0ef493af008ad9f44bf52356e838d561e3f6800a55484ac8d75ea84320f27d05e85a31c910f46e78e2f8ff099dbc93fb11808bc40b60e5cce87f1c51d9c404f79b33df7ddc4102a5b2365ba7b63f7a8d7f906b1a3040baddb5e858d3a9516737a32fedb89a38a7f55c9aebf6b1d975f063f4f9a0abf6014bd7741ed25df7724b6c8443c0d8f078b9959f94679c597cb1f32b1f26d7b8a1b728d614b89fabec5d47d400e2c098bb4904449e69261a62660d365ff35e49c7051a9cd85dc4022ad9eb44a3a795a2d007462b1d0f4e022691bd962106536039145c7d8826acfd432d057e99269f31ae805103d24c25cb6e244b151d070ecb5bcc75130ef7513bcb1d3eccfdcfc7720641120dbb3d2d9e30bb3cd2cc34e1d69dd0e5197c02774eb887dce80799de00465f0c230b9901908f20d399adc2ef6387f72d55a2f26f3f17add585d64da9967ce58a2ee6b8f6c39e7737686e7de74c4747daea0576d18d34feb2b423700764ec2dc56a8b1d3dc26dbd10ca477257077bedbd5f4c01a507c1ce7fa3c08efbfec1a7dd56794cfbad6457dcc7e3507238920beb3856e6916f2a52f525b0a277cfcbb24dc77827c35be75bbd87e6047d563d6eac2f271b6329783a024d1a7efd49580ff58df3531df32b6e66d4caa20bbba3fdd489f9df7b8ad76df863e510e293b0b92dfdfd637eb82b287114935630f018d11dedd806d0d3a88cfbbf112cfe4f64fe58d02fd38a14893bcbf57c57648c67d21167c1f5cfefaedf6e19a059340b53e966cd58fdf1ebd06d05998fa64f05d3410de89f4d6a137cded66dbc5cbb176958a7005141efa5ba41194a6ff74244d12e6c1d6f07008c08bb44f04db7cabc9ad811758f40a319205a90eba1f9991f0a12d5e1c37fdfc3a7742a97fa2266c1e5c569c451c05b3fed136e0fdbbfeea9bcb5e7a7aefdea7abe179f6f0069646f9893e7bd1f814a1d01f185a58257171fdd44 Hey, password is required here."},{"title":"路由器","path":"/wiki/wlan/router.html","content":"123"}]