[{"title":"webservice = XML + SOAP + WSDL","path":"/2025/12/24/0024-webservice/","content":"简单对象访问协议 (Simple Object Access Protocal,SOAP) Web服务描述语言 (Web Services Description Language,WSDL) Web ServiceWeb Service 指的是通过网络提供的服务，通过 WSDL (Web Services Description Language) 来描述服务和操作。使用 XML 作为消息格式，通过 SOAP 协议传输。 WSDL 文件是一个 XML 文档，用于说明一组 SOAP 消息以及如何交换这些消息。大多数情况下由软件自动生成。 WSDL通过 WSDL，可描述 Web 服务的三个基本属性： 服务做些什么：服务所提供的操作（方法） 如何访问服务：和服务交互的数据格式以及必要协议 服务位于何处：协议相关的地址，如 URL SOAP 协议一个基于 XML 的协议。包括 4 个部分： SOAP 封装 (Envelop)，定义了一个描述消息中的内容是什么，是谁发送的，谁应当接受并处理它以及如何处理它们的框架 SOAP 编码规则 (Encoding Rules)，用于表示应用程序需要使用的数据类型的实例 SOAP RPC 表示 (PRC Representation)，远程过程调用和应答的协定 SOAP 绑定 (Binding)，使用底层协议交换信息 SOA 与 微服务 的区别 微服务相比于SOA更加精细，微服务更多地以独立的进程的方式存在，互相之间并无影响； 微服务提供的接口方式更加通用化，例如 HTTP RESTful 方式，各种终端都可以调用，无关语言、平台限制； 微服务更倾向于分布式去中心化的部署方式，在互联网业务场景下更适合。 SOA架构是一个面向服务的架构，可将其视为组件模型，其将系统整体拆分为多个独立的功能模块，模块之间通过调用接口进行交互，有效整合了应用系统的各项业务功能，系统各个模块之间是松耦合的。 REST 规范目的：为了让不同的软件或应用程序在任何网络环境下，都可以进行信息的互相传递。 表述性状态转移 (Representational State Transfer, REST)，可以理解为资源表述性状态转移 RESTfulREST式的，是对遵循 REST 设计思想，同时满足设计约束的一类架构设计或应用程序的统称 人们借助 HTTP、JSON、URI、HTML 等 Web 服务开发中广泛使用的标准和协议，同时使用不同的编程语言编写客户端和服务端，通过 HTTP 方法操作资源状态，最后遵循 REST 设计原则实现的应用程序或服务架构。 资源 (Resource) REST 是以资源为中心构建，互联网中一切暴露给客户端的事物都可以看做是一种资源 借助 URI (统一资源标识符) 标识 Web 上的资源 URI 和资源不是一一映射，一个资源可以设计多个 URI，但一个 URI 只能对应一种资源 表述 (Representational) 描述资源在 Web 中某一个时间的状态。 客户端和服务端借助 RESTful API 传递数据，实际就是在进行资源表述的交互。 表述在 Web 中常用表现形式有 HTML、JSON、XML、 纯文本等 状态转移 (State Transfer)应用状态： 对某个时间内用户请求会话的相关信息的快照，保存在客户端，由客户端自身维护 资源状态： 保存在服务端，是对某个时间资源请求表述的快照 如果一段时间内没有对资源状态进行改变，客户端对同一资源请求返回的表述一致 状态转移还要借助 HTTP 方法来实现，如 GET 方法、POST 方法、 DELETE 方法等 超链接通过在页面中嵌入链接和其他资源建立联系"},{"title":"C Primer Plus - 12. 存储类、链接和内存管理","path":"/2025/12/18/0023-c-primer-plus-12/","content":"a285e82d97efc7e61c5afb94ae7b6e0dd0562d8944e22b098e9926763bd5969acbe091992e8ab87f9872e65f71dfdd664fb7471508a0f6f9f5cca1c35eeb895a96fb4e6f8aef0e88a277c2ee758d6e354b1b3f730496d6f1629389cb9b228e4d93131074ce4e4f7b089d28860b00482d2e60960ed7132f99882bb33843a6e06b9fd57dbae0135b7838c522431613f81cfb79f7100e658bdb856917b03c319b3cadfa8f142f8d0f4c0a9ac6dcb3a0a3e38a4c55e047ff0bb388c5eb74732d94283df77cbc8a2dfafd3263649420b2ae12f5a0f2f598a4f261197b92ca0d0c98d78e6b86d46f5f5d0aa98520b061394271797d6cd05bd36293b7fef5f852c4ceb806a48202278422af51d9719bbac4798cde2fda75937d2736be1cfebd5c37f3df06c3e600215b7b847f5320e52a175061426ee3f18b71792a1e07e2c3f52237bebbba6334aaea0e3625faadb2bfd66a5fd8f268fd33d7aaf8f1d3aae59fe80d21839d8d2f5f18857f6767b1235ad1299b0b4ab7b40a1738ca9194ab1c86c86d0dc45e3a9b0c7b54c7b62264b875f3ad059c7be52779e2f295dd865725c46dd4eefdd322fe98d93b96c09b78c524c3b3a79dbd8bf3df5dca12a5ba86dc3221f25cac88ef09b7bb25de8089a3a856dc51ce12ff87aaa4a8c63d22831db53d7fde80f421e685b52bb8a46979d34ead7427355a75cd77bf2675116fd03768c2edcee5ad77409e3361919013484d50a5a91f0e802d52e66729dea6a30a373a69692f2f38a16359c8a366957fa46135daaaaf3ff4f07b842bb8bd234b6a091261a764ff4c3cd0a8e448a87781c1bedb8dc048e8c2cd0d128d245bd8a6f8e4ac524b2c16ae8c934436696b790ee3cd8ad66da5805e4e2f39efab5337f766003c83f4abb629a2d540c2680f29b95c5bd8dcebbf77f527eabd2ef6d0feaa2a5be0e305f1afdd29a93837c926a238e1a5c89404066628f556b0cc257114a6da7a42bbce8429f1e66f21d297224c591603dfd3f16b538fdc6008461a7add6e633ac72f03433c611114f0ed17572afe19ad1e13925f4bd359599c97afa07eadb16139f0c531f5f7fc679078a24178d10035adf3916bdd6d171d5218df17cf6027f366a57732c6c04389bb2faeb86c2c97d3af1bd566eda0a13dbc8118b35678453ce27ce7d98ab14fafd4f6b18091e72742023afcefdd009eac3570ddaf2c901b94ea9768e5585e1a7b6bd6c2b67260d91e64254ea2b8be7bc7f549eb49e5b9ca3b171f5a89286ed963eee91bfab4a85de709e682c0bbb1a39d937a56bb03376b22990d7e8ecb2f06cbc973bf9aab39b64f5c6c2b723f555cc01db7250d7dd5f12b01f08ccb05e777084eba4b180d68e3c8fe480cbe3dae9bb0b5e3e654cce3f73baa173ca63be46769c56bb4f15f0a693e39b4a68cf15f32130b655a354dc0e9aa725ef6b3814617adc66679d60fb2b7c2f00ab05d0a04d5549f6c7a64a904613c3439b8bd797df720491291b6e2dec382e576e4bad80d28f0dfbb1c262378d861ac34851f099f3e867cc5fdc4c666b73f78b28250e4330aa79d0b16e32b3d952513856176ac28f3b40262a250b7c5ea94ecd7217192c8a94406046ad4b2fc9454cf430cdc302e404b39e820c5db62545d54fe658f7d8e72320630e92fff7c6280653df2818a8670e3ae68d66a156fdb5bc1805280dee443f9db037a634c7500923b1f684b76d3baacb290641e05928c80d7de070fcbc712097f07b7ea5506af7845bb507469360171712a0cbe114d60a6599d2b5c3ad88ad56f3cfbc89398c1889007c5a386530cef87d1dd9ec23a2b1ced663baabfbec0b78dd826ea59415d6000809717eab9dc7ebc464a4ae09eab2f27025a0465cf4b80cc6d95f44ce0f09fe09f5c1786e48e9bc959c6e070684c80a88c092f0dbb6e4fe4e6450f95bfdcaa305d888049a05bf0743977f06f0b309211952d2cf076cf669d888c755f68241c91b110b3dd6e6677f15826a932f73431b4bded3eab09ec703e590d8b74d37d5385ee88ddc8ffbe3c97f8a2a23fbccadc63157bbeed416b0b8ff07f67c359262e7ac4f016edb27cdcb239c492e73b5e08b0f795fcb0ee664e3ab7feca13aedebec760b7e4ee20f96eca37faf3a766626d6606919dd8f901dfb7f54ebbb0e9d918897f3841a9a4960f54ff593d050c44afe7cc7d3defa16e3f81d309e9b201964558d123a7b3494d4cf4be2485f385c6b3cd64d64efab80a236e8e344c743fbd1a0239e72859eb87534d6bfbcb0d37f835449c527c45185c2ecee3383d63ace44e45a05121824fb2bb3b5cff089d5ea4bc1365ded7fa228c5d4c00b5af7f29992648c2a54ac7257ab5d5e308de551f649c45f12e55f6ea7a87dd679136027b17263095d47083e376efdfaa823e17ca96837523eefeccff1c7061927963034f9348e56e194167981f2b2b74d2859d1501cdf4a9f50e5782b11f6dc6d72480cb9446d7192af3be509a57421cf97925cca8fcd4cb96fe7acfde9a5195791120816f4b598e9c99d00db07a08cbc8a81f07fe1eb61a01480d11b66d93028d210bfa74cd02c5ba456f3f827960033631aa06dfd2e677ee65d8bfa12d6dca9a4aaf3991c5c8db6b9698cea5b262d8c0dba02cb9de8e613b0e36732060549823b5f068ee83981d6a94e614d130b70a906817f52d6c0dabbabe08e0df5c30c5bf3ea6c3ba87d3885e7846ca666774e9226b0a7e3b3acd42f57d9c3a556a287f098a3937786ff361b2a15ac7386bbaac196a5dde5ced818ccff2fba992f2457776fdea5474a7fae4a4695802c5af17588bfdfe849445fb457ab42834ecfe2a7fb747b6383cbfdba5e80bff78f0c97a876bc04e5dc156cc0f04e0ae78b0472f877e3abaf67fe00e729026c7f9871535d32fa4211735a138e7331a3ee98342db8880eb87fdf8a4df29e1cff25e44ebb6498cfe013e4401b953bf1a2db86f074329fe9b47fa5f051eef8b0d1dbd973ac7ef6156c090a0d81398c4033180ac0b01dcc560d6b2449e002c407e84dde9b407185dd44007d501fc8957a4b2b0194c5b382b9e102f212a2f9ea5a1ea059eb3aa9b36776744d45a2bcfb0b05744b11763243c4aecfe876267739e709fb6b6f10ccfc155eef855ea3ff95b54de6488eb7b8668c3ffca8c17170e2eeabc0d491d2b29eb181d99589e45f0b17173270e49c07f7e2e1275bcc07464269c75247ce23dcecd3cc66f2d185f68a28b9da06527e59d2c6662be2fc1fbeb07bb577320f260551e23c333557bc765db50c869c7541e7ea5853efd82549210c0518a2cbf74357a40088ca8e85cbce7f6a910baf7d9555d78c48c508d247f80a18b3f6759c0a42e099e588636044175850f084fb322fde75cc060ff281cd171c1b66d2ab34453650e3e02718af7521e5de9f420f5fe04aae56b337e440f26adf266f1bfdf12281a0f1d8d102ab644206857dc19b2010c5f8ddf33c948d21a19e8dcc197df32f8de24af700d93e1964701a8e11e35997879107da65304f98e6bc5e015f3a2cd6c6575fd3c259ee3ae36d614262a5fd0bf7a106185a4f3b6ff27a6ddc8b7bcf8481ae59f093f832079f5d8ba233a1664efff9529d79870513ea267968ed82d8c3c49ca37ed784edf8eae9010de48e74373003baf8efbcf63db1ab5710b0a27aa67fc413295345e04527504a9e94196177d9c1a59dec384aa74c8f2c9ab03cb3e4bede89076af0ba193ed4052c5d8f9f80ec72d069978ca0235bfef2df0bfccf949475e08fc97e661948ecf6ce1923e867411994e8cbcdbe04c017e074e637529bf5b1ec7d99e8b93f8f8a7bb9751586e5edff44dcbc177b2624855f7f665c4c3fc0668afa0b803efc8b34a6da818e31b6f114436be38113152de02e79c01bccb76afa8a9a0ec0a7971e16155ddf2c40ada99b4bd2a587a170fe8b797cc686a199885594a26d3bb067f0436857d2e32d2913b6a43bb993f4678801af0f617c2a67bbb13e358a25d3b65e35708dc4763345b7642220e251751bf2dec5196e5e911420f03b7dbdc6822e1f1f34140457491c61137bce7dab6c0070c2ed12fe6831d3f43dcbd9b7aa540f50e87cf534fb2ec86378416ed14fbe0ead7b69d411cf710065e09f29e56b5a87c001ab717cf5ed9a472d397c5edb9d208732bc2c1a5531b49d21a33f6364ed96f55de7a9210c7c82b7bb18176b65ea34cd4aec335cb9c7eb736699bda621cd75432da36941614422b6e040a6463311ef30538dbcdf8b3229e315be0ea47b7f09df66d837b9200f9504ae8d61ce4045d65d22e47be2a9cf74d4f173c43edf0905aeba433ad5af9a16329aaa6478db14ca75d615b6dcabcb81adfddacf9e1df17a9a3f57c39fb5f3d3e3ae23b9b1c673a125a1f5b04bbcb591831bc4fb10cd70fd72c666b607f2f0e161ce718fc5db86bfeb392154b4c18b1d2d395b4c54d4dfe87fc810ebac0c3bae7d58ee818b6dde8c01f72b13ca76bbbbc0873697e1d791d87d2f2ff11fd47fef0815ec1a25393101d50d9d0a8641392224794331d69cd55672916cb3e0f4674686fe60420e2da1840e68820b41e504f34ce7903cb87b9212f39b3bf45e3ed1cd49209d4684e16f4511fe4bd2d4826ac2259c7c41e8e2c62e27b1a689042d5a4c4895458e699361ce7ff89b8227ad0c9c382e21d524f49260bb1cb7d7dc7b2904063239a6749afea6c254fb4961185b21f15f3e000f5689172ed1276e2b758d64c39b7b99762110eb35178fca0de1b267a3d68d108b4f9d4a9f183ffe22a209fd72639a3d84c382854f47e07870f08eb71269a19e7c34031c9d6bb8453f7d4c27cf0b2ce442ea5559b4cf6d336dd6ec27d5adca4c58b7ed37ff5f3daeb6774352d730e5696c79b3e27c12a6eaba29bb091c4b0c3d32d9c2babd929cd0cf931b21665b182d35645b1d3f67531f264aabd0a4b72e831ad7bf7be3baa8e070c80e690b7d781fbb3b66ccad896551a27011a38f377b882b7dea11a81e3555947e81957cf8dbef959dc449af84670b540da8934fcf7ff79777879684e9ce93dd954e4199f548378c84ef348a10bd6c175d0e19b9f7bfa5e519b6bc7f29c49139a667fcac9a7a958b6c6699aed8607e38cb7f2fc6786195701206d1f5cca021d5d9beb602ab07d4113638450b6703e3f65e5a8fd32142ea7b3e87f791edb3dba71436955a68b4ea086d09148973a2982ecf56558c54778d5f13afbc113a5a189d65fd958e173a58516fb89cd6f8ed30755e14341e0c1d10bfdfa688e2b4da6af5878a2635da90f63e2501ba8629ca135d2a73c9bab5a246ec35f5a9b587fbe7cffe17e514dfe4dc28e2111b11ee2ff54a60b4d0fea008352aa79087f290c989b25e65f252bece6e86a1daed2432d80c6fe18767c7dacc7c1b478bcda2a1bf5cc39cde4e6cbabb1dbde8929cb4bca33bc6ed70ea3bb5f23176f53f66d6644c7704a41d7b16b4ffe3031cc7db1b1d12ffce114727c625e0ffe304a6a1e8041660b424bc4c5d841f29769b9739d6a52ee7a9823acbc55894aade7f2f71eb4e92a114f48e1a86072fe32f07afb067cd6049b67088ec80bd0a1e52c225af0880f39c96ffeaad72feaae9ebb02ce3d765ed1987e8521dfa8cd2e6f0ef8cee5b9f1d5c447120ed69b3c5a3e659d9fbf1da53dd6bd821868648815256152fef3f830bb9df6a1a3efe69ef81ec87af5a92b2b4688d39644b9a5a63694cccd0c74f0c6e166a7311f4bfe9ece8ab6b4a49fd1b0e25d3d0532b0e9edfe96b67bf05cd7aec8c14cf9413d672ea1928ac5facfcbaa34bc0b188c04ba6b000cc2707e39aea8e8b6062f7c3b09ff3027aec3f8a54755a2a41355f342bf6afa6c3e2d5eb7187b91c1818ccdc2fe2347c8f01cd94e810cadaaff25e6b578d4a149f0e88a209e95f668a186f164882b390527dabed6abd3885e34f626cc79479cebae4715d5624de1454a66b9bc8626ea3930b481d8cfbd0f2d5c138f459215dfedd38b3162a3aa5bae23ecf6526b21d2f5631792e89729fcdae163fdfea1d90157e94fd79a85626dc72400c281c79acd3015c488e8117f28a47c25a2be3c89f484e9524ecd0a86fd33b91c842c38c1a06304605aaa89310f46aacffdd7326bff79b9b915fd6e7e15edaae67cfb733359af7a70ca261ebbc00acdfffd970bd1550ba3419a0e3b097af002a8a98cc4e384815ec9159632a13b22cdca77a2f03a065d12edc714ea502e298b3c1545d8cdcb7ede41ffe22440a65789d573badcf203e4f89dc22dd3ca81945d696d37a2e3aed94949806c8535ad8d8161e84cedd7f594e9cf71379be2a13f7506f0c729d5d4bb59c34f1333c296845afe0350b61df5f6369ee1df112dc8924a06efebd8470d5beba1f474ac887901ce5a6d91dafb325eaef9a9aa0b387bb5c9b33c5b9153567274b318ea28ae6356877c84255907715bbc3aa0c024f391e84b206d42981d2a225da80bd724e2041dc93af93beba8cedcbbf3c28f2d9858aca828ad23cbd1834a2ea7fd8ab6a7d262d3ec08a032dcc6047f168761a624508250ad4501e3d0070145a16b79da6f97e6e51edfbe778c3754abbd848db7a8ade72def93255e0c489885df074fb2f1965103bedc50e8fadc2f93d19ea72b3733b9ff7f26dee7da0eef6f139e83f909c129b33fadafb582db0b76c459ee461f0fd94874b7ec57a26a54969796bd9717bc98bd623ef32d1e3a1ac972fdf7345a42300f7872772592f36023f141ac2f6a439908fcce0f701ab5fe86031943f9b2a0f4ecbe792c17240f92453044656075315599402749676ce755bb088dff8a374c051c5da076c30acd39b0ec6bf690488eac834a7c50a02808cf0990f2d922201a9f2a817b10fb405692f592c8168ba61f7b2d0876f205a6d420228e8aa9528ba76c9be51790a4e73a895c9824f04f4c7892e391cc9d0fceca93787d56695f27dcc67c86ce3ce6568626f61eaa8a9cd7167353c1686ebb604ba52c0a8c4eae7f0665d2be4d321b86c806f852e43e72b17dac66ba618e57cb7648efa0d1a2c4083c6a4e7aefe121b75fdc1d9a0b323470b69a85e26b637bd94e68dfe44aac2ff6a3ba12d9183aebeb94be2cff87d583f67d58325079eab25a375175e211d95a596733ce6e2046d1fcaeb79a206f8489230c602e661502b311c0cbea880b99878532e56bbc538a431b5edc8481152d431337e3026f53d6815ba6bd2a3720b178362add50ee47f2d837c1777283f2686f5b306a3106c5b77303eeb614a107ed37d78b724c91b6847724087c343f5ea9586bedb626eba9f29b6221c1dee0326710ee76e049b0235c0ae4a6a67b3054d17003c6638284f1f9e7c6e70d3142ff3e78ae458d47f96b69b2cf50023c77cf1c6c7f7b8ffcac2dd3698d0583dbd8b66a894e2b59abeab83ebe0767905129c3b86bbbcfc227e7804f660fc2bfbca47201d566fe1939df01ac55ec68a2bf7fa377490a31c00ff8ed3751d33e2d4a72ecc42fc8285c510f4ce3fbbd309dddcd9d2f43609ef675ff50d1a287bc8dcb3691117294af9873c7c4225056bf1f35c8f67fa268b67c7bb9525205722bda79a3c2ced1b752c10886746177d3abc0379329a616d03531fde103a887f06c457bfe1e5c2349607929496dc4f8e3f247e1a1641a00aaaeeb4a93d0930c3bdc2cd02182376aad5c8c7845fd0d905705a7b6041adac4fcb645981af9895a12f7a5c1c98002452979accc3a751a970bacbb3d3f122f5e6c4c4c60b2f3a164eec786d91242ddec27b2b5e6c59404288be4cd5a33545b4aa4f5d963cd939f8591f80654cbc827f346b89627e04b5d77b5783f6f962678dc2088be94e3442214cfb0994dba1aaca5e69df8140b7c4a3ff799f649eca496e237053af899e036a23ddcac67ae5b94c3f2cc0dd22e779348cfbe2eb70b6b8a1736fe1cd9f682bd370b4e9b568bf9a7385ded90e798a17f379edb9c96b2e78fb13482f88f33af63c99984c9a742da4e83e3fe6332837956fc261debf78613d0bfe9eadded8f59fe9f544a559ceefa9ed061a4941e337a5dd89cef498a247c0fad35b1ddb3b1e4a4b30ab96beecee8db2e206ff856159cf00a8f0b710b223c456abfd5bb7221d38decaab11fe03ac38949c083c4a7d5b76050cfa4cdb94a1a714f18f6263c8f5f559ca28337703c00c9a22d2c0cf8ead73606d6716285b30dc74ee37d3e1598f16201821e2861220297adb65e096153f7e44d47f704982678136032866e44a65ad9858cab8011fbc7601b0a812a355df11c70a1bd485d3c9d4bff1ec7ac0ae50fcacb29f96ba5489960daeeec0a4687f1990b0c0a3ae4fc047ad92a0b824226fbfba75cc2ab1bc8ccfb053df6011336b7412c583de6035c609ed8b7a5f0bef5ce402a02f7f9872b977c70e02d92b7bdbb11f289f4aa2a714ff7e81fa835db5302ca9d2722eb71b43892977c4bbbb6cd48f2f55dd136b4f0eed06c253f206ebb5ba885ad006761db8feaff8c32e9e7e63f7cb33a2be7e994d381957ff34111daf3bf77433706f2e60d280fd1d86c41f261835d5f556d06135210d6ad27c1cdeddce562cee4a74a399d7c005718829512bf0d0f52d85a60930e17aa1c7dcdf7537247827b839e8e7ed69382093804ef93bdc21dfe34e7855e2f3dcc56989ddd6749310144274efc8e0c94d8aebbdb6e1020fd335949ab9ba49285c59e6352630336d39c7fced2029d17f04c34e356fa3e3180f429269b65229b865d4fd1260303f1991bc82e8df30f9503ce6c8b4f77622156145ff433ea34775e6d09f4918c5f1c333ab61b8011a3f0beedd3b3210bffc69639f9796b061a4536eb9ad7003b57d1391357a13af7fb392a5d69b137888b28d793a8ac478097b0876256d4f0393e396b4bdc46fb416ad89b10005d3bd62b13a133adcd9c4de16c7fdd14eabe2a05f8f9c9562d16c361f7e54dda0ee2ff522098b236853c17e1f3b0e2da84d3ca8a44720bbc46160c11239b72057fb86c34012351387ea2e9881a37c427ef72fc2ef3df1473c893405b34ee02e487fa9474682265c81cb56c17648924096ac6f55ed3cd849141b608b2a9d84e918b1e29fa0f0455ae7a0cbce1ae59f2dbb8f319729c3b241660ce432e0ea3882b8e39c93bd2fb923e55a4cdfda0b5c069a4e878cb2395d06b5b2fbf82a56a749b980814785b3884917e3b141e73b19e92d99e738b10c9ff5d0992afe0886635ac6d21d189656ef7816654cbd56991e4c608a8518db373b062940a624b5ef576fac4ced48527e0848f84c6f90ac886e3232d31272b1882b6e3ef77debf1676761eb49320461d1cc868aeb997be4b0f07c9eebfb5f6efab817b352e6cc5907e7b2846e45b249ee6a3bb42ad9eaf10f4bc5f07af93173f3effb346cde81d6dab67846c6753415ea1105568e6ab8046f9550683c9edef84695a2c68659a354bcb1f872d7cb78f2c0c7df0287574852bcb2467046bf5c636ab6682de3085e9ecf1e89a5935b4502e95257e6249a5f0bf47b1f6f870d03e08a415a52b64593b7a1ce98be268d460825f74057673770f58003d9c7b596129d9d1a2cc1e670ea96679c2dc823eab39f3dff0e1222473c2256e1e4b98658d6b9352c8238da3c769dd75019003ec6a4865da1989a144bc13253312a42e1fbe26b9ee6d22d2cfbfe0c4deee13414c17065eb2e3d5fd8f3269be6ce60fdcb832ee70322bef130a701cda9bb4ae81f88e2af9f80daf09a75b91be8bda6ab415423e48005b6cc6d0019ae4c78d1a7fce6522ced40c3628f8fc521d517b8465074bc2757b190bc587de36a3095b3e30dda9954bfd4641ef0aa8196a4449e7e077b91a4f2503f4fc9605b3ba8ddd78a3fbe35c0245b066577f3527f865530b10357e2488a9708d9a63ba7e20fa8ddc673203d0de25b51dfb304c13d2be0478e7cf18b7befb4135de27b60a398f1e3ac741c6e50bbcf9af513d8d149e88ca51afd9c0c8d49878380c4ba78339e936ce8794aa9988975b8ff6489dbc434a976fb2492a7167ead527fd31aae6a54a29b7334fb1252b75747d6cbbcac35a31b3f79bdda6cf8b28e25b4c9d042ea2dd625491c05190536443a671fd1f08342019e2d7e525a90db781fc39201d7f971682a0b8b4669685a5423723dca740080728d770f2d50dd6759556919c8828078a9a0d51364fd4dab78438b9b558fdb7c8a0688cb791f6826859f13601c11281398499eb3edfe06daa3b3b4c511f15d279a02bb150881d30f63a73a121353a1c99b7f61a4aa25f9a76e73d24cfb864c97f10ac287390bfff32ac195948f33a4c80445f32897a0111feb73a9ca6b7a8c0aea9044d6675a6e2315812cce7bc00cd0d98163c2a1ace3761c4c5a273febb8d7b36b36b34fa1a7a628e5db500f08452ec230799cf21b8cfba096aa1f5c443dff69caf8685cbe07389deaf7bb0ec9e881895b346d141a630d23da3281fb5933488dd58126bb6d449997e05cae7514069190a414d1474a0e730195b818735226669686e8719fdce00c4cdb971e65a3ac08e73e8a38d10b08c4d410087b1216bb28dcb59a5573d5ff97858ee21d38251cc32222e787883af6c86d147385e464f92c209d6172c6ad86f9fb9143f78682967eeb756be35ad45de71943ae19eae9943e2d979242ce8a01ab7bc6f94ae3fe9b1cbda9478fa6409573ba20f131e25c18768ac6834e28a60b7966944cc35cb5f4bc697f4f762c15b5a4404668b68ce7cb6cc2d010df5a99d5c4eb70286e4c15ea3b1537ccbcf048a2fae269d06c2240e18f58871f147ece663bedbf043848f0ab3ec2c43a3d90a7699245a898ea4d80d42bb86e016dbff693089e7e62035592aa9462d11c91ca3e97527015e852c0d8630da1dc4b2857b9606ca7b5fd8cb4add1c4ffbe30cbf64d09f0d6b615d2d25ee51f1c8e2ea51ea21980fcaef53379b46717353cab0d6177d70354a06342a8c7a89aa4114f186baf1fe5c714a08b616eabdef443189b3b7d428e09042fcd7bb007d34b0ef143c71c7fdd8a2bfda82619417ecbfd2dc02c7e0bf1342595b6886d886b20f7d5e6c4b0650ad04e76ce7a9b22ba0ae7cb05f2e31c2954b76dae6b533bfcab63efedf6a6731af604c28fe3a58358d5ab46732d705412c1da6fd75b445e7ad46363bca89b81a35e66a753715ba46b5e2ca2262a22cc9856aaa626a37c19316514a73fcb6f76ab806cea218512d63d283de96a4 Hey, password is required here.","tags":["C_Primer_Plus"],"categories":["编程"]},{"title":"C Primer Plus - 10. 数组和指针","path":"/2025/12/18/0023-c-primer-plus-10/","content":"a285e82d97efc7e61c5afb94ae7b6e0dd0562d8944e22b098e9926763bd5969acbe091992e8ab87f9872e65f71dfdd664fb7471508a0f6f9f5cca1c35eeb895a96fb4e6f8aef0e88a277c2ee758d6e354b1b3f730496d6f1629389cb9b228e4d93131074ce4e4f7b089d28860b00482d2e60960ed7132f99882bb33843a6e06b9fd57dbae0135b7838c522431613f81cfb79f7100e658bdb856917b03c319b3cadfa8f142f8d0f4c0a9ac6dcb3a0a3e379ee71a394ca80e8aaed82cbc78f8066702df2fefe36f3f80802aab993934ddb78f2b28534f91f61af652438e8ed9b44d722a46fa1ea86c0251af09af943264944c64fce25c770e5204f264e04b602a36f6cd3dfb6c493dff1d612a90ea743cb2a9e308f40c725632a89eded33a2f5eb6ba336fd219755bcc84e85610c260068cc2b5276b4231c23d309a48f2c816d283ec60121d13811689633eadf0a00b5ee93151976e53e5617425f47249ac9293751644b95897d9bb7ded907bab5f287ea1e5dc37251d0040d91ac83c42890745bc1d291a00072913809b58f825e84a8928e7a0df7878ae4c026603bf3ad1548534009479ad10874a9ee7920ba9d1b5f007e6b21991af87c519fc2feac4986804ef638e250e15de789eb7182cbba98d4f5a8568f031b2447115fbe6c56335a65a50a42f9300eea94f08947bb2ab7feea46d8a1044f902c62fcf14c87be02e1d0eb6094ca71a3118c4570574e8fce5ee60aa06b17b2e5491e6b62ff96d7e7c01720e09e442e24416aa50d6b9ae2ab7355d3ec782fc400530532f85019b8765c6530887238713a762f4a92258f6672d74ecfbdd73102573ccd75b42cc7138f415a7f335180606a53d957e8a5b384b058ecc798a1d3129c2432378bce89e99d966420ad23e0f13ab9e87d0ce3459faf4229543c3114238eeb10fb188ba5dd2011c03edbaca676a9d3afcbc09512d420173e84ce14db9cdb69649e2a094ad768f63f0f96da950eafb619e55f86c5bd50cae26629ebb20062e59b8dc0be69cb78fbc38c9d31014a9687e7b69fecab238b3bc6f5e1d1c1654227fc0237d9a358a9cc58aad4642defe600089c24349aed7600be54668d602275e039a085037b4a4599233e29eec3f2e8bec5bed70a0c9538f91bdba2190b5d9fa3e496c9ec213bd9391643015c12e1712fcdf56fbfebc95170445660eb60a85a730472404976be428048e5607e4e87a6ded7f4abfaf29330c8c5b30497f038fd07b761dedf3410ecdc7e97430bdb46b1566db64f1ee1094f9c60ef77753a0bb725172ccd97cdc5ceb3dfbe66959efe9c05a2ad1f863cd66b475be56bd041d808bd54c8f61145d5a9e07d60f77729ea9dd69b230f297eced45259ffc3778d7c90af75a5864fd533c6bb5d80b0d0fdb894cee58190415771999b1e84a212ae79bb60dc5ce1bc00129fae9f1aa51a16268aee9db01eb893896e913e0e300aba9dc6bda660e197d4881b88bc580cb8981480ec41dd35c40494f40de0d7a634d40959b5d0f4db9b0567a5fea0206e27e755b3ec0485fc48a11ba8779067b8e7d995a03114e8bfe20d1495eabf37a165232cebfdfefd8dd1324a56fb134274244eaae5f6e657299ba9b97673b0f92d4acbb3974fd8d4473318795b9617fcdd2ae6d4646b8357fff74422fc15f305108aa38600eb399573a6fcb48f29734e968343165aafd6e1db1e322b17cc014cbf17a0ee3624192e7775079fd6953231b289b95d879a2ca1212749d4f1c7737fb467b832e5583f61f80ff6eddb1ffedba1f8799fd66b90091b7555dd953bd884dd7c9426e58c9551fc1fbb791f792abc519bd98885a40b5549cf17fa9a30b4b8e78f8d50d69a82f2da627fa62b61d79817bfa931f5a227b4e6ee6d7172411436c285c0dee2185fd9173e8bd48f41796e76d3bc3792ecb793d2a051308bbc35e4d7630a4907bf0f9587ab9e35c694226d419ef7dd80da2406754fdff0e5a6131e49361f2e5bee9d7e048ef04a3120ebdffb6c43488984e15b83edabc58eecf72c0e2bdd59766bdddd162f35c2eaf6d6f682fdc5fd7a3103da936b6a3029c42040e1ebb9fa72a445e5a5949b3944d349da2d5253c79b5b7a80c1d76250b45ee095530124dec09681d2fa4d0ab115a5e2a342a5a4d05b8cac77446888a5c33d8d2f5f9925df4b906361c2ddef30ab1be2b2c0237fc77ce6b7ecf2a8926ad5c92ca4a66c28186d0d91a4ff7d638062fcc5f73a73d6031c20cb008ef2bda0f46ff222d5291530b6935e36b3a76d71536ffb22fc0e9b3db03f3864d493d599a894ca2a9183c7853de266525d5dcddd8307ffa6c1d72255983a987d0ca2ea0456277207c0662ad06adef189c2ac9858102a9a53f0c7f11c941b336e59141c9b1c8c870385c6490e91bd288bec7d2a36570b61bad9b965eed9473d5a18feb698ba2bc70609b2fd857e665128c9e8c80e93f1ef926ebd1b5f23a1337ae6735a8afa291fb1ab493695f40abbd026ed5e5add5a7bee36535e24043d1651070f519b1a4e4b67a386540d3698ccbed0b70b8ed77d8d60cdf333c1d1053a6a3b003811a4656070e64dc8d9db7639c6f64e97714f661219db36c4e2d03b6bd7ef964c92816632977e4e8719a1339f64c5af58e2bc74347b67bf3465673fc10f0678f4699092758cbed8c9c493c55dc29d474a8d958b6dc20b73a017b6e2e80c78f5d6e4cbad773d92177b0e8277699a801c84f1a7db8b653edbf688f6fbcfd921044fbfdeb07e56faf9b91a18e40d07552de5d9822a71eea4090468c91bc839dd6b257592d077d8907a5f7dd0f0d3706a17d2a4d8c639c71156843359911a419ba651a7cee116c9ffd34c095c6119a87a9e1d25de74c6802a69a012d043fba73216f41af64d2dd826c44d1a3d010d93544686dc321bceb0bee984a9df530aa8cf26e7540b5b1e8068000354484142ea34de6767cce31b75299173640582129fafa4fe58930ed7ab40ceb5020656d4ca750ae959e96e60b32f5f1c59903b50eb8295e8f9c5449815d09e051c90b277a509b22e92c0c8126a0338ff6d3c3fa7bf0b16a7b9be090be489d0e7aa857e71ae73155d6cdf8cc66b75a370c954f3bd56381ce81c534f350389f6f5403cef0fe23cde4762696e93d805096ce1b57a3733b2397b7bd313f40eb79b9978f207eb9a3f9ab61474db2e8ad817a585275a95421e10066cb1626356446c5d6af7fc7df8acea246d938328691f3b8f4d9f37536088d176a47543b7aca71ba4776482b1d155fe2b16fc8c1c74fe9d708713a478f010ad7b4b800d2c87fba9a0f2672c293b80ec1b7d8de1133e9363dea0f46a8db2dcc31e345862d587c64bed3f9305de60a785df2eaa014eec6da23fe0af63a00a3a8d0e90712151551ae60a67e8ac88fd79d1ff744152324276d1c71a5054e7fccd5fa5b09966fa4c0e51242454b6ad9fc3f7874b9907d5b6562ea202bde36d5f414e1ad2ad6bc7722a6c29d98f6c6fddae00a27207ac86902de4ecd86ddac12e70fe79b74b877a52b47cae8847fd4e9e19e411295166f61ec6203064d46daa99cf66aea305d072c8e6ab75983674894565c20d0800b6dabf09c7aabdbf73c307d5946b2685e122d6cb3d0e09d360ba22a4354eabcc4f7959da3ab53df0c0d1bb2a229fbaafeeb79a80d99f4aa3d672f2b1d64f3a08c4181da1594ad1f2af1fffc18a938032c3e893e1be04ecf1611b32b52c90238d40e65f1483172b5cd77de6842c5f237b1fb770bc15aedc45ea583225e8488ccfce79c0a1c627099375e024e7ca06670a21c6ab637a23f85d02a783c20f585218c071d8075ed9a6814472dbc0900d382d3921d679b6e254f028b1a6388fa4d2f290c0a21506ea963df9c961ef9d0b9c8e8df7213e5a64725013f4c0e8f021e714d988feaa57072bd820a91148b286dac79ef06629d58b8643e8a3f8743bdbd89de880f9074691c434bb372865103142bab3dc1bfe1a3de0379ffb3db951022e581d6ee6285d989bc510b67d7830e1152a5bedc12fb57cbd94992484cf82d3a9829baae9f484dec0ebe28e96bf4ed6da93da59c536069294bc3be07245e9ad709c1c0c20b7c7eef6d93770f3cdec195221fa7a1513b969d41a20c1a2373fcec24dc01f875c0a2845f0f2fa2226b029476ad71a4db7385be9b4f8436ad63446531ca716bee2932f574912fa03f95d42f88361bbf61ded0e38d2d15f09980048cf2522a74d0886f780487dfc022497353206d4200414aed31adae7453f1118c7b50a7dfae6dd7ee75aeaedfc070a24269dd4fd01e79360e0904d8d1c7cd0fa99febb85d31e4aae4e65a23b83de6db15e4083877aadfbad582d8f498bb93c8fa32b2bd9770611078ae1eafeb009cfbfac3b9ce3111b8ef1853007d460267d72bbc1efdf8e7b296fa539f9cbde3f012628ccde5d9c77d0e4429372ebc5f9f358fc64c79731b4b33f0b8f4395b64984fdf81f7627a701eb105515d9fa733141aa71121733ef0e3decf68131326f41af37eea9878fa7ecf6be060689a57bb91dea0255aa0220477ecd771cdd4aa39d90e58afd37673bd204323b4285b8cc6dba3f69b0af399ec078689d55cb4769af9d660f07f3238c25b7854c05943b1b0e0b1569f51a6893d3b2f0b8eadad9b554d0d4201be9901bacbb41b6c630fc6da9c9af85ce01293ece6bdbb38403aac111d151dbe03288f27abcd09c6e73016e91435338800d7de63f52e2e405c0698b8ed98c7dbe58448b613c1e760d6e2984e8d92e9cde0cdd79337c1acd85c01109ab0e5bf444a205fe75cb6d4f516c445db39d07e312bacb1b91603d264699163748a4220066ab451453d31bdd9d94cab9248605aabc1c7f70072b81dce161f067ac912e53c22c365be1e5b098f4c77ba5b13d4e24173ac204ff0cb68e11168556a7e665cf5438f8e332989ec80703d736b5b8eec809fed772f2d5fefd576509992a12b88d8b818a2a9d1459da7b1e3913265b6d5e6b7b40562446f51bb84b8087ffcddb21467a1b22f73147a70c4a2c2ef277a92fe26f2e5a8a4126e16beec45bb745c881acd9d7f0348244cbcc677c9c2c7250cb84b15bfa8fe6ba2df71eb2657504209945fdff401f02cc62ea8f4b9d20983f041ab962e249208973e917c9447754027eba9a3afdde42b0d9a3a41e386f35876c5cb8761eb0254dbc5a5e779e5cce94f9265b7c4f293f64eb110988d2630991cc25d57427e735753fb035560e8d7cdb429243f0d36f5ee109b907a8802fd9615a7293eca6456d1ae36564582672101f4218be6fdc6d478b448fce60beef8d701b72d8170e3d11d00a19762ba14cadc414b851e7e3bc08f0d32097e149d4e10a6e06b08ef76b6c8512ffd2b2a2f36b689c57ad81f4ed2c4734e14a59800b8224dc988ebbd8cc95e2e4da898cc480dee7b166244419d139ff58371e151c30a3908faf41eaafc84daa6bd2c14bc1ce0b76f9f2b2ef9ec3642f0285dca67713be9649123f1f91c46f674211e1133e25b7b79c32378ba6e927ba67fbf7b3982f0ad009b05573acf3e475bf1ec2f7c1792d0682a9cb0503e36af930652ad6c435b213462a3d71d93dccc0c68b6673c9abc6a443250e66d829b77a1e3b9edc2e2937def8945d6f07a9346469c8620dbd096d70b8e383ea6461a1d78551108c3309dc3ed33fb5257fa1f37b5501ef37259f791ca95e0841d4baa77e8624be8a398959d845fa26b7cc9ae668400fde2e7ab4f67289d0f912443be4403090bad05e5f73b8d8a96a701ed0a8fa0c8781eea110d2efb79a7c732742305579c8098bb2bcb8ecf8f782c7136b4a25fabfcb2c455d7c7b1c447d445bbcde2ee69e586e0618cc708c0d5c4e604640294fcb431dba44ff0276c295a6029bb293b4da1c2c1e22e5d997cb6979339d35ec535be47b53dd7acfc8ba4717f344365512af04b341e0c77cfd85417c8598b6fc35508c9520601a4357b3b51bde10ca4430b70564827241b0a2e51cf76dd63c806a053de7b11bb95bf821e5fd27dea49c1cb4ee69af7902ed4b08a9e3bcdb70c14e01adc7c3f38f697623c0617047400001e7fa9bf235ff7013929cfb5f355d9f3f4ae13343618f588d2e86ff83cf2f7dfe951bc1f3e48c67708ee10166392293c647f2360e6a00417a68daa09ab606c45893507f5d1656a6dca21213f9e35894f5632c7f23706332fded4619a195e66f569baaf313553f06f69bb7ce6d1da5ee1a4e3106b9e50c69a02f6df402ad7e97967f10f25d8b12748e83336aec13db1b79b27ca97e9524b9e93764aa5250cbca8a72c54955b5a0df8c7a66fa589dbf7d7426dc57c3fa1370a545fa6c3c479f5dd7aba7b12c90670168deae58fb7f99751cb433ef9dc08b17f04dbd8d15cd03e80a73e6bb101cacfe46a3f2270d6fd037b203fe0dbda201f89a8757378156fe01858db3a86a303506184dedc48d2f65f1341123cf3929944e1c3868b488ad4e0030281aefd06e7d3d42a022f3f482b66fd9173b2381ab440e89e4558198194375c757c801a7bd38b295cb47eeb75327e2b4d12bd172753e1a3b612c3456f5e1be189059804a14c90dd090502ebe14603ba6a80dc73275bb29a8aabed7349c5585a253c67f16724fd2b07d06e66bb5275c79ff939fe63e004e47e76f607e310d987102d8486aae3c9fd44763adf14806f43487f3b6b9fef3807a3dc458c871b58640386a474b58cd63cc1b2c39d351efdb2aa8a0d965c80f555ea120375e86829468af3f89333f749f0d3f444de76d7f0e6f75b64566a9faaf52691caf5d53765b71f818e03c62b010a001b1136588b662af04c4d71d7c76c349b50c07aa7e6e77db33d8b003abaa30891a43e9ff76d790b1230a7670999cb1e70c0e9127a19235af37d0a5e329a2ed2a4375ef5cedadcaa1d0ca1ec093c2dcb857ada9f102c6c94fd8cdd0f478f96b59d0cb31050dd6a10a51304d198c3958586cd0300adc4092223eabc4169aa00b8e857ff86aa64d5d107ef9c01d327bd280b61d6dda9a421f6a194fa9796b81dbf3ff72e61f278be0dbecfb526680e171ffcb49782a0533610e980ccb9a6198638d3d9689b7ed4763067ec231c4e4cee1a5d697641edcd9fb1171143a0ca1e2568e916a8087c474687d57e38f8f9f1b01a0eace25612c0a09c45e19336be29673eef4bffcfcc0f4be6ecce6a7607dd68621ef244a5658075ee9ca90581e8ddae4dc2007ed5d2146e6e152af790237a2970ae51aa8361e34e4b8ba33ab068e0ecbf5732cbac3aeef39186b039c5fa456a81f3b7408af4f32addab0d295f4cbe8711b5c6d6979fcc06969dd242103b6c4cf7bb76a28587182a746962a9b3a2c89d1c428a6a663cb2e291d1c178a5b49c5ee006fa30edb3aa6a0e21deae676272d34e4f2b9c251a3efd10d7d4688f044b86b86767000a3f3f334f1b3eddea06751e1e903e7339d11e53c8782d314a5f6d60d6b0de316f86fcaa63dff70a91e3357468df4e94a6b3031f8ecaddec9ad9ae2f75aa9fae50b20d0b97e653be4b555ad9b662147c9881caa14deff8ef9327ef706853b3fbf9e4a6614f93a7faa2cf0a60dd04a40c7ea14346d6e057bc5e1219c3b6194cc4fb921ad98be0d90b17f6fd507bdd4b3fed8483dea46cec217cb273ea571e9b19e0ae0ab67bc3ebb3149b2883ed411d26fbd31aa0f83910e40e62c7d08df08d998a6227d26a416cde872edb627705ce7e339a7e124e63f4d2af06044a71a1e9ffb9a6a7a05b5cb55bdac638c40a3e5ac0a9cdc49021616e2a3135c91fc3925e462882fa94d39a6d6f64f9b8b117df910e7c7023c59accd9c017ca4cef05a78a49b3637b328306a845a4347fa7f37c1414df876e379dd089f9d2473e13fd92124b0b7c86dc61875a310f55a6e44b9fae60b15f49288a465956939a57aa41f651d0e43b9aeee668d42c986702d38aa4059e4fec309ed6af77f167f33a748d90fbe7920678e4d56d7f3f69ab260a7a56a3ff0c371a7878a23079b72c98460e047f3c15e1606a3cb3f8a8846cf4b56231c065e575c0ea39321755005865b36705dc94b5d706794fa212d33f790e82206fd60461aea844e374a7aeec631fc26fa7deb93abe60ebb44c31ee0abb3b15f0c4b9f16b932ff8d355298e56a21513f6914f946261a55990af9c39f5833246b8cfa55f9731b1464a89d8d3b13310bff33da157e0b4c39a070b0adbdcc8d47850956c2898ffe8ff4a312c5916b183def26466ea071b1e3b8faeeaef57ac3a04f81d225c543239fef1f0388bac7be32dc3ed07ecae52322ef38931a87e16770566964e40d00110d191c8973d747e0792e43b720083a04d0103f6f0f4cf9829ef637c00306440b1b13ac0776042fb0e5c2c205334ee5aded16c106238888b940bcba18c25c811f56538dad501e99af74328605d03b0e9813d34fb06b743c1237031d5344cbd12187c943ab9d3e24ef717e568b0ee310063b4b14749eb38099a60bc76f47e39d7c3cc81e9caa70e8c57f956cfaaa2588dded9c96ba6da02313502829e550410b8a59f27a728a8212f27f7f4380565fcf46f6bda37f529f7b0c0ac135381f31709c6f0cf68c4d3b736893228aee6826b9c2d23653cc4e84aa631f01caa4e62fbe1b2f41f9b2d69f072743b1c5059b7d958c9d7faeb7a79885bc3a01e044d0dc2084a27ffb618832241859ce210d5ab6e81e36f3b8cf1797e20b1f7f4e309347b2486401a972b64f0a19469a3e9f131dec2544ca57613e4e7683691226f687917610460fe1bee7ad73160f64e6875d2e3a1b3656ff54fc9e61e5b5ce569c00701c06b6a4358985cae74d240ae3a476168e18c4b7a977d2b10328b84cf10d282e4a6c9770a932cf1505668343c948b62d0ac6d9b3c78fcea2b3bf1a20f38409d0195200a43685197af626caa4c7c37740ed35e61b5f935c0ba924ee839c5fb8dffe2776ed650c5a01afe6398ed9cdd0af11bf69a41ea6712f5dd7cbc232060b10315509b4accf74220061ae0ec009289b75a749c38324874ad9a07e392011ad1f89d17dad0cdb728895520442c8387be274d8fbe5de016c11c1f5a772c1e4c64f95d4c43144c0974f166560ad22be85b8b81b202cb047bdd961c4b68d8958a0831b0237b47a02dfd74d60483c089f5b2d222d8b6281cd6a64cd40190fe2538e0c5f38551048fd4a1c655bf9cf2ccef9072d1d69cec482333ca30b471d57f401c359c54d0cd80e0844bfd4cb1a729955a4cb5d4d107cc2ccfcaaae76475c2583853fde19fdd4e9c8a485341b2f6d8cdee35ad628d748c84bf83c90e20d33a12a45cc89a60842c0bfbe9f3fb443cede6767291652979a299321c954e6eee37f8daeed8272ab0f8ecb7d529771418eceedf4c7e9ff84bbc51f73c1fa75414ea3efc24b97a713e85b8897f2243d51d9311f3d29a552ca34c192ce68572ff34af0ec468d14309bfb5a1632b80cc80ee5e5d40e4211103b84a9dcaa64ec6f88fe086c7b917ed80cf1edc71a5f14e6d9bd9a5853ce7233014f5b4cd34b668f78b6dc7461d0d8ed8e5c8fc1a8a296f81e1afa90233ef2937518e68818210b438dce4824bfd785ae331a366f364aabb4fcf7617c405af2baaebade00b455790950a921cb055ff15f2c6c6ca3f78fbb4edf3590c05c7ec8e7c004cecec395b70bb5c4b5c971c083d70ffde12f2f5d15f32e789aad7f6e5a8b16c91688c74900bff859d3415f457b2d2aec892b0f0195e85a766e16396f330403f266b47650920c976175d4a523d8b56df9efa6a5c383c98cfe7c8a683e25423d37b0187e9690fd7afd841dc1dd409e336ed079f34e8d0c634a3ab3693217fb45b74444f9f622eb7b710e7a3afa2f05f64c8ccae6dadbe82b5ea97a2f0560142ffc54e7a40343089ba52ae1b852d5e94ab399119ca35b6521dec4258881bedad601e226899bb0efa9240878be7d2b3f9b7bfc3df42ae86d534b3d517fa762eb7a9cc57cce9e81bac0e72f927952aae6298e7399f58861e5c90025605f53294271bdee894549b91f0470d77069577554e51893b074e48f071bb94fc29cc00c87b0a9b8ef97ef818214ac3919016b24378db72518874526f7ae2d4ca4710eb981fe0dc76d1aa0e9e9e698d9d3467181a87a09d376dee863fe45b7c964d3a4adcdce24abd4edd7e1779a45c4107b20c21d7605e375fdabb45eebee78ab2f4762ae2a3195177cee1d5f4cf49c6e19a728d4b8c6cad137b6bd9a59b4a6745dd31d08c70e4e8f1093f8684c2ea7a468d3f8ddad1023495f1a5a0deeb0acf625289e9919634349f32db207a15678d45c1fcf353c55d5217738e7d712e8c2ae200162c6780b15b3a181f63cf2b5ca64fb1273f8d5df2009cc285630c8d57b0dfef0c78dde92c34b95703d4af2d6dbbbc54a7c156a7c5f57699049a97cac259fb71cb08aed9f4b041f585e42b600958b0ce411cefbf556c2ae995f92a0bb95f59631c33945c9a064a2b787700b253ac01873cf4347e5841bcbc3f9603415c4e27050011c4fb092e22b842b95bce53e4904e0eab6ba6c7815db46080a2e361bd1bb46e4ddfa0c0534ff27ab8bfc2bf49efbedcb2e022fa4c6057b1e59652183f8e8388fa3359060db8140ec8bc93849b7ac2bfb7c29817ec9c9799243530675006847b72cf825ab585136806a054d82bb4a9bc004e78f3b61ec53425a1b6362aebdf589ba6f5d7d1a9b4ef45e6e52357d27f8b39b375046a6bfc6af59413b9058737338a0a4f2ee2e8858bbe5caa18f1c5218f2874dfea8e921f7967db184b91e066114eefd29a3821bc27e334709bbf4fd48f25b6c6084083671a5ba160e18b72ee36e2e9e9276986e4ed57454c6061cca1f284e548a4cb5043c1f3d956aa9eacf3e943cd0348c7dc58d4877b8898c88b86b36cc3d44bcb912535ab355cdd05301dd98823cd09aa1019ab1b12ac10f3e06c7705bbdd2fe20291d05f51feedf163dec43ceb3fe5bb3f2b19a567dec0a6a447230af0c10a7a6e64547de58deb64e7c8107138b130ac3599b2db3fe6bdf1f55ff2475348127c821618ab18b828d71eef3b897fbf6d61aa642da89d09c068c983b527b882267a9b5da95bef9124706aa96ef2c72bfef64947e30de286ad82c130f409fe75ed0ec111b8e359e459e6407f1fe8af43c2f52e16feca001bb2426cbe056b00b74c17585234bd2bc3f9bcb4a2d50791318d9333a934fecbe7bad54e64a86e9897a38b6a479e57cbdcdf2e5f324d4695a65ee11905e060eb20643bae2cdebb680957156b64e0f8678fab174a1b4f3f395a666d7faa78e5c9e452d5b9b0107f1a2ec3625f17b95190db761c96aabefcb9225049db1051273bd3a6bf477f62b5e5b2e5e085c5bd4e4f25bed2a27c74b2185567126611395e6473565cca22e6540a51d41f7c558c9265d305d317606495682f48ef73078b70d566c91394d42735daa902a6bcc1cb031fb8ce5453a81267a300c0d80d80e3fc74323e35e789865920343b2e331c1c8d085de7e78257b3cd1d9fd8947273de0608df5e683806435f9e68be15664a9c30b4d2f288d083f592b4f54b7d0216f7e27f2b7f2638e875b2f2808d0a7e27aa551ebf6b1458b97230f38e5fcc2524205c4e0c5c3bd899eb511e27883c16d70015aeb8c6c7aab5181ef7cd5a6c914c5f5b3d51f3c4bd8177dd1ad515306ad28f04507ec65bf521c52970f8435c267aec3fffdbf4ea842d008a49006a12b96c03c9df8b88901575fdf126e293f973129f2d3a69430f07917982d67a856e06c2e177e4a7f7d785fa9a6d9b78d2671508198abfc200d9f14c7d20d9cbaada314777ea4a97b90169f7770dce7e1e0acd081a7b7d2ceeb380e6d3da8c04621fa64f0a3e1210acf0f8015f1f853f0eb40fa27788d013c3d32e0a894b28c5ae4402e2c7726244386d245203fceb59fd5837b7f5ba43e5668f25706888b1a4507dabe950d7e864af545ff1c732e4b5517525f0ff772353ecc187f4a3b9c7ca5be070637c028c674e84116f1e9ffb9d207104c4278d785005597db954d403c864ac83ac221b4c7afe4bd8917afbb0cfb7891c0e2913eac3aff059a572b315b33ab5578b23ddff9a4da86519c3ea3d69ef50bb64c404e0b65a0d1a22929c493b47613a709c88ea9a488fff9dbe6aa5d3409f59003aed8ac8f1eec544df1570b2936929978f8b23d08b0222710db50f00751cf3d9d2c62a2a6b85a17351acadb20915a82fb007f12f759c8b04b1c5201804917f44aa801511020443a7beabe070396632cf52921a8494167332348faf850c0eefc12a725059f5be0e056fb753fccd7c5b7d40c09ebea833f73386751787f91b33a9fe5c26e0d3bbb4806908b53376edb4cd436a83f95ce2f050e902977d883f2d18898636381b39ad0a41e7dd76d516990205edd45de6bc71175202ad46b4498654a7f2507cec468b7e5fe27d628f5bdc0732d25ccff0bdde0ca09d8edb7d63bc719459d9c432d5e9cea47f6809ee15980037c6cffd2e474b7bfce0e2b6290c9f257dedc88467973d15e95bd414aefc469fa4eb8849e603d80876cb594501826806140d90e7584a2adcd3436c292c0846c3185c117eb238c85a170f49777407a68ca08e118e7aa1210cc6b9e10d579e35ff1cefb93fc2677d92ff45d885f225694c8f0de92da0b1fb625fa4d91950f5b275b1c04c42e47116ee6da0ce928097c5c3068ac31ae3ed7728d4ce6e2bf1307ebd98f78b649f8f7d4f035bfb9d0fe4ea80bee75f9dc99fbab0311218435e7a901ec4512e8ab796c46e73209868d96f5220e50a0adaf2827f95806f49c37fc88692dec6dbb4ba53469e87be8dff1c79a40be0f62668153307eabde5f030a8baa634c0bb92656f2abb7e6129da28b838bb1ba28f0039e4d05797b037330b7084ff0ec792a6c266af55430de18dbb856cbbd629c4fc7b7b06ef10e7f7b0d9715554f134d38c2bd7576a3e1b0cd1398ebc24d417a4397384ead8623269a78ca18cad2ae8658824e35e9935d2673316bc37ee5e9670e4e77e5f61657cc640dfc5ede51cfc69622cf17dbdaf9d8166e6fc8ad6efad96986b65f59c8a91421e33e7985bac25ae325761f22edc524cb23b0f3d8545b0db37ec9e45f21304a83756d6990b46df5cf5c91ccb16a921bd2a39bac75c8f772b7c9d77205c502ac6991930297c6a36959924941b33d3e140481ff78b465bcc6e19904756d74a404a2aa9e03109ac5d47193e831d069e1087bb72f36747277a022ce4f068b2f9a324d38cc21b416c23d8b7e28250612824f0e33841cd4557c3a76bdba59119431fca70ad17ddfb08895442f3f13515dc0629344b0b854455b5c4e9ebaae4d1e6cb71e0a9584d5dfbf0216161db9b0e8dfd660ad1391ae656e02024f6685eed253e2f5e1cacb7e64043492cd60f8854d4bc8cfa990efcdb7431a0eb25c9e0d280061804ee757accab652198f93ab8c5cb3a4bffb815d8d447b0428a561fc27efd89278996c38be6b1a5910b32f0ecc97f00580d0f7f90006c22bd44a8f382cc5fe145b1229fb18b643f4064b7de45b0842bbb3690faaa8c217aeefc992867afafa71749ae6df6ecb8fbeb4c7ad1ada8901b04d3d5c1a1ea383416d4177b5f4162f780236ade04e45d9a5eefd01438de80fa258774c65e69c3f5c4851e39a3501b416966a06982e18d6156b1929de3d94b746dc15009657e68843b1ab81ac26d41c61ec96bf160aceea69431435cf7d9c805889da8021fa296319b979134aa5de47ef2dd037007d545fe9096266d2849a5e3954ff22295aea2c65c07200135c315dec5d0059f3f62a8cec2c39ba0bc69f7f01afb823c6b08702da2fb9067c63ab229fa09054a6b2d87c98ecf5e55ace7c6818fb6eef55d6329b97376df20bde4324db4c27ab9d224fccbd0eed355d1b9b0504b42463b33e4e967f924538659abcbef2155b39578e8d8171a4a29504296b00726ccdbd658e69effd1251adb0be559c54806862a9dc43c715c50f6d2c26138c6d4862a929e106f842fb4992634f85181732781eddb628b10666f26a1b8bda76763705c1d3e14d96f85b8b607b7f1f10433889455f6df307e726f22e77bdb90034bbf2622888f142aea131daf1fe1ae44f8768734748042010c32f4e3231664569f5b47dd23d673b421af9b34bcafced4083537d335c7dd5d79fb29cd05b28061bdba1280393fd228e899dce76b8a5ca8949cdb8cfe83b74a5907e42509d2ede0c7bb201d25f261cfbe678136a80f23fdd592d7d83f322b91b50ae5581562c7a6f5b3c2f139cbca1c47a39101a6f0661f0e6aad39b6375bb830ae0418f63b053c0f330df62adee502a9c6926e17d84d9491c47417955273df4429ef5167267570af25301ad6fe7d6e784a4306935145c75c701d34d71af115ca1c56b2fa209d372a825831e38e955bdd5e24199e8710ef46e36d1c037719b84476235ff044d49790eb0ccbd194d4233a72cb383b94576df32b1a4d045bf0bffcbb7666a7633c4e4640fc2cfda50ca847e8bf5ed469fc1a941dfd6af862a726e3e0d4601826106167c5a81040353d56f219126717e5087e672969ee2491ff1a3c0f6080d009b0258588e426c553ec3bfed960c6b4995b8d88f5c9d80554d6c267152e188ef4f3423063d17204569f9a01ceacb13f430d9c0f1e303672c287b3f807bd16254327b8bec1908753c74846cbe4e59c1f09d69a3c890f79f26ad77a4c11ada52d3c12dd7b7fd129e5d20802b7bf2b8f3a7fccc8ed8176d288bb9e1ad875f84f60ca82b3cac5e63736557a789fbcea24d8c95bf9db8aca47e0a0903700a5a7f657db6f01c7d1d1c3f9c8ee8dcbe60166f779be5298965b21175c6db5e721befd3904e9bfa326c202b7bfaf988ca4a384c7f56f801b3098fc051a96c3d42f085e7862173731133c87f68a1c92746822cce0467639f43bacc1f6acee45b50c608a25ca2fdf5fcb62235e4e241a6e47b11d97a375f7a61eac20cdbf81f7349399e5e1cbaa88bbe95cd56a37a66fe03a77ed5edc19c648fcd4daf9ed99dde3b410eaca2c034caa44f60eaad11f5b75eb1bc405dbaf0b3a01825d4e26e36cde84d1250707d4d377dfe8cb54a1d77d2124090e4f8f19bb28bb8c6151d75621a15266cf49c21f035 Hey, password is required here.","tags":["C_Primer_Plus"],"categories":["编程"]},{"title":"ASCII, GBK, Unicode 和 UTF-8","path":"/2025/12/15/0022-unicode/","content":"在计算机中，所有的数据在存储和运算时，都要使用二进制数表示。编码是指具体使用哪些二进制数字表示哪个符号。 ASCII 码ASCII（American Standard Code for Information Interchange，美国信息交换标准代码） 使用标准的单字节字符编码方案，规定了 128 个字符的编码。（最前面的一位统一规定为 0，只使用一个字节后面的七位）。 ANSI 编码对于中文及相关字符，128 个字符显然不够，因此在 ASCII 编码方案的基础上，中国大陆地区设计了 GB系列编码；同样，世界各个国家和地区的文字都有对应的编码。这些编码兼容 ASCII，但互相之间并不兼容，微软将其统称为 ANSI编码。 在微软 Windows 系统中，ANSI 编码一般代表系统默认的编码方式，并不是确定的某一种编码方式： 在简体中文操作系统中 ANSI编码 默认指的是 GB系列编码(GB2312、GBK、GB18030) 在日文操作系统中 ANSI编码 默认指的是 Shift JIS编码 GB 系列编码GB2312GB2312 规定一个小于 127 的字符的意义与原来相同，而两个大于 127 字符连在一起时，就表示一个汉字，前面的一个字节（高字节）从 0xA1 到 0xF7，后面一个字节（低字节）从 0xA1 到 0xFE，这样就可以组合出大约 7000 多个简体汉字。 GB2312 是对 ASCII 的中文扩展。兼容 ASCII。 GBK不再要求低字节一定是127号之后的内码，只要第一个字节是大于 127 就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。 GBK 包括了GB2312 的所有内容，同时又增加了近 20000 个新的汉字（包括繁体字）和符号。 GB18030GB18030 采用多字节编码，每个字符可以由 1 个、2 个或 4 个字节组成。 UnicodeUniversal Multiple-Octet Coded Character Set, 简称 UCS，也称为 Unicode Unicode 是一个符号集，将世界上所有的符号都纳入其中，每一个符号都有独一无二的编码，规定使用 2 个字节来表示一个字符。 Unicode 没有考虑与任何一种现有的编码方案保持兼容，导致 GBK 与 Unicode 在汉字的内码编排上完全不一样，没有一种简单的算数方法可以将文本内容从 Unicode 编码和另一种编码进行转换，必须通过查表来进行。 Unicode 只规定了符号的二进制代码，并没有规定这个二进制代码如何存储。 UTF-8为了解决 Unicode 在网络上传输的问题，出现了众多 UTF (UCS Transfer Fromat) 标准，如 UTF-8 表示每次传输 8 位的数据，UTF-16 表示每次传输 16 位的数据。 UTF-8 是一种变长的编码方式，可以使用 1~4 个字节表示一个符号，根据不同的符号而变化字节长度。 对于汉字，UTF-8 编码需要 3 个字节。 相关阅读The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/","tags":["编码"],"categories":["编程"]},{"title":"PlantUML 使用记录","path":"/2025/12/04/0020-plantuml/","content":"项目地址： plantuml-serverhttps://github.com/plantuml/plantuml-server 时序图：多进程流程梳理 活动图：代码流程梳理 思维导图 使用 Docker 安装 拉取 PlantUML 的 Docker 镜像 docker pull plantuml/plantuml-server:jetty 运行 PlantUML 服务器容器 docker run -d -p 8080:8080 plantuml/plantuml-server:jetty 访问 PlantUML 服务器 通过浏览器访问 PlantUML 服务器，网址：http://localhost:8080/ 时序图注释信息note left图片代码块@startumlAlice-Bob : hellonote left: this is a first note@enduml note right图片代码块@startumlBob-Alice : oknote right: this is another note@enduml end note (多行注释)图片代码块@startumlBob-Bob : I am thinkingnote lefta notecan also be definedon several linesend note@enduml 对消息序列编号autonumber图片代码块@startumlautonumberBob - Alice : Authentication RequestBob - Alice : Authentication Response@enduml autonumber inc 要增加第一个数字，请使用：autonumber inc A 。 要增加第二位数字，请使用：autonumber inc B 。 图片代码块@startumlautonumber 1.1.1Alice - Bob: Authentication requestBob -- Alice: Responseautonumber inc ANow we have 2.1.1Alice - Bob: Another authentication requestBob -- Alice: Responseautonumber inc BNow we have 2.2.1Alice - Bob: Another authentication requestBob -- Alice: Responseautonumber inc ANow we have 3.1.1Alice - Bob: Another authentication requestautonumber inc BNow we have 3.2.1Bob -- Alice: Response@enduml autonumber stop 停止自动编号 活动图开始结束图片代码块@startumlstart:Hello world;:This is defined onseveral **lines**;end@enduml 条件判断图片代码块@startumlstartif (Graphviz installed?) then (yes) :process all diagrams;else (no) :process only __sequence__ and __activity__ diagrams;endifstop@enduml switch图片代码块@startumlstartswitch (测试?)case ( 条件 A ) : Text 1;case ( 条件 B ) : Text 2;case ( 条件 C ) : Text 3;case ( 条件 D ) :Text 4;case ( 条件 E ) :Text 5;endswitchstop@enduml 思维导图图片代码块@startmindmap* Root 1** Foo***_ 1** Bar***_ 2* Root 2** Lorem** Ipsum@endmindmap","tags":["UML"],"categories":["工具"]},{"title":"2025年终总结 (更新中)","path":"/2025/12/02/0019-2025-review/","content":"总结1月 我的第二份工作，结束了 6 个月的实习期后，在 1 月的中旬转正。 2月 去电影院看了《哪吒之魔童闹海》。 3月4月 在成都出差一个月，去了三星堆和都江堰。 5月 还完了最后一笔车贷（历时两年）。 看了一场毛不易的演唱会。 6月 6月末把旧电脑的系统刷成了飞牛 fnOS，感觉挺适合我这种普通玩家的。同时也安装了iStoreOS。 7月 7月中旬租房合同到期，感觉目前的小区环境也还可以，也懒得去找新的房子，所以又续了1年的合同。 7月下旬请了一周的假和媳妇儿去了内蒙古，好凉快。 8月NOTE:牙齿的问题一定要重视！ 前段时间有颗牙齿碎了一点，一直没有管。8月中旬发展成了牙髓炎，第一次刻骨铭心的感受到了牙疼，开始了一个月左右的根管治疗。 9月 9月底心血来潮，再次开始博客的更新。仍然使用 hexo，主题在经过对比后选择了 stellar。 10月 时隔多年，又开始看《名侦探柯南》了，之前应该是看到了基尔篇。 短暂的体验了下顺风车车主的工作，对车主来说感觉并不是真的顺风。 11月 下载了多邻国，开启每日打卡。 开始学习 ebpf 的相关内容，通读了《Learning eBPF》。 12月 找了新的房源，再次开启搬家工作。 复盘 有知有行：年终财务盘点 指引手册 关于生活关于工作美国心理学家、密歇根商学院教授诺尔·迪奇提出了关于舒适圈的行为改变三圈理论。行为改变三圈理论指出：人对于外部世界的认知，分为三个区域，分别是舒适区、学习区、恐慌区。身处不同的区域，人们的情绪感受是不一样的。当你在舒适区里，你会感到放松舒适，一切应对自如，安全可控；进入学习区，你感到了一定的压力，但总体可控，你相信只要学习提升，就能够应对挑战；进入恐慌区，则意味着你处在完全失控的区域，你感到压力山大、无力应对，内心充满了焦虑不安、紧张害怕。 上一份工作作为初入职场的新人，感觉自己一直处于恐慌区；现在的这份工作，最近给我的感觉总是处于舒适区。 关于阅读看了豆瓣的2025年度报告发现今年只读了一本书。哦，算上技术类书籍应该是两本。 不过以前好像只是在追求数量，而没有重视质量；虽然往年看的比书比今年的多，但转眼也就忘得一干二净了。","tags":["年终总结"],"categories":["复盘"]},{"title":"租房二三事","path":"/2025/12/01/0018-rent/","content":"毕业到现在租房差不多有三年半的时间，因为各种原因基本每年都会换一次地方。但被坑的比较严重的一次是帮家人短租 1 个月的单间，最后花费 1500 元左右，大概只住了不到半个月，也是目前为止唯一一次和中介打交道。 回顾几次租房经历，其实有很多需要注意的地方，比如每次找房源大概只会花一天到两天左右的时间就做决定。 最近在 v2ex 看到一份租房相关检查单，而最近又在租房，所以想整理下和复盘下租房过程中的一些注意点。 合同房东直租如果是房东直租，可以考虑使用该合同作为模版： 城镇房屋租赁合同（市场监管总局2025版）https://htsfwb.samr.gov.cn/View?id=2340996b-882d-47a4-b74d-c30784628737 中介推荐一定要把合同内容复制给豆包、DeepSeek等AI工具，让AI工具帮助我们指出合同中的一些及其不合理的条款。 结合仅有的一次和中介打交道的经历，中介公司使用的是电子合同，合同的内容冗长，且在手机屏幕上很难有效的阅读其中的内容，普通人也很难发现合同中的一些问题。 记得当时中介把合同发给家人之后，家人直接说还用看吗？谨慎起见，我通读了一遍合同内容，但还是没能看出问题。后来把合同内容发送给豆包，发现里面其实有许多及其不合理的条款，中介公司也是基于这些条款坑害租户。 可以询问豆包、DeepSeek等AI工具以下问题： 该合同是否有什么不合理的条约或要求 签约签约前，一定要核验出租人的身份证件、房屋权属证明，确认房屋属于可租赁的房屋且出租人有权出租房屋，并注意留存复印件。 租房的过程中，租客会被索要身份证复印件信息，我们也应该索要房东或中介的身份证复印件信息。还是和中介打交道那次，由于和我们见面的人属于中介的中介，所以问题出现后，我们连人也找不到，只有一个手机号（当然，是打不通的）。 租房检查单可结合实际情况进行增删和修改： 租房相关检查单https://www.v2ex.com/t/1175331","tags":["日常生活"],"categories":["V2EX"]},{"title":"VLAN","path":"/2025/11/19/0017-vlan/","content":"VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的 LAN 在逻辑上划分成多个广播域的通信技术。 VLAN 技术可以把一个物理局域网划分成多个逻辑局域网，即多个 VLAN。每个 VLAN 是一个广播域，使得 VLAN 内的主机可以互通，而 VLAN 间不能直接互通。这样，广播报文被限制在一个 VLAN 内，同时提高了网络安全性。 VLAN 标签当一个局域网被划分为多个 VLAN 时，每个 VLAN 都用一个唯一的 VLAN 标签来标识。VLAN 标签也称为 VLAN Tag 或 802.1Q Tag。 IEEE 802.1Q 标准对传统 Ethernet 帧格式进行了修改，在源MAC地址字段和协议类型字段之间加入 4 字节的 802.1Q Tag，形成了 VLAN 的帧格式。 TPID：Tag Protocol Identifier，用来判断本 VLAN 帧是否带有 802.1Q Tag，缺省取值为 0x8100，表示 802.1Q Tag 帧。 PRI：Priority，表示帧的优先级，取值范围为0-7，值越大优先级越高。用于当设备阻塞时，优先发送优先级高的数据帧。 CFI：Canonical Format Indicator，表示MAC地址是否是标准格式，取值范围为0或1，缺省取值为0。取值为0表示MAC地址以标准格式封装，取值为1表示MAC地址以非标准格式封装。 VID：VLAN ID，表示该帧所属的VLAN，取值范围为 0-4095。由于 0 和 4095 为协议保留取值，所以VLAN ID的有效取值范围为 1-4094。 数据帧分类数据帧根据是否携带 VLAN Tag，分为以下两种形式： Tagged 帧 有标记帧 加入了 4 字节 802.1Q Tag 的帧 Untagged 帧 无标记帧 原始的、未加入 4 字节 802.1Q Tag 的帧 链路类型VLAN 组网中的链路包括： Access Link 接入链路 连接不能或不需要识别 VLAN Tag 的终端设备 Trunk Link 干道链路 其上通过的数据帧都必须打上 VLAN Tag 接口类型根据对 VLAN 帧的识别情况，将接口分为以下几类： Access 接口 用来连接终端设备的接口，这些终端设备不能或者不需要识别 VLAN Tag 如果该接口收到 Untagged 帧，设备将强制加上该接口的 PVID（缺省VLAN） 如果该接口收到 Tagged 帧，只允许 VLAN ID 与接口的 PVID（缺省VLAN）相同的 VLAN 帧通过 Access 接口发送的数据帧永远是 Untagged 帧 Trunk 接口 允许多个 VLAN 的 Tagged 帧通过 该接口发送的帧，VLAN ID PVID 的是 Untagged 帧，其它 VLAN 的帧都必须是 Tagged 帧 Hybrid 接口 允许多个VLAN 的 Tagged 帧通过 在出接口方向可根据需要设置某些 VLAN 内的帧带 Tag，某些 VLAN 内的帧不带 Tag QinQ 接口 给数据帧加上双重 VLAN Tag 缺省 VLANPVID (Port Default VLAN ID) Access接口只属于1个VLAN，它的缺省VLAN就是它所在的VLAN。 Hybrid 接口和 Trunk 接口属于多个 VLAN，但是缺省VLAN只有1个，所以需要设置缺省VLAN。 同一 VLAN 内的互通同设备 VLAN 内互通用户主机 Host1 和 Host2 连接在同台设备上，属于同一VLAN2，且位于相同网段，连接接口均设置为Access接口。 H3C 交换机配置 跨设备 VLAN 内互通用户主机Host1和Host2连接在不同的设备上，属于同一个VLAN2，且位于相同网段。为了识别和发送跨越设备的数据帧，设备与设备间通过 Trunk link 连接，且允许携带 VLAN2 的报文通过。 不同 VLAN 间的互通同设备VLAN间互通（VLANIF接口）用户主机Host1和Host2连接在同台设备上，分别属于VLAN2和VLAN3，并位于不同的网段。在DeviceA上分别创建VLANIF2和VLANIF3并配置其IP地址，然后将用户主机的缺省网关设置为所属VLAN对应VLANIF接口的IP地址。 跨设备VLAN间互通（VLANIF接口）由于VLANIF接口的IP地址只能在设备上生成直连路由，当不同VLAN的用户跨多台设备互访时，除配置VLANIF接口的IP地址外，还需要配置静态路由或运行动态路由协议。 用户主机Host1和Host2连接在不同的设备上，分别属于VLAN2和VLAN3，并位于不同的网段。 主机与设备之间使用Access接口，设备之间使用Trunk接口。 在DeviceA上分别创建VLANIF2和VLANIF4，配置其IP地址为10.1.1.1和10.1.4.1；在DeviceB上分别创建VLANIF3和VLANIF4，配置其IP地址为10.1.2.1和10.1.4.2 在DeviceA和DeviceB上分别配置静态路由。DeviceA上静态路由的目的网段是10.1.2.024，下一跳是10.1.4.2；DeviceB上静态路由的目的网段是10.1.1.024，下一跳是10.1.4.1。 同设备VLAN间互通（三层子接口）用户主机属于不同的VLAN，并位于不同的网段。 其中，Host1和Host2属于VLAN2，Host3和Host4属于VLAN3，DeviceA通过以太网接口interface1与DeviceB相连。 在DeviceA的interface1上创建2个子接口interface1.1和interface1.2，并配置802.1Q封装与VLAN2和VLAN3分别对应。 配置子接口的IP地址，保证两个子接口对应的IP地址路由可达，并将用户设备的缺省网关设置为所属VLAN对应子接口的IP地址。","tags":["计算机网络","交换机"],"categories":["Linux"]},{"title":"时间轮","path":"/2025/11/13/0016-time-wheel/","content":"为什么使用时间轮基于链表排序的定时器使用唯一的一条链表来管理所有定时器，插入操作的效率随着定时器数目的增多而降低。 时间轮使用哈希表的思想，将定时器散列到不同的链表上，这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响。 时间轮的原理时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot 槽位。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用链表结构保存该时间段到期的所有任务。时间指针随着时间增加逐个slot 转动，并执行 slot 中的所有到期任务。 任务如何加入根据任务的到期时间进行取模，将任务分布到不同的 slot 中。如图所示，时间轮被划分为 8 个 slot，每个 slot 代表 1s，当前时针指向 2。 假如现在需要调度一个 3s 后执行的任务，应该加入 2+35 的 slot 中；如果需要调度一个 12s 以后的任务，需要等待时针完整走完一圈 round 后再走 4 个 slot，需要放入第 (2+12)%86 个 slot。 当时针走到第 6 个 slot 时，怎么区分每个任务是立即执行，还是需要等待下一圈，甚至更久时间之后执行呢？因此需要把 round 信息保存在任务中。 例如图中第 6 个 slot 的链表中包含 3 个任务，第一个任务 round0，需要立即执行；第二个任务 round1，需要等待 1*8=8s 后执行；第三个任务 round2，需要等待 2*8=8s 后执行。所以当时针转动到对应 slot 时，只执行 round0 的任务，slot 中其余任务的 round 应当减 1，等待下一个圈之后执行。 定时器类class tw_timer public: tw_timer(int rot, int ts) : rotation(rot), time_slot(ts), next(nullptr), prev(nullptr) private: int rotation; /* 记录定时器在时间轮转多少 round 后生效 */ int time_slot; /* 记录定时器属于时间轮上哪个 slot*/ void* user_data = nullptr; /* 客户数据 */ void (*cb_func)(void* ); /* 定时器回调函数 */ tw_timer* next; /* 指向下一个定时器 */ tw_timer* prev; /* 指向前一个定时器 */; 多级时间轮todo","tags":["时间"],"categories":["编程"]},{"title":"iptables 和 netfilter","path":"/2025/11/11/0015-netfilter/","content":"iptables 和 netfilter 是一套 Linux 防火墙组合工具，共同合作完成系统的防护工作。 iptables 是客户端工具，netfilter 是服务端程序， iptables 工作在用户态，netfilter 工作在内核态， 用户可以通过 iptables 命令作用到服务端的 netfilter，netfilter 触发相应的回调函数（hook 机制）执行相应的防护动作。 五链netfilter 是 Linux 内核中内置的网络数据包处理框架，提供了 5 个 hook 点，当网络包在协议栈中流转到这些 hook 点时，就会依次执行在这些hook 点上注册的各种规则，进而实现对网络包的各种处理。 PRE_ROUTING 通过数据链路层解包，进入网络层的数据包通过该 hook 点 所有接收数据包到达的第一个 hook 点 此处可以进行数据包目的地址转换（DNAT） LOCAL_IN 经过路由查找后，目的地址是本机的数据包，会到达该 hook 点 IP_FORWARD 进过路由查找后，目的地址不是本机地址的数据包（即转发的数据包），会到达该 hook 点 LOCAL_OUT 所有本地生成的发往其它机器的数据包，在进入网络栈后首先到达该 hook 点 POST_ROUTING 本机产生准备发出的数据包或转发的数据包，在经过路由判断后，会到达该 hook 点 四表每个 hook 点可以注册各种规则，这些规则根据用途的不同，可以分为 4 个表，分别是 raw 表，mangle 表，nat 表和 filter 表。 每个链中的表，按照下面的优先顺序进行查找匹配： raw mangle nat filter raw 表 用于决定数据包是否被连接跟踪机制处理 mangle 表 用于数据包的拆解、修改、再封装 修改包的 IP 头 nat 表 数据包的网络地址转换 filter 表 用于数据包过滤，判断是否允许一个包通过","tags":["计算机网络"],"categories":["Linux"]},{"title":"每天最重要的2小时 - 05","path":"/2025/11/05/0009-two-awesome-hours-05/","content":"对工作环境做出理性的选择，选择那些能够让我们更加专注、更加深入思考的环境。 声音对工作效果的影响一些基本的建议，能够让你在关键时刻保持专注： 一个独立的、远离噪声干扰的环境能够大大提高工作成效 如果无法离开办公环境，那就戴上降噪耳塞吧 不要听音乐或脱口秀节目 如果在家办公，就把电视关上 如果要完成的这项任务需要发挥创造力，那就不要抗拒背景噪声，可以考虑去一家忙碌的餐厅或者咖啡馆，要么放点音乐也不错 早早起床，先在家工作一两个小时，然后下午早点下班，来弥补早上在家的工作时间。 光线对工作效果的影响蓝色光和明亮的白光似乎都能增强大脑的一些功能，并帮助我们更有效地工作。 在需要有良好表现的时候，可以做一下这些事： 多开灯。 在天气晴朗时找一处有充足自然光的地方，然后在那里工作。 把灯泡换成偏蓝光的。 如果需要完成一项需要创造力的工作，把灯调暗一点，或者找个比较昏暗的角落。 可以通过以下方法对自己的办公空间做出改变： 清理杂乱无章的东西。在心理能量不足以做某些难度较高的工作时，就可以清理它们，比如下午或傍晚。 把电话、水杯或其他工作相关的物品放到桌子的四个角上。 不要在桌子边坐太久。 摆放点植物或者水景画。 想象自己正坐在桌子前一张舒服的椅子上，有足够的空间能让你把椅子往后推，把脚跷起来。做这种扩张性、开放性的姿势，并且保持两分钟，就能够提高睾丸酮水平，并较低皮质醇激素水平，这会让人们更乐意冒险。 把物品放在伸手才能够得着的地方。 在跑步机上走路或出门散个步，能够提高人们的创造力。 结论：与你周围的环境协同工作反思考研期间一直不习惯晚上熬夜，听到某个考研老师说可以不熬夜，然后早上四五点钟起床。不过现在对我来说早起似乎也有些困难。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"每天最重要的2小时 - 04","path":"/2025/11/04/0009-two-awesome-hours-04/","content":"当希望在提前安排的任务中或者某些特殊时刻达到自己最好的精神状态，利用身体活动和食物的即时反应来增强你的心理功能。 我们的身体状况可以影响到精神状况，改变你身体的感受，就有可能改变你的心理状态。 运动对精神状态的影响身体上的运动也会在短期内对你的心理表现产生作用。 运动半小时左右可以即刻且连续地提升执行功能。能够让你地注意力更加敏锐，让你更专注，让你的血糖值稳定下来，降低焦虑水平，增强积极的情绪和感受。 不论现在有没有坚持有规律地锻炼，都可以在需要的时候利用运动来提升自己的思考能力和心理能量。 一些非常有用的运动： 如果没法集中精神，就走出办公室，快速行走 30~40 分钟，上下楼梯 20~30 分钟。 把有挑战性或者会让你焦虑的会面安排到一段适中的锻炼之后。 当日程表上有项极具挑战性或者令人疲累的工作时，要么在那之前进行一场早锻炼，要么就在完成任务后立刻运动一下。 需要制造“高效两小时”的时候，就在之前的一两个小时内运动 20~40 分钟. 饮食对精神状态的影响升糖指数低的早餐更能帮助孩子们提升执行功能，而提升效果最明显的时段出现在早餐后的两个小时内。 即使是那些健康的年轻人，只要体内2%的水分流失，就会对注意力和短期记忆力造成损伤。 小贴士： 只吃半份早餐或午餐，把剩下的一半留到两个小时之后再吃。 一份富含碳水化合物的零食也许能帮助你在15分钟内集中注意力，并且让你感觉良好。 吃一些含有蛋白质、含糖指数低的碳水化合物和健康脂肪的饭菜、零食。 当你非常忙的时候，坚果是零食的最佳选择。 不要傻乎乎地大吃一顿全是由碳水化合物组成的饭。 如果在过去一两个小时内没有喝水，或者刚刚做过运动，那就赶紧喝水。 如果很疲惫或者睡眠不足，那就喝点含咖啡因的饮料，但不要喝太多。 结论：主宰自己的感受我们可以根据自己希望大脑在饮食或运动后如何运转，来决定自己要吃什么或何时运动。 反思最近总是在晚上运动完之后，就立即开始整理读书笔记。 运动后及时补水。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"每天最重要的2小时 - 03","path":"/2025/11/03/0009-two-awesome-hours-03/","content":"我们需要让自己的思绪乱飞。 大脑天生无法长时间保持专注从进化的角度来讲，如果不做到这样，我们人类就很难生存下来。 把那些没必要存在的和会让你分心的东西都拿开。 拿开办公地点的干扰物如果想要最大限度地专注于某件事， 尽量降低噪声，尽可能地关掉各种设备。 把你的设备都收起来，或者至少放在隔着几米远的地方。 没必要当个从人群中消失的隐士，只要找个办法，也许只要能让这些设备在20分钟内不会令你分心就可以。 冥想练习能够让大脑更有效地保持注意力。 走神的重要性走神对于认知性任务（创造性地解决问题和做出长远计划）有很重要的作用。 如果想要解决一些特别难的问题，不妨让你的思绪飘飞一会儿，琢磨一些难度不高又不相干的简单工作，这能帮助你找到更具有创造性的解决之道。 在专注于某个问题一段时间之后，转换到另一个从认知角度上讲难度适中的任务 – 但不能选择某个需要利用到工作记忆的任务 – 然后再转回到最初想要解决的任务。 比如： 欣赏墙上的画、房间里的植物、窗外的风景，或是你桌上的照片，注意各种颜色的深浅 整理桌面和书架，把桌子擦干净 听音乐，注意聆听这首曲子里用到了那些乐器 玩个小游戏，比如只要看到有人一边走一边发短信，就在纸上画一笔 不建议在走神时做以下事项： 整理文件 看新闻或博客 查阅和回复邮箱 排练你要演示的PPT，或者为某个会议做准备 研究一个高难度问题，比如填字游戏或者数学难题 “觉察注意力”，放任自己走神，在觉察到我们的思绪飘走了之后，再温和地把它们带回我们再眼下所进行的事情上来。 不要理会那些不能帮助你继续完成任务地想法，就像冲浪者们放弃不够合适的海浪一样。 大脑会产生各种想法，你并不需要对每个想法都做出反应。 结论：给自己一个喘气的机会反思工作时把手机放在视线外的地方。 尝试冥想练习。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"Linux 系统中常用的时间操作函数","path":"/2025/11/03/0014-time/","content":"ef77cdfd35a516030a30622d6798f966922f09fa54d377420ff3f0fc2944db5b883f34d1acc43189aad7e189bb52aa7f01f63e95133dfdb4a8517b8c8eed389ecbcc216614bf14afa2364a29099391971d3f3332d2eafe6cf0680bd7b20512ca17993dc180ec3ab0a4016db97acc4938d032726d128e25795ec607fec28a3354e1151f9a576d06bb1bea4e18df27253b711d47ea1c5e56894d52f6e9e23e417e3c7726d6bd9b3e1bef4084155c84006b5e1fbdd15584af5f991c58786d9893cd42ffe10bab0d350c6da9e8f095901620bc5b3bc65c0c35ba05eec27cfbb250ef274e716646021aedf44af33ca4561da947e6b730e3644c0f0629da552c4b460de3c28edbd6c62a6d280d413cdae9aaecdac783a65797b4c04582f4d8c96294965ebc8e42363854d4a4529037d9bafdcf5e1bcc06d404dd7c15b4474580af3f70e87ac1c593b5c08adb657f8989487e28ecda0331a402d166814102fe4c117d8cc12b2bd8769917db9916e52372eac3b49f33e086cf9abf1e1dde5c535425268a39b748cfe175fce6723cc692b830c43da307482b0ca202eb12f99193e1d1e4778232567260b72dabbce06a62c3c8f3eb266e1a41b25634d1c4e2e7e463d0398dea5fa12234c67f8ed8044616ad54fd923fb26467eeb8993de927e736e664639b82f9c836945c6ebfd0c5c1846ba36d57ddfe079d876ea6fd58799e8be728f966bb5dda97090a36b3a46ee43be1d09bac6bcb934118204142e0023492af15dfc12ca0abfd95d1318214cef542106175645eb63c0ab6e439569e58bfa5936dc5577b8fa052474331a212b8d4405a0665f8ac65894dbdd0e6400f7945a5d41383fa58d5cbd04ce173ee080d5b05542e8d4dd84cccaaa3e790c07534fc5fee5be5f480ac4f7ef2a11976ab6ef3d192f9f23078bf78038867b90b4417f3741ca0e7b74648df5030210293f4fd2f190bd85e9b521ad88db01c4ef4d2c92c2d46465678b3ddb207571da7fa51d7426ae96f800fa2cd3afaaca0e2e1d356b2245d91e2770e1c1dd88f856c41496f5a2100c5651e4efd52ce3b2a82f41eeba106ec52a917e1c0ade33a53109e3c253d56a034f3d85117482773dec2ea33bd002005d8d2e5484f6af95dec4fa7e26437ae0b61622dfd528ce3e2d1cce170db30ef1eb821438d481d7cbb55eab4a3bd98d007f986ff7a7de304b72853a7184f232abdebbf1d2e3e40bc1073f79a512442e7281f4a55c634f45d65b6a00579029459794318ed536c1ddc461d0ed85f096bc45dde5ee290f0b7cf733340b6f11143472a8eb4b883badd64363fef69e8d6d48d893de27e9bfca981036d07429d152deb3cefacf5a74a16a36a3bfed860583146168c2e4abfdf7944b82898f3ea5b5517687c812b89a481808f92f05697ce3b06b9780758b7d195ee7cc54a0edeec6024ebdd6b805ce38b340d6267aab3a63e82f996ccb943030dc822a8437c38e834f51950d74625265d1d69e60af423762e9d9adbd8d764b149da9890d61be7d39843d6339622e455c17fc88ee1844e586883d99c4775806b277f4b04f824301898f6cb2228025f7d55efbae07a4665f0f9d4033d38c28cb8e3e365cb1bffe92563049fc79eeb913b7ceb481689e664bdcc5de26c18704ee342c31d60b4c58f824d585e2a26f7bad7ff5fc76732e90a0862688130c26c58a4724cb65790142cc1b5392f5d3f63938c179565797fae36e8651660b1c38e007414735b3d509c9f8ae1ca069b4d199c2e66586283aa8bc2a375309a5fed67d17691c0e4f76997b3d2919129b546a188de468c7186f2132f458b19d4b9ad97a2844f33a7de147e33aa6cbf678f7610107fa2d5dcbc16516da19a9dd42132842895ab67c6628f8ec72064e3c34a88b4f5efaad327c5657ad2f42e5f0f106dd5728d9542b6be992c59628c08b75f16e33bdebd7160bcd9d47a1bbebe2684fa71d94b578bd9bfbee68639180fe0fdb682b68442470d6e978d43a09ab025f3d620dfc3c461559fdb21366a6d48302bc09b32779823cf5cde9edfcb2a2ce2d04217d83559dcbe226e0e1ecfc5e5d98bcc0de4c8c57d08e1aa161a0c968bf32f9b12bcc4d44ae4f2fdf27ef17519522bb81bd1e84cce07fd35d5ab5555bcdf5db8bb0d12430e091bab1e082f31cb091728aa556d59758b222a1d7293a27c6b8a8f0826d85460eef4e72a56480759a1d7e71ae5c5e073df8c64ef2d15a0f0954e6bf503c6ec47aa345e076ff1d8a7b5e8c9b536e79040eb83affc27fb80ce3e72184477a01ec42ed7bbf6b86dd23f4ad5946a62a39a62dbe78226487fbfd8faf5976f43abc013dc356ae724a9b1887f0295ff3e2b4ef491ef912776e0857ee73fbb8436e856c49fba59bfd2470032ca08001ec6a4fa9b6f8adfee825537cd51b3be57e26f7b45debdfcd89ffb7f7c294e6c326242b29102cbf65914da19a653847e3474689d21150a09043e61cc9ff1b849559b5ec51f0d4c53705a0ec49724dde5c7485f969327fb4593a31b5f1f39fc20ece38b3f393cae1acc87a29ddff8c8ce0f14fd943a9cf4e727bfc5cfdfe3196ebce955db091bf1f61748c20dd07372c90d768764af25fc4dcd341dfb520564b46d38566b92c5e991303397493ca1304d55acd7945334155398e0142d74d3e89d02e1420db9cd3bdb46303d298221cc758d408afb1ae8ff78f10e7dccac72de7a8366f2a30dbbadbc01163b35aa0f1725b0ec5724ef2d3940af5cf092eab0f47bf71cb9b0f81d93a66186f04078f5d1e0149ab9dee1904fe7b14d5b521ee9a27ebd8752888fe967cad8123d82fc44e7c1626542bfee351eb89c717784e71ef0322255be2a8de4307af0a299cb7d0ec7d5e09b9afb948e2f5b95402a3faa821fb79fdf89662a7e1201cfa3c3c26399878eda6132e765990cae9fa9a5d019135d678a549bc3be3a8fb217cd92d32f517767bbe976cfd5abbbca560ef77c7deba57d357ca291f8400dd2f056f59ca6c27ca655b654d133bcb3324551594feac06663e7e6226d2cecb9309fb241df2763622a9399a00d8ab334d83dc8b175b6627ad5919c30841881d8bfd97737b3348fdfe9257e4d056eba1334f5ef94b97f94c04f553819837b7e5ca5fb37690c45851685c6a93153fb50b20c37addbe0678d777c242af49e1e27ec931e957f8f4917f966c992212b08ad9845e50f38e80b7b2e807d07192f89a941b15ae96a40b1744a7c2e41bde9c48fcbbd4e1426ed07b7de90ff042e5a69e4f67ae34a38c50745ee2c0aed61372ea6edf355fdc40d8a3b188839fdcd0233fc788b18c737225ced709defa6793c8b26631e1a8232b1459681c8dc1cb7c66500151a6675a4fbeabcc410a4cb198f93341047100b36d090abd4eb04139a0b0ccc441569430a62a194869905cd55dabe5f9e7cac96c4d8842a2d09f230222efdf46d9d987dbc55fd43fd4ffaaba0460b78c407282917c38fdb73022e7a99adebe091da8b11fc527926180bb81baa2a00abbb651cb2a7507e1533d082f1f509ef93c86b196756b8862a99c10924df720983fe4ffe5b2674c053d6a3e4d834c9c5530431d08f20c85df2b05d21907629d0a5c051d6289988d0383b91969ff2ab17120fe25f3703df54cf2cd580aa00fb0461f6131bbedd1dc1952ba9e7739a993a82769c097e837ba68ce5e00818a7a8913211c105e757beefd58ee1bfb6e8599c57ab9817e38f8eb72ae82d811a4813693d8bf6168530ddebd8c2c6771a4d862fd86f7764f8081709f74ab76ff91e0ec66b96b7d0916bdc825e577a8c1ffc19db0d24c5e07c6a9971d2137bed9b2fd2ff3ef460fe3d7d787d21b804ee42112e4b0e3c62e89ff7ff67e831ed6d59b1fc17546c68f807c765fb30ba2dae41d7f7e7e464851524a7753d67617ffeb229cbde5da2f607581c607970850ec56726eedde02782b8583bb2f7a0631066389330fa09d8965778b09194d3bdf91ec27490ad567fdd4487a277d71a5776f807823856fde4ac641333e239951598751bb63c0ee93693ad4a34bf1b90d18226da35dfc50f01d5c5efddac0224fefe3053ff1a0d8a5bcc455bb34a8d47fe80a9de70163d7d78316e53899461f8aa6d981526acaed97e8482cc865136586e07f0a713c1d8d6733b90ab0ba19bf0cedfb07334889ce14ea9ad68d16c5ca8ab193caa33c9a8c752d6ea89d763bc652b5c896ed6bcd7e5d56ce070d9f8a49a6a38db53b762eba15fd69bc812d7bc0f1246dfa2d9300b26b3b70dd5adcacfc1a00dff01b4b973ef3c4a5d373b18b78a3badaf6e51c565f1150142cb9f49401c5906953e082bad3789a21a943c7eb0b50350c405849bb3a2e289f95fa9af0d6e5b021397b015d19f64bcaf38ac969e1cfc997410e15e1a6b19f5dd98f176ac601ae24f28ac8481afce5414977163ffeb755f254be235f2c126b5b6a2b4ce5cd46562d4a91147249ea00f636c7d31ad075766799f7a9e1170fd721d7735a76ffc7fc95323dad15aa147b2a83e01a4e6d5f3e01e18e07540bf0b05d302fc5aaf5be1311b99a4cc105d62312af31cf31b1fec608209450853abc6ed12efbea72b39bd028e07b77fce1ce40754e2d111e003f0aed56f8138d59e8889df03573dae3d162462b05bdb2b2afbaa701ef1f2efd6e7dfb58b60c9de4d72c9029c548958d2ea902d03148a9e374cd2bfeb0b82409ceea0b44e2398dd20647eaf3d42e2fd328b4b8a786ab1a7bf24ac7272325772318307432d7483a7dd95e27f7f97bf2330201f004bb3cb8d1210abfceea0162c8104e1b62a1459e05a738364144009faf62d533e8a8fdc3e8e7e25a42b7b30949c283c796bbff9c3eaa6c287c493a60c7c8a6151e885591c7dc97df259966711c1383203f0f8b81d05c16051c38d0a310e953611b76f3c8646b1eeccc851812a53351dbec29f7d95b6bc03c29ecfae502f40c2d2d3a2e500438407defb3281bdf73e202e08a44456530eb4d9f5c60f42a63e145bb228e34a2d4c5f7cd19c117cd1285f917d6542a29e823d5dee29d696a052d2d93d33a677789afd4b51c454b48f88aff5ed09f1ddb9a57610bfb53f08abe945ce5b470d258e28da5a07d76fa3e642094e93f1388861aaacd62bdee35db1e87421ea0d14ac3ead59cbc9bbe3d6c090547d5fd66c3e126a304ec0d3b722731db0027fd33ab4f39f78e00ff5cfe589507f5e6df4f0931dc3c6fc8722273fe426e63ce88c925cbe8d9a334ab773e55470065ce5b792bc0fff223671a9108e65c7f95fe57b54e292be34b84ae6be9aff4180dbd7dc1483a765ddd8524c54901beb1ef5585986abfcf6b18716aec221bd7f816d83f871e022ef6c69b5ac66867b3e19f6986f2ddabe4d130aaf92eb3e26b87de1f3fd196356a6c4c43b251546c78f5197a102ec7ae580ffe2ffe4d5b0493b8c8d96b02c98c88d8dd116497eb93e651a219d4790949f73fce87521fe9a07450e545ac68ef91c13ffaca61584b069fbc2a87849d1d81693e6f851f149206378190a2b262b071428555cc7b74f1ac4c982c1f1c08baa896309d10661fbb9db3ff14e3d2ad4e550844681c42235bea9c11c65727bda8df30fcf1ef82ff0e03298c9dcbf0be871ee09459d6ae9f604c4a2f7525a77786b27a99617f22942d88353d2a62130ce34add89451d72d958994176431472461233783af09d09bd969d904605dbaa525060ee2a5796b63495e0e126cf80cc47865d8d675e06a46e57ae40abdd381ad827f31f25811040a99a55702dedd80f734e2eaab1e040653b3d927d23c89cfe4489c17d372f5f2faf24ba009b042f8ead11585c6131f3a3db184d81ae70b56d9782c81e6203dab61b6b92b825856b1ad4ede8ad13c7144fe5f180caeae4cbfd10d2d128d220fecc2541db8895e7793f81009450c91a601bf995d45c715e94aae492e43d5c4bf74310f681d962992a5fe482d922ddbe0c59a3f7856d43bd106f36c24306f209a93028f8201b829c7e277881e8dd7af2c72c972d4a58f5b35ec83ceab2ca05f4a9fb1b0f4cc71a2f7caf8b09e509c7bf093118edbb20c66e094aa96e69aa5b0f444582075a930a79c8ffd8de832496b422d54927d2cea80ae391c07e33a95d4143c76ea30418e774ee6507907afa6cc9c84a5f35921739ff4f4d3fce6ccefed8aa33ecb5dc28a4ae3f6e795b93198a3768cbf6a5ea6b0bc4c57567bc767403c46714e882fe85c9d9e3bb106b68f506836ca7fe7c876e13f3696b49a29d6df736fb3162b157390554331015d449a587f37e9d3a976824e32c43b0b79c3de6a26a47744733e516747e7bf8804b1f79ceacef47bd3adcc99a4b07d36a1db03129bf21c9ff06616aa5e20fcd08e551c26b3583a786e6c2b274c630996f225aa79ab572018737d68dd2495a95a8f1bed48846bf3a6f9cb1086aa4ddbb1d20d5fad1394a8ba37f227901596b5b6e19155bd6771664ff9f52a2c5def8470f9e92516867d45d03a58c613c43564ce4b6e9bc18c1588ef6478c4e81078c5915f10b610e9dac36ef36b9403575429584d7c878af726e55683108f4a6de6a8e804f77e696c3c0e5c9299fccd1a16c729f3476c8a56528286b8cf5152e21dee637fc5f0151f82de2a1e02ee463dcd269328c297614e6f99539d1d5ace7ef4b5650d0764a451f79a8a8081009e1fba7cafbf40b58caf20198b3569c327904332230f9cc381b37374aaa628c69d4ec8342bf7e4b802fcb97a6cc81b98e624ffd4ac880ba1695debf4439bad2849d711f30fac699270db36aef7ddd12d7befa2a9033b4e66e8bf1bdd502105c04de27224ad1df6c0cf959bf79894048647dc5d363aed55aa4b937a2b7319b90af28518d72cf4e233355011eb8f4a05d88cfb1700a8369c271f3d8059790c004edb258edecd8a8fe8c7fff746803d92dff8e71126ea8fe8379617fc03190b4722d90c176b3ebc618db0f6943c67c9014013fff4ae18dfcdd99a53a7699dd7a38b3bc51256307dc299e95fad7c7809371e3100d698629f312bf359f9e4070f8140aa054fe2125c13962026474db4740cd29ab087786e3438409fc0ce1cf896b3736c860bd42d8326bc93b18641267273785697040233da51501d3417614520c45ec01621013dadb0ecd52e117b0e95303e25aa59d1db0ecc8b3e71f1323f2b0b265ae62fdf3a47b1f46dd6b7f4696daef79a2b28ef3a146e5a15b96af23f0524248172444dd0c92025e6727004ba77b6db0f8e3541ae81478dcdf938cef2fbea7a1be16b0de1040878280bcae443e769740b41de9815ceec4648485d493a7a903787dab64fcc89c96ce42d1f35c74b2c42a973f52b3cfe0379ad55f9cca2da5020ce94073bb219342f46aa798844c5d819534ad132dc103b0f462ca1a51411ccf5ef5ab2f7390228704d78a9160e23f1c3143b25683cf5a3f5687465d31ecb14012ab23769611fdda665e1310c871dee13e14f59631a9696f214697cf14360eff23343cef8114ed896e749482dceb8f204b0fafbf25fb7c36821f70f26c07d9648ae1634caf64dd8d4f1e3e48633ff6423b22eb599edba6b694c787f098b1a93e86ecd5ca92775eeff8224dbde636501841df7df601e8700e1e3278479c4c09ae96a988e66890a3574816b6b6b30bbd8c72ad3bebca6d2a6509ea1a5eb65fb4f5a27df567df30e71fdfda49de6bf44bf27aa053582da4110a2fae9525b2cc1c22fdae300fcef604f764b4a7f54075e8ffa2375f94fb70865fea42686640f8e23aa8eaca00f812132816f35e0d89457f8d20e1f6b546d59027a6b4c4a6a0d7f1037e451808a812e75b65064cfbd54696c9d221ced911621419173192a524075547538b223343f75980d9f651ce6e8f198c28803271259d3366789e3f5f233ee506345faa9a51ce525b77d0679bd505ce6a479a44438532941cf80aa78fb73c1df7f2b0fd05b4e31c5e6f6cbd516e9bc8aff03e294bfbdd364b8b18c916eed8790adfc2c94eba90ae67eae9c649a398f65f21d288a18b870dcae6a81171265d41945b908877eeff5e18a5d7619ca2c2d31805ed7270eb9e9aacd65e020e4d92650a23456278095123654eade37b6e534a9d3970c98cdc4b2d22e690a69f1f0ec4fb1fc5d00a05331528a001f324bd10ba705f6ccff7d02410cfea60c8a81267142fc881bbfd1b3d1fd7376fee01da21f339ee2c875876f04f95ce75f4a6e034d0fd5c2c5d42b36cdea6a4409c9fc0371da232c5317fe54f2d0d8a2b6775fd6fcf407b9709442077c1c0cbba8a2173bab915accdd5a4657702e0658dedb01d1f90de5bb5ba1fd42b5fa24c0f41f8aba7afe839441de8a7bfce16875b923450b61722dee442ba762efde94e9a83b23d92ff0ae851253b7089110a0d5cd85162cd3b6270aa05bad7e63afd1b395adfa29052c8bf85b6d5cca153e1fdbcdbf4f0b8b265ec944e106ee60875a744b2f0e599709d60b172b284808ee3782cf54876d9a50867f2a997cc0e26b0d678e34ed41227911b1560d0299620394e3ea337b6156f347ad824b446248b9be0fe68413ffbb5c25d932dd4010cc598470ad059d1426d1744f823eeb4ed04635ad02b958a4e2562a3b014027065ac01f88b89ae11e890c533de0e7cd032b1712e3c75dba7df485c7a2cad65dd9ee5f05b2c4ad33d3d1b0f5aaea4652718d78ddc93b294551bc26aeb46378705736cb9f1bc7d2244b671cfbd544d5df37ad2f0af46f04fef05731da93eb86539901f5160d2f93eb87f6233da53a0dd3900476e23d11a874cf9af3a136c0801e287898f98032b996fc03285ff94c540f4b95d88faf9f3d60d2b265c574791cc99f7dad9b69500b08ef8160c6297a34957a4cc43e9d05ac29e4249053c0dc271f4d3e07b2851804c1d8cbe798e6b3e8cbef7ca7aa4878b5bdccadc59881c70499b01bd08b2c20bea4f2dec5522ce4ee4d14183cb5d08657efcd3103924b1907d67014211d204914fc93314d6a2660800c3b1ee010cc901a9b7a0bfa2b6392e3172f582b7e6b79c1282bef68ef03209b1c2467be80aa5e434469de9dfc2d9e3b46f960709d54e94befdf8ceb1a4462740a98915528a11b38545da8ea24b3677ba04a593091449dfc99146cf13e17b5fd04a74a67daebb3d0927cf6240210971a1b8fb42c6c7005825e4eccb7bf72388be5a511c62bd06a987e50af6c02a6a10e4e6065fa7708482d0864d0de13c4c0c314a799ff44a0db502a1f93bb4c142d6d Hey, password is required here.","tags":["时间"],"categories":["Linux"]},{"title":"NTP 相关内容备忘","path":"/2025/10/31/0013-ntp/","content":"注意事项 NTP 使用 UDP 123 端口。 ntpd 既可以作为服务端程序，也可以作为客户端程序。所以当设备仅使用 NTP 客户端功能时，要在 etcntp.conf 中增加以下内容： restrict default kod nomodify notrap nopeer noqueryrestrict -6 default kod nomodify notrap nopeer noquery #针对ipv6设置# 允许本地所有操作restrict 127.0.0.1restrict ::1 配置文件etcntp.conf NTP 服务（如 ntpd）的主配置文件，核心作用是定义 NTP 服务器的运行规则，包括时间同步的来源、客户端的访问权限、安全认证方式等，直接决定 NTP 服务如何工作 etcntpkeys NTP 服务用于身份认证的密钥文件 文件中每行定义一个密钥，格式为：[密钥ID] [密钥类型] [密钥内容] $ cat /etc/ntp/keys10 M 123 密钥 ID：1-65535 之间的整数，用于在 NTP 配置中引用该密钥（如 trustedkey 1 表示信任 ID 为 1 的密钥）。 密钥类型：通常为 M（MD5 加密，最常用），也支持 S（SHA-1）等，指定密钥的加密算法。 密钥内容：由字母、数字或特殊字符组成的字符串（建议长度 8-32 位，复杂度越高越安全）。 常用命令网络抓包tcpdump udp port 123 -w ntp.pcap ntpdate 使用的是系统随机分配的空闲端口。 ntpqntpq -np ntpq -crv 查看认证状态 ntpq -c as ntpdate# x.x.x.x是 NTP 服务器的 IP 地址ntpdate -u x.x.x.x 认证相关 ntpdate -a 10 -k /etc/ntp/keys x.x.x.x 在对时间有严格要求的生产环境下，使用 ntpdate 可能会产生严重的后果。 ntpd 是步进式的逐渐调整时间，而 ntpdate 是断点更新，比如现在服务器时间是9.18分，而标准时间是9.28分，ntpd 会在一段时间内逐渐的把时间校准到与标准时间相同，而 ntpdate 会立刻把时间调整到 9.28分。","tags":["NTP"],"categories":["编程"]},{"title":"keepalived - VRRP 协议","path":"/2025/10/30/0010-keepalived-00/","content":"虚拟路由冗余协议 VRRP (Virtual Router Redundancy Protocol) 主机设备通过网关与外部网络联系，当网关出现故障时，主机设备将与外界失去联系。 VRRP 将多台设备组成一个虚拟设备，通过将虚拟设备的IP地址配置为网关，当网关设备发生故障时，VRRP 机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。 概念 VRRP 路由器(VRRP Router)：运行 VRRP 协议的设备，它可能属于一个或多个虚拟路由器。 虚拟路由器(Virtual Router): 又称 VRRP 备份组，由一个 Master 路由器和多个 Backup 路由器组成，被当做一个共享局域网内主机的缺省网关。 Master 路由器：承担转发报文任务的 VRRP 设备。 Backup 路由器：一组没有承担转发任务的 VRRP 设备，当 Master 路由器出现故障时，它们将通过竞选成为新的 Master 路由器。 VRID：虚拟路由器标识，在同一个 VRRP 组内的路由器必须有相同的 VRID。 虚拟 IP 地址(Virtual IP Address)：虚拟路由器的 IP 地址，一个虚拟路由器可以有一个或多个 IP 地址。 IP 地址拥有者(IP Address Owner)：如果一个 VRRP 设备将虚拟路由器 IP 地址作为真实的接口地址，则该设备被称为 IP 地址拥有者。如果 IP 地址拥有者是可用的，通常它将成为 Master 路由器。 虚拟 MAC 地址(Virtual MAC Address)：格式：00-00-5E-00-01-{VRID} (VRRP for IPv4); 00-00-5E-00-02-{VRID} (VRRP for IPv6)，其中 00-00-5E 是 IANA 组织分配的，00-01 是为 VRRP 协议指定的，VRID 是虚拟路由器标识，取值范围为[1-255]。当虚拟路由器回应 ARP 请求时，使用虚拟 MAC 地址，而不是接口的真实 MAC 地址。 非抢占方式：如果 Backup 路由器工作在非抢占方式下，只要 Master 路由器没有故障，Backup 路由器即使被配置了更高的优先级，也不会成为 Master 路由器。 抢占方式：如果 Backup 路由器工作在抢占方式下，当它收到 VRRP 报文后，会将自己的优先级与通告报文中的优先级进行比较。如果自己的优先级更高，就会主动抢占成为 Master 路由器。 VRRP 路由器的优先级0优先级为 0 用于指示当前虚拟路由器的 Master 路由器停止参与 VRRP 组。主要用于触发 Backup 路由器快速地迁移到 Master 路由器，而不用等待当前 Master 路由器超时。 255如果 VRRP 路由器是虚拟路由器地址的IP地址拥有者，那么其优先级必须为255。 1-254Backup 路由器的优先级必须在1–254之间。缺省的 VRRP 路由器优先级为100。 典型组网案例主备备份业务仅由 Master 路由器承担，当 Master 路由器出现故障时，才会由选举出来的 Backup 路由器接替它工作。 负载分担在路由器的一个接口上可以创建多个虚拟路由器，使得该路由器可以在一个虚拟路由器中作为 Master 路由器，同时在其它的虚拟路由器中作为 Backup 路由器。 为了实现业务流量在 Device A、Device B 和 Device C 之间进行负载分担，需要将局域网内的主机的默认网关分别设置为虚拟路由器1、2和3。 在配置优先级时，需要确保三个虚拟路由器中各路由器的 VRRP 优先级之间形成一定的交叉，使得一台路由器尽可能不同时充当 2 个 Master 路由器。 keepalived 阅读材料 HUAWEI: VRRP配置","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"每天最重要的2小时 - 02","path":"/2025/10/29/0009-two-awesome-hours-02/","content":"我们的大脑能量是驱动我们行为的燃油，如果没有了它，我们就寸步难行。 什么会让你心理疲惫“执行功能”指的是大脑所拥有的各种控制和决定方向的功能。大脑的执行功能包括做出决定、做计划，必要的时候，还要短暂地记住一些想法。 进行自我控制往往会削弱我们的自控力。当进行自控行为之后，我们的这部分大脑功能往往会显得疲惫。 即使是做一些典型的、日常的、不重要的决定，也会让人在接下来的自控性任务中缺乏动力。 情绪决定你的表现情绪能够帮助我们解决和应对眼前的情况。 愤怒或不快能够让我们积极应对某些特定的想法和行动。下一次，如果你明知冒这个险才是正确的，却又不敢冒险，不妨让自己愤怒起来。 当我们感到悲伤时，往往会在做决定时尽量少带成见。 焦虑是一种能让我们高度警觉、对任何突发状况做好准备的情绪。 如果想让自己在那些不太重要的事情上放开手，如果要发挥自己的创造力，如果需要做出迅速的决定，试试带着积极的情绪去面对。 如何管理心理能量首先要分辨出那些工作最容易极大地消耗你的心理能量。在进行需要自己百分百投入的工作之前，一定要尽可能地避免做那些消耗心理能量的事情。 如果你在做完某项任务之后觉得很累，很有可能就是它让你消耗大量的自控力。 试着做一做下面这四件事： 早上第一件事（真正的第一件事，在看任何社交媒体之前）就是完成你最重要的工作。想想你自己手头上最具创造性、最有意思的工作，或者长远来看最有益的工作是什么，然后在早晨花一两个小时去做。 考虑一下今天所有的待办事项，把他们分类为重要的、创造性的、其他。在一天中较晚的时候完成其他分类里的工作。 试试在下午花上一个小时阅读并回复你的电子邮件。 在第二天有重要活动时，头天晚上就提前做一些决定，比如穿什么，早餐午餐吃什么，也可以是重要的决定。 迅速补充心理能量的三种方法： 缓慢地深呼吸一会儿。 尽情地大笑一场，积极的情绪可以为我们“充电”。 短暂地打个盹儿。10分钟的短暂睡眠能够帮助缓解疲劳，还能够提升警觉度以及许多不同的认知功能。 有时候果断地放弃一些事，以保证自己在最重要的时刻拥有良好的状态，对我们而言或许更有帮助。 为了真正利用好你的心理能量，你需要做的是出色地完成事关紧要的工作，而不是平庸地完成所有的工作。 结论：让你的效率达到最大化下一次，如果你发现自己正处于抉择点，能够开始一项新任务时，请务必回顾一下：刚刚完成了那些任务？大脑是否已经因为做出了太多决定而疲惫不堪？目前的情绪如何？它们有没有影响到你的下一项任务？ 反思Dan Koe 的视频中确实也有提到愤怒的情绪的作用。 某天，我发现折腾博客的个性化配置会让我很累。 时间管理不是把日程塞满。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"keepalived - VRRP 同步","path":"/2025/10/28/0010-keepalived-03/","content":"Keepalived 的 VRRP 同步功能（即同步组，sync groups）解决了复杂网络环境中的一个关键问题：在此类环境中，多个 VRRP 实例可能需要维持状态一致性。若缺乏同步机制，各个 VRRP 实例会各自进行独立的状态转换，这可能导致 “脑裂”（split-brain）场景或路由路径不一致的问题。 keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"Source Insight 配置记录","path":"/2025/10/28/0012-source-insight/","content":"快捷键 F5: 跳转到指定行 F8: 高亮选中 Ctrl + /: 全局搜索 Source Insight 的两种高亮方式1. 自动高亮（鼠标点击高亮） 打开选项设置：在菜单栏中选择 Options File Type Options…。 勾选高亮选项：在弹出的窗口中，找到并勾选 Highlight references to selected symbol 选项。 效果如图 2. 快捷键手动高亮 选中要高亮的部分，点击 F8 效果如图","tags":["SourceInsight"],"categories":["工具"]},{"title":"keepalived - VRRP 调度器","path":"/2025/10/28/0010-keepalived-02/","content":"代码版本： https://github.com/acassen/keepalived/releases/tag/v1.1.12 Socket Pool套接字池（Socket Pool）为虚拟路由冗余协议（VRRP）实例高效管理网络通信，可在合适的情况下允许多个实例共享套接字。 vrrp_dispatcher_init创建和申请一个 socket pool。 假设有 n 个网卡。每个网卡最多有 2 个 fds（1个用于 VRRP，另一个用于 IPSEC_AH）。所有的 VRRP 实例都通过这些文件描述符（fds）实现多路复用。因此，我们的设计可支持 2×n 个多路复用节点。 fd1 fd2 fd3 fd4 fdi fdi+1-----\\__/--------\\__/---........---\\__/--- | ETH0 | | ETH1 | | ETHn | +------+ +------+ +------+ 多个 VRRP 实例不单独占用套接字，而是共享一组 fds 资源，通过操作系统的 IO 多路复用技术（如 Linux 的epoll、BSD 的kqueue）实现对多个实例通信需求的并发处理，最终达成 “用少量 fds 支持大量实例” 的高效设计目标。 vrrp_create_sockpool为 VRRP instances 创建 sockets 结构 vrrp_create_sockpool(vrrp_data-vrrp_socket_pool) for(e : vrrp_data-vrrp_socket_pool) alloc_sock MALLOC vrrp_open_sockpool开启物理 sockets vrrp_open_sockpool(vrrp_data-vrrp_socket_pool) for(e : vrrp_data-vrrp_socket_pool) sock_obj = ELEMENT_DATA(e); sock_obj-fd_in = open_vrrp_socket(); socket(AF_INET, SOCK_RAW, proto); sock_obj-fd_out = open_vrrp_send_socket(); socket(AF_INET, SOCK_RAW, proto); vrrp_set_fds为 VRRP instances 分配合适的 sockets vrrp_set_fds(vrrp_data-vrrp_socket_pool) for(e : vrrp_data-vrrp_socket_pool) vrrp-fd_in = sock_obj-fd_in; vrrp-fd_out = sock_obj-fd_out; 通告处理VRRP 调度器处理传入的 VRRP 通告，并根据实例的当前状态对其进行处理： 代码流程vrrp_read_dispatcher_thread vrrp_dispatcher_read /* read affect received buffer */ read(fd, vrrp_buffer, VRRP_PACKET_TEMP_LEN); /* Searching for matching instance */ vrrp = vrrp_index_lookup(hd-vrid, fd); /* Run the FSM handler */ prev_state = vrrp-state; VRRP_FSM_READ(vrrp, vrrp_buffer, len); /* MASTER */ vrrp_leave_master vrrp_state_master_rx /* Process the incoming packet */ ret = vrrp_check_packet(vrrp, buf, buflen); if (Lower priority) vrrp_send_adv(vrrp, vrrp-priority); vrrp_send_gratuitous_arp(vrrp); return 0; else vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); vrrp-wantstate = VRRP_STATE_BACK; vrrp-state = VRRP_STATE_BACK; return 1; /* BACKUP */ vrrp_backup vrrp_state_backup if(Higher priority) vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); else vrrp-wantstate = VRRP_STATE_GOTO_MASTER; vrrp_send_adv(vrrp, vrrp-priority); vrrp_send_adv VRRP 协议报文封装在 IP 报文中，发送到分配给 VRRP 的 IP 组播地址 在IP 报文头中 源地址为发送报文接口的主 IP 地址 目的地址为 224.0.0.18 TTL 必须是 255。（VRRP 路由器会丢弃 TTL 不等于 255 的 VRRP 协议报文） 协议号是 112 /* send VRRP advertissement */vrrp_send_adv /* build VRRP packet */ vrrp_build_pkt(vrrp, prio) /* build IP header */ vrrp_build_ip ip-ttl = VRRP_IP_TTL; ip-protocol = (vrrp-auth_type == VRRP_AUTH_AH) ? IPPROTO_IPSEC_AH : IPPROTO_VRRP; ip-saddr = VRRP_PKT_SADDR(vrrp); ip-daddr = htonl(INADDR_VRRP_GROUP); /* checksum must be done last */ ip-check = in_csum((u_short *) ip, ip-ihl * 4, 0); /* build the vrrp header */ vrrp_build_vrrp(vrrp, prio, vrrp-send_buffer, vrrp-send_buffer_size) keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"Linux 进程间通信：共享内存","path":"/2025/10/27/0011-ipc-shm/","content":"头文件 sys/shm.h shmget 创建共享内存 第一次创建完共享内存时，它还不能被任何进程访问 int shmget(key_t key, size_t size, int shmflg); shmat — at：attach 启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间 void *shmat(int shm_id, const void *shm_addr, int shmflg); shmdt — dt：detach 将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用 int shmdt(const void *shmaddr); shmctl — ctl：control 控制共享内存 int shmctl(int shm_id, int command, struct shmid_ds *buf);","tags":["进程间通信"],"categories":["Linux"]},{"title":"keepalived - VRRP 状态机","path":"/2025/10/27/0010-keepalived-01/","content":"代码版本： https://github.com/acassen/keepalived/releases/tag/v1.1.12 VRRP 状态机VRRP_FSM Read_to: read timeout struct void (*read) (vrrp_rt *, char *, int);\tvoid (*read_to) (vrrp_rt *); VRRP_FSM[VRRP_MAX_FSM_STATE + 1] =/* Stream Read Handlers | Stream Read_to handlers * *------------------------------+------------------------------*/\tNULL, NULL,\tvrrp_backup, vrrp_goto_master,\t/* BACKUP */\tvrrp_leave_master, vrrp_master, /* MASTER */\tvrrp_leave_fault, vrrp_fault, /* FAULT */\tvrrp_become_master, vrrp_goto_master\t/* GOTO_MASTER */; VRRP FSM Macro/* VRRP FSM Macro */#define VRRP_FSM_READ_TO(V) \\do \\ if ((*(VRRP_FSM[(V)-state].read_to)))\t\\ (*(VRRP_FSM[(V)-state].read_to)) (V);\t\\ while (0)#define VRRP_FSM_READ(V, B, L) \\do \\ if ((*(VRRP_FSM[(V)-state].read))) \\ (*(VRRP_FSM[(V)-state].read)) (V, B, L);\t\\ while (0) VRRP_TSM当某个 VRRP 实例发生状态变更，且需要与其同步组（sync group）内的其他实例进行协调时，将使用 VRRP_TSM 。 使用方式可以理解为：VRRP_TSM[from_state][to_state] struct void (*handler) (vrrp_rt *); VRRP_TSM[VRRP_MAX_TSM_STATE + 1][VRRP_MAX_TSM_STATE + 1] =/* From: To: BACKUP MASTER FAULT *//* v */ NULL, NULL, NULL, NULL ,/* BACKUP */ NULL, vrrp_sync_master_election, vrrp_sync_master, vrrp_sync_fault ,/* MASTER */ NULL, vrrp_sync_backup, vrrp_sync_master, vrrp_sync_fault ,/* FAULT */ NULL, vrrp_sync_backup, vrrp_sync_master, vrrp_sync_fault ; VRRP TSM Macro#define VRRP_TSM_HANDLE(S,V) \\do \\ if ((V)-sync \\ S != VRRP_STATE_GOTO_MASTER) \\ if ((*(VRRP_TSM[S][(V)-state].handler)))\t\\ (*(VRRP_TSM[S][(V)-state].handler)) (V);\t\\ while (0) 状态图 初始化期间，从 INIT（初始化）状态开始 若所有检查均通过，则转换至 BACKUP（备份）状态 若未从优先级更高的主用（MASTER）设备接收到通告消息，则转换至 MASTER（主用）状态 若接收到优先级更高的通告消息，则转换至 BACKUP（备份）状态 若任何被跟踪的资源发生故障，则转换至 FAULT（故障）状态 当故障条件清除后，返回至 BACKUP（备份）状态 INIT 状态/* Initialize state handling */static voidvrrp_init_state(list l) for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) vrrp = ELEMENT_DATA(e); if (vrrp-priority == VRRP_PRIO_OWNER || vrrp-wantstate == VRRP_STATE_MAST) vrrp-state = VRRP_STATE_GOTO_MASTER; else vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); vrrp-state = VRRP_STATE_BACK; BACKUP 状态 当处于 BACKUP（备份）状态时，该实例会设置一个 master_down_timer（主用设备下线计时器）。 每当从优先级更高的主用（MASTER）设备接收到有效的通告消息（advertisement）时，此计时器就会重置。 若计时器超时（即在超时周期内未接收到任何通告消息），该实例将转换至 MASTER（主用）状态。 /* Handle dispatcher read timeout */static intvrrp_dispatcher_read_to(int fd) /* Run the FSM handler */ prev_state = vrrp-state; VRRP_FSM_READ_TO(vrrp); // vrrp_goto_master /* handle instance synchronization */ VRRP_TSM_HANDLE(prev_state, vrrp); MASTER 状态 拥有并维护虚拟 IP 地址（VIPs）。 按照配置的时间间隔发送定期的 VRRP 通告消息。 处理接收的 VRRP 通告消息，若接收到优先级更高的通告消息，该实例将转换至 BACKUP 状态。 static voidvrrp_master(vrrp_rt * vrrp) if (vrrp-state == VRRP_STATE_MAST) vrrp_state_master_tx(vrrp, 0); FAULT 状态由于出现错误条件，该 VRRP 实例无法以 MASTER（主用）或 BACKUP（备份）状态正常运行。 keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"每天最重要的2小时 - 01","path":"/2025/10/21/0009-two-awesome-hours-01/","content":"意识到每天的关键时刻–抉择点我们一旦开始了一项神经性常规活动，就会像电脑程序一样一直运行下去，直到完成任务，或是被打断。 实际上，每一天都是由一系列习惯性的神经常规程序组成：早上起床、穿好衣服去上班、打开电脑、回复电子邮件等。问题在于，我们经常会从一个任务跳到另一个任务，却不仔细想想下一步最好该做什么。 学会意识到一天的当中的几个特殊时刻，在这种时刻，你有机会也有能力决定自己将如何度过接下来的时间。 做出最恰当的选择当常规程序结束的时候，自我意识就会浮现出来。意识最重要的功能就是在我们的自动式神经常规活动遇到困难的时候做出决定。 抉择点通常是作为冲突–无意识的自动行为之间的冲突、行为和目标之间相冲突–的结果而出现的。正因为这些抉择点会令人不舒服，我们往往才选择尽快跳过它们。 忽略抉择点的坏处匆忙跳过抉择点，很可能接下来进行的任务并没有那么重要，或是不适合在这段时间完成，损失也许会更大。 充分利于抉择点的三个诀窍在这一刻，对我们而言究竟什么最为重要。 珍惜每一个抉择点 意识到抉择点的出现，并尽力抓住它；要承认它的存在，而不是无视它，一头扎进无意识思维指引你去做的下一个任务里。 抉择点能够让你与眼下最关注的事保持一定的“距离”。 提前为抉择点做好相应计划 “计划不去做某件事”常常会失败，关键的一点是，你做的计划要让自己在这一刻进行一项新的活动–一项你乐意做的事。 当我们在脑海中设想某一个行动时，所利用的神经回路其实和真正去做这件事时的神经回路相同。 不要随便开始一项新任务，除非已经有意识地决定了它确实值得做。 一旦你完成一项任务，不要去想接下来自己可以是轻松地做些什么，而是把这一刻标记为抉择点。 怎么决定什么事最值得花时间？判断依据之一就是自己当天最重要的任务。 结论：聪明地安排你的时间用途在完成不同任务的间隙之间，我们终于从忘我工作的状态中脱身而出，这些时刻实在是不可多得的礼物，而我们完全应该审慎地利用这些时刻。 反思 早上睡醒之后，会无意识的在社交软件，购物软件之间来回跳转。（睡前将手机放在客厅。） 下班前会突然冒出不想运动的想法。（想象下班后运动的过程。） 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"孕期检查备忘录","path":"/2025/10/20/0008-pregnancy-checklist/","content":"名词解释13+6医生关于孕期的常用描述，13 是指第13周，+6 则指的是第6天，比如 NT 检查需要在 11 到 13+6 这段时间进行，意思就是需要在第11周到第13周的第6天之间的这段时间进行。 重要时间节点NT 检查 时间：孕11周到孕13+6周 通过B超检查胎儿颈项透明层的厚度。 建档（母子健康手册） 时间：孕12周 一本粉红色的小册子，需要保留到孩子上学。 建档需要进行抽血检查，所以当天早上记得不要吃早饭。建档之后，需要按照时间要求，定期到医院进行孕期检查。 准生证（生育登记证明） 时间：怀孕3个月后 准生证应该是计划生育时期的叫法，现在应该都是通过各地的相关公众号进行的。 唐氏筛查 时间：孕15周到孕20周（以医生建议为准） 用于评估胎儿患有唐氏综合征的风险。 四维彩超 时间：孕22周到孕26周（以医生建议为准） 实时三维超声，是在二维超声的基础上，通过技术处理而形成的形象直观的动态立体图像。 糖耐 时间：孕24到孕28周（以医生建议为准） 葡萄糖耐量试验（OGTT），简称糖耐。检查时会让准妈妈喝葡萄糖水来模拟一顿饭摄入的糖量，从而检测胰岛功能，排查妊娠期糖尿病。","categories":["生活记录"]},{"title":"顺风车车主初体验","path":"/2025/10/19/0007-hitch/","content":"更新记录：2025-10-28：偶然看到保险会以非运营车辆进行营运拒赔的说法，所以最终还是把所有平台注册的顺风车给注销了，避免不必要的麻烦吧。 在国庆节的末尾进行了爱车的第4次保养，我已有两年的驾龄，由于最近经常需要在周末开车往返于两地，所以下定决心跑一下顺风车平摊路费。 在没有注册成为顺风车车主之前的想法是顺路了就接一单，实在没有就算了，也不指望创收；但在成为车主之后，我的行为竟然瞬间出现了变化，我发现自己早早的发布了几天之后的出行信息，开始频繁的查看三个平台寻找合适的乘客，在乘客莫名其妙的取消订单之后觉得失落，在没有订单的情况下觉得要不再等等看有没有合适的。 在体验了一次顺风车车主的行程之后，我发现与我希望的方式（不接不送，顺路上下）不同，无论是高德、哈啰，还是滴滴，都需要车主按照乘客指定的起点和目的地进行接送。 因此我决定记录并提醒一下自己跑顺风车的最初想法和要求： 不需要跑顺风车创收，有合适的就跑，没有也无所谓 三环以内的订单不接（感受过市区下班高峰期之后的第一个决定） 距离我的起点和终点超过10公里的订单不接 每周五查看平台信息即可 接单后，及时与乘客电话沟通确认 除了上述提到的三个平台之外，在我的城市还有一个公众号平台，早期我也确实作为乘客体验过三四次，这个公众号上车主发布自己的具体行程，乘客依据自己的出行需求选择合适的订单，并主动与车主电话沟通。 哦，对了，那顺便说一下三个平台的逻辑， 高德：车主端可以看到乘客发布的行程；乘客也可以看到车主发布的行程；双方可以根据行程信息相互进行邀请 哈啰：暂时没有体验到 滴滴：乘客发布自己的行程，但看不到车主发布的行程，只能被动等待；需要车主依据自己的行程选择合适的订单 对比下来，我更喜欢高德的顺风车方式，不过感觉好像滴滴上的订单更多。","tags":["顺风车"],"categories":["生活记录"]},{"title":"结构体的内存对齐和变长数组","path":"/2025/10/15/0006-c99-vla/","content":"引入项目中业务模块产生的日志在通过本地 socket 发送给日志模块后，日志模块记录的内容总是会丢失前6个字节。经过排查，业务模块和日志模块使用的虽然都是 log_msg_t 结构体，但结构体中的变量类型定义却略有差异，如下所示： 业务模块的结构体定义 typedef struct\tunsigned char type;\tunsigned char level;\tunsigned short size;\tunsigned int pid;\tunsigned int cds;\tunsigned char imm;\tunsigned char u8wf;\tunsigned char data[]; log_msg_t; 日志模块的结构体定义 typedef struct\tunsigned char type;\tunsigned char level;\tunsigned short size;\tunsigned int pid;\tunsigned int cds;\tunsigned char imm;\tunsigned int u8wf;\tunsigned char data[]; log_msg_t; 显然，由于结构体中 u8wf 变量类型的不同，导致出现了内容丢失。但 unsigned char 的大小为1个字节，unsigned int 的大小为4个字节，怎么会出现丢失6个字节的内容呢，这与结构体的内存对齐有关。 内存对齐为什么需要对齐在 C 语言中，结构体的内存对齐是编译器为了提高 CPU 访问内存效率而采取的一种内存布局优化策略，是一种拿空间换时间的做法。 CPU 访问内存时并非逐个字节读取，而是按固定大小的 “块”（如 4 字节、8 字节）读取。如果数据的起始地址是块大小的整数倍（即 “对齐”），CPU 可以一次完成读取；否则可能需要多次读取，影响效率。 内存对齐规则 第一个成员在与结构体变量偏移量为 0 的地址处。 其他成员变量的起始地址必须是 min(该成员自身大小, 编译器默认对齐数) 的整数倍。 结构体的总大小必须是所有成员中最大对齐值的整数倍，即 min(结构体中最宽成员类型的大小, 编译器默认对齐数) 的整数倍。若不足，编译器会在最后一个成员之后添加填充字节以满足此要求。 练习下面两个结构体的大小分别为多少？ typedef struct\tchar c1;\tint i;\tchar c2; S1;typedef struct\tchar c1;\tchar c2;\tint i; S2; S1 和 S2 的内存布局如下图所示: 相关函数sizeof 获取结构体的大小 printf(%ld , sizeof(S1));printf(%ld , sizeof(S2)); offset 宏 计算结构体中某变量相对于首地址的偏移 头文件: #includestddef.h printf(offsetof(S1, c1) = %ld , offsetof(S1, c1));printf(offsetof(S1, i) = %ld , offsetof(S1, i));printf(offsetof(S1, c2) = %ld , offsetof(S1, c2)); #pragma pack() 修改默认对齐数（谨慎操作） // 将默认对齐数修改为 8#pragma pack(8)typedef struct\tchar c1;\tint i;\tchar c2; S1;// 恢复默认对齐数#pragma pack() TIPS在设计结构体的时候要满足对齐规则，又要节省空间，如何做到呢？ 在定义结构体时，将大小相同或相近的成员声明在一起，并且按照从大到小（或从小到大）的顺序声明，可以最大限度地减少填充字节，节省内存。 可变长数组此外，可以看到 log_msg_t 的最后一个元素为 data[], 且如果使用 sizeof(log_msg_t)，可能会发现结果并不符合预期，这一切都与可变长数组的特点相关。 介绍变长数组是在 C 语言的 C99 标准中引入的新特性。结构体中的最后一个元素允许是大小未知的数组。 比如： struct S int n; int arr[]; // 部分编译器可能会报错，可以将 arr[] 改为 arr[0]; 特点 结构体中的可变长数组前面必须至少有一个其它类型的成员。 可变长数组必须是结构体的最后一个成员。 可变长数组不占用结构体的存储空间，使用 sizeof 计算结构体的大小不包含可变长数组成员。 结构体变量相邻的存储空间保存的是可变长数组的内容。 log_msg_t因此，两个模块使用的log_msg_t结构体的内存布局如图所示: 可以看到两个结构体的 data 成员相对于起始地址的偏移量相差 6 个字节，这也就是为什么日志模块记录的内容总是会丢失前6个字节。 优势使用指针struct S int n; int *arr;; 那么在使用时就需要两次 malloc 和两次 free， struct S *ps = NULL;// 动态分配结构体S的内存空间ps = (struct S*)malloc(sizeof(struct S));if (ps == NULL) return -1;ps-n = 10;// 为结构体中的数组成员分配内存ps-arr = (int*)malloc(ps-n * sizeof(int));if (ps-arr == NULL) free(ps);\tps = NULL;\treturn -1;// do something // 释放所有动态分配的内存free(ps-arr);ps-arr = NULL;free(ps);ps = NULL; 使用可变长数组struct S int n; int arr[0];; 使用时只需要一次 malloc 和 free， // 分配内存以容纳结构体S和10个整数的数组struct S *ps = (struct S *)malloc(sizeof(struct S) + sizeof(int) * 10);if (ps == NULL) return -1;ps-n = 10;// do something // 释放分配的内存并置空指针free(ps);ps = NULL; 总结使用指针： 为了防止内存泄漏，如果分两次分配结构体和缓冲区的内存，当第二次 malloc 失败时，必须回滚释放第一次分配的结构体内存。 进行了两次 malloc，需要对应两次 free，如果我们的代码是在一个给别人用的函数中，我们在函数里做了两次内存分配，并把整个结构体返回给用户；虽然用户调用 free 可以释放结构体，但用户并不知道结构体的成员也需要 free，造成内存泄露。 malloc 次数越多，产生的内存碎片就越多，内存的利用率就会降低。 使用变长数组： 连续内存有利于提高访问速度，同时减少内存碎片","tags":["C语言"],"categories":["编程"]},{"title":"我的影视资源解决方案","path":"/2025/10/15/0005-emby/","content":"影视资源站最初主要在一些影视资源站看视频，比如在在线之家看完了全季的《权力的游戏》。 以下是几个仍保留在收藏夹中的资源站： 低端影视 在线之家 NO视频 网盘网盘在很长时间里都是我获取影视资源的主要阵地，从百度网盘、谷歌云盘、阿里云盘，到现在主要使用的夸克网盘。在阿里云盘开始收费后，我发现88VIP会赠送1年的夸克网盘会员（此时，我已持有88VIP将近半年的时间）。 夸克网盘会员(88VIP版)有6TB的存储空间，且在电视上有对应的客户端，几乎满足了我所有的观看需求，但影视墙功能仍需付费开通SVIP才能使用。不过，最近在折腾飞牛OS里提供的飞牛影视可以挂载夸克网盘，并且能够进行直链播放，也是一种免费使用影视墙的解决方案。 PS: 88VIP还提供1年的优酷会员或芒果会员，应该已经能够满足大部分的观影需求。 以下是几个我目前常用的网盘资源搜索网站： 云盘盘 SeedHub 夸克盘 EmbyEmby 在我看来是强者的存在，几乎可以替代爱优腾和各种流媒体平台。互联网上有大量的公益服和付费服，我记得最早使用的是叫做普拉斯影业的公益服，不过目前好像已经不能使用了。 以下是一个关于 Emby 的介绍视频，部分信息已过期，不过有助于你简单了解 Emby。"},{"title":"家庭网络折腾备忘录","path":"/2025/10/14/0004-cucc-modem/","content":"002a748617e5cc304f438c1409bd96526eb4ad4593d4d71e04e8698e3520de0cf8e5545d3a653be200d7127a72677075b27591933b5624dc42316f783c49f5b39cbe5476d1a3a35076c86152eb558d28c39678e517a24164134ed90692d8bcc00395ead76bb9bf955b19704afa3fb2075cb8988f8d95f0d888ee1b9577408744a705fd6d0008bb468613f9e3165557b4881365223a42ae4d5cda13bc70d5f635bc2932f657c2a25e8aac2cf984edcdbd4f56c4da662c37bea241d1efb52c41221c8e663eac64dc536ef2ed9c1315f235e1631b7eb9ad79cf3f1eb466e1d4ea8dd90ccf78a7ff9632a3b584aede277aeec0cf8c338b321fbeaeb833eb5cd5ff1bf6572b52d008132cb3b4a66efdd439eb75e56f271a6d2ff57e84ab760f4d279279cd828a918447fbfceaafbdb556a2513d4629afbba1ffd5b520a690fff390570a8febcf3bdf62b223a4f032ac02c0d731011c6c1bf4cd79f1596d484a6e477183ef99d4f92e03028d4cc176033163aa1f1c5bb1922adcaeaaf03538658f4c223c21e0f7f985e9032730a942ff60c5619f4f344dac000b70427f472ed7b2225d4195a28db1ad60db56a6dcc178a3325542a44e652800c9212138c3c29916fc9ce344bb42d2e54c6f91a678bd9fd8844ab925b7210a19b05d6fd1d7a3f282927cb658efa98d9547e0ebc4a5da9de7ccf847aeca4c67a77e23bb5855dd8d3391a457c7d1918d32545e6a9ef5ea30c2b9758fbd83455d0ef7a69f489d8b95c29122a21bd94b572a99e28766ea16801946cc Hey, password is required here.","tags":["光猫","路由器"],"categories":["网络"]},{"title":"Hello Stellar","path":"/2025/09/30/0003-hello-stellar/","content":"安装主题在根目录执行如下命令： npm i hexo-theme-stellar 主导航栏根目录下的 _config.stellar.yml # 侧边栏主功能导航菜单menubar: columns: 4 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 # - id: post # 页面中高亮的 menu_id # theme: #1BCDFC # 高亮时的颜色，仅 svg 中 fill=currentColor 时有效 # icon: solar:documents-bold-duotone # 支持 svg/img 标签，可以定义在 icons.yml 文件中，也支持外部图片的 URL # title: 博客 # 标题 # url: / # 跳转链接，支持相对路径和绝对路径 # - id: wiki # theme: #3DC550 # icon: solar:notebook-bookmark-bold-duotone # title: 文档 # url: /wiki/ # - id: explore # theme: #FA6400 # icon: solar:planet-bold-duotone # title: 探索 # url: /explore/ # - id: social # theme: #F44336 # icon: solar:chat-square-like-bold-duotone # title: 社交 # url: /friends/ 文章模版根目录下 scaffolds 文件夹中编辑 post.md ---# 基本信息title: title date: date tags: []categories: []description: # excerpt 也可 # 封面cover: banner: poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选# 插件sticky: # 数字越大越靠前mermaid:katex: mathjax: # 可选topic: # 专栏 idauthor: references:comments: # 设置 false 禁止评论indexing: # 设置 false 避免被搜索breadcrumb: # 设置 false 隐藏面包屑导航leftbar: rightbar:h1: # 设置为 隐藏标题type: # tech/story--- 文档系统（wiki）source 目录结构如下： .+ ├── _data+ │ ├── wiki+ │ │ └── hexo-cpp.yml+ │ └── wiki.yml ├── _posts │ ├── hello-hexo.md │ ├── hello-stellar.md │ └── hello-world.md ├── about │ └── index.md+ └── wiki+ └── cpp+ ├── backup.md+ └── index.md hexo-cpp.yml name: C++title: 学习指南subtitle: 从入门到再次入门tags: 博客主题icon: https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/icon.svgcover: https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/icon.svgdescription: 这是一份从入门到再次入门的学习指南。search: filter: /wiki/cpp/ placeholder: 在 Stellar 中搜索...leftbar: - tree - timeline_cpp_releases - relatedbase_dir: /wiki/cpp/tree: 快速开始: - index 网站备份: - backup wiki.yml - hexo-cpp index.md ---wiki: hexo-cpp # 这是项目id，对应 /data/wiki/hexo-cpp.ymltitle: c++--- sites 网站卡片 source 目录的文件结构如下： . ├── _data+ │ ├── links+ │ | └── tool-life.yml tool-life.yml 的内容如下: - title: 中国科学技术大学测速网站 url: https://test.ustc.edu.cn/ cover: icon: description: 非 WIFI 环境下慎点 在需要的位置添加如下内容： % sites tool-life % timeline 时间线静态时间线 在需要的位置添加如下内容: % timeline %!-- node 2021 年 2 月 16 日 --主要部分功能已经开发的差不多了。% image https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/photos/hello@1x.png width:300px ratio:1179/390 %!-- node 2021 年 2 月 11 日 --今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。% endtimeline % 侧边栏组件 参考链接：https://xaoxuu.com/wiki/stellar/widgets/ 在 source/_data 目录下新建 widgets.yml 文件 about_sidebar: layout: linklist columns: 1 items: - icon: svg.../svg # 或者 icons.yml 中设置的 icon 名称 title: 关于 url: /about/ - icon: svg.../svg # 或者 icons.yml 中设置的 icon 名称 title: 说说 url: /memos/ 在使用的地方，如 about/index.md中添加如下内容： ---leftbar: [about_sidebar]--- hexo","tags":["hexo"],"categories":["博客"]},{"title":"Hello Hexo","path":"/2025/09/30/0002-hello-hexo/","content":"本文描述的过程主要为如何在本地部署Hexo。在了解和熟悉本地部署的流程之后，更推荐利用 GitHub Actions 实现自动化部署 Hexo 到 Github Pages。 前置条件安装下列软件： Node.js Git 安装安装 hexo: npm install -g hexo-cli 查看版本： hexo v 创建创建 blog 文件夹mkdir blogcd bloghexo init 部署 hexohexo g 本地化预览hexo s 写作创建草稿hexo new draft hello-hexo # hello-hexo 为文件名 发布hexo publish hello-hexo # hello-hexo 为文件名 图片全局资源文件夹如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。 然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 文章资源文件夹将 config.yml 文件中的 post_asset_folder 选项设为 true post_asset_folder: true 在通过 hexo new [layout] title 命令创建新文章时，会自动创建一个与文章同名的文件夹。将所有与该文章有关的资源放在这个关联文件夹中之后，可以通过相对路径来引用它们。 相对路径引用的标签插件当打开文章资源文件夹功能后，把一个 example.jpg 图片放在资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](example.jpg) ，它将不会出现在首页上。 正确的引用图片方式是使用下列的标签插件 ： % asset_img example.jpg This is an example image %% asset_img spaced asset.jpg spaced title % GitHub Actionsname: Deploy Hexo to GitHub Pageson: push: branches: - main # 或你使用的默认分支名称jobs: deploy: runs-on: ubuntu-22.04 steps: - name: Checkout blog source uses: actions/checkout@v4 with: path: blog - name: Set up Node.js uses: actions/setup-node@v4 with: node-version: 22 # 设置 Node.js 版本 - name: Cache dependencies uses: actions/cache@v4 with: path: node_modules key: $ runner.os -node-$ hashFiles(**/package-lock.json) restore-keys: | $ runner.os -node- - name: Install dependencies run: npm install working-directory: ./blog - name: Install Hexo CLI run: npm install -g hexo-cli working-directory: ./blog - name: Install Hexo Theme run: npm install hexo-theme-stellar working-directory: ./blog - name: Generate static pages run: hexo generate working-directory: ./blog - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v4 with: personal_token: $ secrets.PERSONAL_TOKEN publish_dir: ./blog/public external_repository: username/username.github.io # 更改为你的 GitHub Pages 仓库, username 是你的用户名 publish_branch: main # GitHub Pages 分支 hexo","tags":["hexo"],"categories":["博客"]},{"title":"Hello World","path":"/2025/09/30/0001-hello-world/","content":"10d79030e8222445804370796b90fca1cf7dd2ee01010d95413afa643c36d75c6da7dc8584583c53132d123565a83bc482d57efe09dbb13f6be1ebadf67b396c5e9af14ae37a94b87d779719bc8c1cd1a95420a6d53586101970b6bd1e11383c5fb9eb6a2afd2dfd764940c736e232c31819ba63da4a7c6eb6c1003cc6443dcf2082b9f749ca03a1484b87b08c908b3c310d7b631064a7fc3f9ca36177e4c3059978875c3caa78a7dceb6037a9522caf5c4adf858dd97440561f76a5ba5e4fd77e9898dfeb4cad54c4bb643f9c0ecbaef49a3431bdd2455830a88255232397afbbe9b23eb9395dfae6f0824e03416bc0b3804386abdc6c923976a913424fdbf1ba89bde972822239ac5e9109f398b65ae65ef00629508a203d30649f6408e1f61f5f6e73d99349907d745bd4c4ef0763621826913a2677273e3b66ae19439d1940d9ebcc45d324738506f0ac5dca5093adf45b82a24da2d49432e9f7cea3b56d73ea8b80628014008c75e6df0aa070ccdaa53907f1adc5e6234b2ab2f7f8485fb9383dc64927d631e20713c7d719815e20c9d6247aa120998e681a19e43d40ca49e20ce7419d535072ff85e74c96caabe848f11f049126a6f4cbbfc746a3cae3d4b6c98db711e8b3bdbd372def67e3d1bf776ee35037a2377d5898704789976ec22fc47c64eb83da5766f0408afee5b438701c6084a1025c673100e7ac0cf710407782790b56679a3fbb40313022e90f715c1a39914fe4b710beb621310bee163ece727a9d02da8b2ef0925acbeedbed1bdf2fb2a5a106956f607dcb5fcef0e36a97afa6fe5d415be51d647cc196fec6186575845eba2577edf79b237f40501d9e0516fe26fcc18e5bb029218ceea51ed6571ed6499c1b863fe5e4184373aee7af54e687aecc3ffa4986afe90e3a5fd67d73f47c0c882443054fed1625259e96370f07d55431f1a03130d5486c9ac1bc2c51d48a7b31ca8c81fdd6cc8795e3296ee5cc4dd66f3e582583d5516a299f41c5bc32710ee392ddb18d02b9fea50df38fbea6579d1f8a7a1ec2fdcff1a546b8a51d96657a2c6538c2dc93476d69467cb3671b880c09d3c422cfb3bb9199050f0c77a137b4b0dbdb4041a1be97361f0b783b6ab8bbbdcfdf1c9d545e17a129eca1e4cc3aabe88b7ab633ec35eacbb26e1b4b8c0876bd6ed5f351cc4d04c974e55a4f37f0580b599953ae28a9a6f6ea344c8bee255996315fa0673b087d06f292b6f9e84801a38c8ffea05fecb03b16577db7697bbac072e1d372bf5fb0dfd48bdb369ba8ac97c5f3f8b3173cbee017a98e2eea5f78edd3ad8ae87ff061a3e43ccbb435291c501139a80744cf59040e4b980306c75cfb527b82fe4c578a8973a6a75baeb2be249b344f14cd6153f99e07309fee10b0e8e4702ded0dbde9bcc5b0eb0d117b479db98f93d36f1c8721a712a9650023572dd95effb7718f45c2948d9192a1d27b38e652903d68992618f4c9feee5c5dfc2fcb15fbf1d3fd5896245a14bc1bdabb6dddb4db0ea3fc36165bbc4b56ffbbb0ed570e77f7d8820a5078d5fe499945473ff216f85fe92c706d7aa308198dfcd4d85abe4f1fcb8924d6b5c72b05a03333c163fedfef1f479daeff26a1d99802645980fefa0f8be445851c3f508e0b5ee79b06b504a054b4e7ad26f9d0344d2395322d452565b03020d13fe150bbc9ca3e433e04e3411da56239b42807d0090d11b5858ff8487212fb6771f4914fdcd8393d2cd2150eb82d8e82be0db2e71679f2f78d5b22b32a305993748f09821838303b75df669acf24e08c3eab2fe0433662a1056cc392ccecc20041dbf44a229ada35bed43255979bfd7e150b6e812c6c23466dd45e57c5b443d976b298b5f5e4d977130bcaf5ec26e2e2c727886f3f116fd1fbad331bbf9d1ca9efa141a0174450b00f818e2b59a784a40b77918ba82e75a31bd542e611a43010f08fc30369e93386f239e5fb9a515d6c2afc272997890c0ec4619f78f4b5fed881f0002b85e8165088649391e0249613310e523cdf5e2dfd5d4b4236bf38c02fb72341cfe539508f7af5c7db00d07b8425db13d92aa628930b5521eba6daf54fce1a8a6a36e1b095f67ebadd2fb0c096012eee795a471f33f501a0fef0a9075dfce83a3227087b12382ff22011db6d7fc3cc877c19d425b5b672b574f4df7643bee516ecdc66629c21963733bea688bc205c9add0c36479130ca3eee5dc72698d00713bf52775cba1634cf4cdb9d5856c60135524af408c949847e6cce9729997a3858154a3cf638ec1f1d326b3caa59b6a3555f947a761998b37a3890339d86cf8eaaf75260de0475d5ba017d78d7e2671849c4f8924658a4fa3a6bb478e5dde99ccb965fc5f099418feda6e45cb85e810e253d8da0ec932b4f426793cb86b882291a6d98f048b162b71dd6888262a0e3d96caa0538f96845e3bddee62faf30f9b8e3176953e68652ed0b429f284bbd828de3d2c4815b2b69cd2f5cd993b1bcf65d2c8b67f3a5cc99dab9d029d01f9730eccf97c48dcfefbd9c3589bee7e98ebc76468ce1e4d47c4a4c89e275bb743892c4b8558d8ea957afa93b5ce2bd02f94ee38eb9fdcddcb8231584cc840b914a3eefe46c659029555aa0c43e523b507722c6753aa625f67b07ade89ad34eabd449f4c1d2822e0a0f435ce2602c2f5427dabec0f8cee68c5d64d9685cfc8e367505320dff6026c07f62ddb32c3039fe867067bcac7347b455893575e795974c91cd2b13bfe2341efd7b5e24b81aac898e60bb569def27c91bd3554bcf25d039002a7541daf01684f1aa4e4eb493a7ef9d3ab8c8489f98da8bf72989e524f97268729a6f437727d3354db4d2e5890f9b70fe2daa36cfbba178ccb0ead684e862eacb694e5c22f388c7d8b1f360f0459117529cf67e806255f61f71f840674c20c1b6c9b0ba4072bb7b1e19abec986c902fa25e735c93371dfb51ec15e9a2440cf886f29bc4e911d7c8925922efbc893b336161da60f33600143637d99e132a76da2087f75934b4997351f5e29ce8da8b847b61959afe5e9c612a2cc64730cf8dcb02cd15002ed3ec0088023a12023dcab79efe9d7f1f1d222b1193c79f0bab1a8e6a2dff9665327e827e675d76d3555cdc880e Hey, password is required here."},{"title":"关于我","path":"/about/index.html","content":"喜欢搜集有趣的东西。"},{"title":"探索","path":"/explore/index.html","content":"工具纸由我 PaperMe在线自定义打印纸生成器PDF24PDF工具中国科学技术大学测速网站非 WIFI 环境下慎点Notion 风格头像制作https://notion-avatar.app/zhWiFi 连接卡https://github.com/bndw/wifi-card 公开信息查询中国裁判文书网https://wenshu.court.gov.cn/合同示范文本库https://htsfwb.samr.gov.cn/专利查询世界知识产权组织的免费专利数据库wikiHow互联网上最值得信赖的指南网站 自用stellar 文档https://xaoxuu.com/wiki/stellar/#start闪卡导入 CSV 创建卡片引导城镇房屋租赁合同市场监管总局2025版云盘盘https://www.yppan.com/儿童睡前故事https://beddystories.com/zh中文播客榜https://xyzrank.com/"},{"title":"关于博客","path":"/about/blog/index.html","content":"2025 年 11 月 26 日使用 PicGo 将 Github 作为图床。2025 年 11 月 7 日增加评论功能。2025 年 9 月 30 日使用 hexo + stellar 重新部署博客。"},{"title":"最近听的播客","path":"/about/podcast/index.html","content":"2025 年 12 月 7 日成功向媳妇儿安利了《半拿铁·故事篇：西游篇》，她说比末世文有意思多了。2025 年 11 月 21 日最近听到的比较惊喜，也比较喜欢的一期《正经叭叭: vol.224 第一届叭叭KTV》。顺便说一句，谐星聊天会 YYDS。"},{"title":"说说","path":"/about/memos/index.html","content":"2025 年 12 月 31 日第一次使用 GitHub Copilot。2025 年 12 月 25 日发现自己给自己设了好多限制，一些可能并不存在的限制。勇敢的人先享受世界。2025 年 12 月 23 日冬至以后明显感觉变冷了。2025 年 12 月 12 日今年冬天的第一场雪，又到了重刷《请回答1988》的季节。2025 年 12 月 8 日发现双十二买棉服价格更优惠，今年着实买早了。2025 年 12 月 3 日今年的第一份年度报告来自多邻国。2025 年 11 月 21 日发现最近很少去电影院了，上一次是今年2月去看的《哪吒2之魔童闹海》，上上次是24年6月。现在即便有想看的电影，也干脆等到上线流媒体平台了再看。2025 年 11 月 17 日手机在使用了半年后，电池循环154次，最大容量99%。2025 年 11 月 11 日今年的双十一让人有点摸不清下单的合适时间点，优惠力度也从原来的85折变成了9折。2025 年 11 月 4 日在晚上运动后，立刻开始整理《每天最重要的2小时》的读书笔记，感觉确实不错。这也能够驱使我晚上坚持运动。2025 年 10 月 30 日如何做一个有质量的技术分享：问题 - 方案 - 总结2025 年 10 月 29 日昨晚无意间刷到一个外卖员练习英语的视频，想到自己也可以下载一个多邻国试试。"},{"title":"探索v2","path":"/explore/special/index.html","content":"bd25ed9264b080267271e137e33d0ce1adc3c6b2bac6ceb0572e33f68e974c79e53c621cb5700767a90da456d8d0482a95d12d377dca048a8c8ccd92f66d61b6e49740685f538acdcf2e0dea9dab84618f2882502d4bed4cf755309e7e2ab3a7439dbb350dc850437a38b20071ae95909cbb306a1524c79295094aca89e28950001a4b28bdc89fd1177565161ce632943185ddebdbeb4d5a582198122ca8a6e8fcff61ba88bed701aba1a6c52081d0f6687efd6861c7aff16f0b2153a7d70e58263952cbacd353cae09343b5a6e5af3a22f125a3351e39f09773e31d863ae46854b9af18184dc250cea51b2ee44ea1c129899f172d5f5744a084770d3fddd207dd258c6cb3b61de5dbeb56c288559a954b7f3d41cb909500db6d9703d6c1924ed2ddea6096215734e6999f45f86b3d644edd7c6f9216509b12649b47c358579adeb1db8745740d4397c5cb300c68489c4ff304a1c6dd973135d8bceda00b8086cbd42b81ec8fdd1bd50f6dcd9e222341e36f024b0d99449a5773a6d3817a51a72debbefaf7a129aacd4d2360497df6720b695a200ff51bd54e7b8e1bf0007e1477d83918e0ae5f68bd5a735e7f4d1bcaeed6a6999ffc66bd5f1783dd921786a4c8f60e666d33b38dcd417497bbcda97fd866ec9d4d756cb839f23fc2baaebc2c00db3ffa60dd6a5b4b8819850d1cac417944d8810357ecbaea7082a5be0eca8c806fd3da8b96c668b7d76c7826d4a1885ec3e9185d5f090d39f77e6dedd0f7614cd8ca0aeb2acc608b735dbbbf6c66ed537a0d247a6d82e1094399a5c8a9ef0f749a7df01baa3890e3acf5f6896c0bd89a3f6294686885d8138a7c7e1e181f24d22473c53b54fe099171686f99521385d9b6df70a54b545e2d7a5f635ec8821ffcf4723ca9127e8832d3298f39c32faef9a07e232b4ea4b93ac47ab4350175f81dd978e4872329c11270135b22fd4cb7db1c496c4b54039d8f75d58e4e569979a92966a8aa5647e6c58fd4c580ae8ada636cf732ba9c9a285dbb05820770623a7c09ce52831a7898e3e303862facd1ec72817f3bb791b8955927bba2b18f9fd4f99aa73fb770a4dd1606940d59d8da5abf4f062672608bbe9dd88ae6cd71457d5849d147da9f4e94ff87e70268f6bbafcac2733a28f75acc69baf18398ca919df8cd71a15caac2371cd1774409e5f893aa1f64fdfcf6f441f795ecb13f8800e303bbfad5dd1120a24c41359fa3c8ec7f72e791cde1483a7836ff856d1a3e3d786b3027d2790def5b583a80fd040a63bc5c272dbdb2ce69cba4560c5ce76024345efe5bfeb26c701c58f93b0206d6e305ca056e84c615d411195774b5058e9f4d307698b267bd20c1d7ed05faf73b7e586b9c0a501c39e27ee2671774578a0ed8bc8089460e6a416ce300b6d2162df5564429cb9b0c200c8ab19b7c25c382633bd7c3aa9fd71aaa0727ccf1b2ad34d8593af657abbdfdee1170e456b0f2ff0829a3baaf60fa00fa6ee67afafe63069e10199a422114ff2f4200e525a430ae17d8a255de472feec7d1652bfff36f584c3c6a21b099e2cba44b316c04dd2e28138706cf1acbea79cb3f9a72f6826e9af4b5104d24e5afcf86843b9f6411c27ba082d814cb55c9ee06d2e8fffecade803aa4efa9d5c814b673d4e9f5be9ae4ca55b3826b697c3911e1e6c3c14e7f7305bf6d6bdc05efb329a0d9d40622c6d5486520e5e068d2f93defd6011e88feaafa1e4323c8772bb513b13a970ccc7180842b710112490724c705e6cfb1b45b28d2a8240a65911d8c091e45ea914f547b7d240fdb7916227dec9c06d37a4236319f03d16bc3fbaf7379c58ed07e53965ed5a58f664c16309c63d0b7fcd45f68e7b523ca54ad655e856086e8dc8f0e46fc129e81407a0ce277eb6fdafb2b82fbc8b1db12930d9702e9e49cd08d6888a98518911132614a76f4c6108916e802f513d620ae167aa008ed0915e6184bcf976759ed2ce4343938755bfd69a95a0b89ae1bff007ca5cd796008579303879e4aef7cf4254a8cab34e1103761b42e75f7e901ac06ebff0314ce11ed579041332f8ecc5d16317b0175c3880301485282700da2af56c151ed5ed2d6cae1bd50831952ef564229c3565d76ca3eb6191dac36503accf60ce7043f57a86677d96c52b74969b84eb503a96c8977b7ada340033dfa4981b3aca7173f73527f11e040b1098ade2522c1b6cdd809685f8d82ad52f3676616aa0203b616ce7043d8406c39cd97cc6df121d493dc6726301c71abd0962acbd26e53f07ed83854c1b3acf1991a0cc7a896dcd77fc2d6acd532ac3b62f7587fdb40a23b851fd34757e3b1086a9720e15c2d9ac2eb9201d12e5bab389abeeee787b0ceb6a74fd7e6cdd6f8be673347324701a7c5cbd80fee2a305ce370d2d5f430a61fbf64b02c5200a4601ef6461e229bb7f142676f777b5aeb29a9485f310e6d3e15b3617629507d6cc68c797e82cbd05915802939696baefcbd619d9a020e2002bef604d2f224e07f4b33eb409e38c2573c3a839f865f6bcc5df82ae24585011f1b7eae6d7279ddeddafe52c897164b15f6450f1482f004d0daf7843350a3a748d47736d8d366fd542b0250fdf429f02a30a724d1aa3d744acf05d0ed6cde8111dbd34bb190778e4631cc06381f013d21e7cf70a91923cf7e78965cd216fdc77d8d731539fd82e1dc587e5fe8a3aa06b3f41cc6bdca059dc0cc9e9ebfe83bfa29004b8f23ad36dd4d2c7932246bc03cda48d258ac51b9ac1518ef04e3331fd4a3e23c7e72ec8838c8e3fbde62ae0049b515ba17d556d1159362b162c47fb29fcfaeb045db8d01cc809fe819f161a4b4fe655170dc2b993b779b44127d5fb5267e132c4dd8565640c18cdc676010c9e4b3e8640219376c18dee9f873b8c465661b46ab54c54f847d0899d9237b4ea86f5e7e61183126597b0aa79537739e6423d9013e22b60bbcabfea329612ef7c2e079030e5d76d83b445f075eaea0993abae6cdad25a9920705870b95afcdf5c285955508998448193aa5e7ea997c79d23c550d41c05a6afa414ce6fd0517898803bb356ca62d8f173d07eb957d27fd8433d2bb3e417e3cc85964974f8b9fe6a6cdcbbc4ace84ea0548f5b8ff4faae5953f817abad6f3dd101ff106bf30295424e98ad81440667b3d5c7901f0a74795b3b4a5e1b3d467535e91edc04e75216cf16c18011969b8f286edd50b102779ce10ea54431d191c6bf7157574d6560f873d30b9262724d2f6d6bb9f9d15ab619696b6976f325dab4b500e5bfae1c9dd1181fb541b46719f0a9ae904f89d050dac6eab30819aa6f4241a4e1b8d5f062e1f550c47149567d3c70f454197fa30ee7ce64e499cb9f4b275b947dcf9d72aaf53e40646daa35ff8083550d2b847a13e1dc1ee011cf35d8a3f174f0d5a139cdfdacaa5d069e9a42691cdf1f65c1ea7a0b3edceec4a03fd8c153a8bd3f5dbe9e7b2635753a6dd6714e622a892babb53d76a5fe7b7385a2e70b2c01063a2382a317a7d7f40a9744d6e95b35fa6696d2eff6b56dfee0e22ba2170df4a5a196ba41cc92652bf30477aff3e44a50877d79c2854c0230ab1c8abf2130c8cb0acc1922b3fcb9592fc6b9564e059b041a35b38f9fe12a43ef3e811245b4968adb27e5ad2ffcda2f53014cd6dcb7db485bdef0f7d04aa7c48cee33158f11ad61a62d4e6d783453c969119d533ab2848c3e77b2d83556c1f1688c0eea53302ceafca5880dae0c2a382cf82dc63d2138d18dfab3b7401fd97fe3357c9462b0f0025c44cda4995bcf44115be27a021a26167fd3ac9e6126ece8d681cb9b57abd1244bd4ca69b7767b00f4f60c836f303a005588ddce5df29cb78909b26693604c7ba49a8909071d6e78fca5532dfe2434b927be1a939247fba72a9499e1a6ba7171be91007390962d76f2b9aceb8e7a246740bb2428f8ec1df450ec71183c5c8a98ec2125a6431a393c6c87a4abb15a56bc8d944f8ebdd87d66107f4b7eacc579496d2637aabd93ff449ab976af2a27ed048b5008c7d1d5df0af20b8cd2fd4ce27a851661f730aa8e00d3f9d6e4300c6c2b6250202837c211df9556fc3012e7d5cb1a4278090e6439a2062a99dd9d90cafb0c4a6fa8ecaf677547338f413dff2a9bd1b53b0f5c370a4d3e5a56ba0bb63ff80a2321af9c151bf11b755f3fde831872475aac7f147a358d4588207d30c124fe9fa9e218e93c0791102fc5725514811f91b1b827f18c11573ef5eada5889fe71b7c242e732201c9a96c0f59a8ca1d927ddbfe1b1a5953ab6a5a14f07ae8a46481764175b3d261c929f10db7917e7a710bdddd96ea591bc498cd3e4cddee5cd2ff9a4806d821f4e8dae3a845bdc6d1baf05c0a97f2ad6b23343f81c06a89745f5f838f034d80de804d0246e2a983762c642d55e49ffd9e10a2d4cd8512b36e7b45019a1e858fd0e0712a41a0f265d38e8f4526fa417693a55190b1b468c0349e230d540a486f59dd917570907eb9bbd66fcc2b9f9ce69ef39b2241f4a7a8d4711af72dedf1e9658ea247b60b75ec74a2365893b1d665995cdc7aa91369eaf899a00f200e29316adbfffd3cfc3d61d80c2b119b38db8d31b1a86133c1f00aca08d8eb3985c6ed4d6faaf40380b7eb063b25b11a7a831c58fce0f2303c7606e01e45baa3f8d99089769d2350e92b21be01391004fbd00a27b3348b559bc2cb40f1e1e6096bfe66d8bc41c9943a3679df5d9e69df2b78a5b6f9c08019a04bcb7ddba3015dea385209c89c6fa2ecedada152056435d3f4cae9612056244cd6fa84542e089d33f8a8e575e12690a9783b8b203bd4a7dea9ab9dbcc0f422044621fa02f90a056a8a87661c2817dd468eddc25184fa50a301e78314155317bc85152b072a3194e070e86375452cf2e8d29f4ad190d352b4d4aeb46b2a6b142a2165ba307fff9463bf10c9d276900907969c40928c6f71daf10495d150e9a772cd56a43c6f7aaad5067ee72f3e4ae2bba4ef072e85c6202b17607f0f99c95a80f7c4ffa9dc6badc929779eaf0d2c02f1102fb4b207e64a87e0b1f337712efdc44701273ba9e1ce5387974191674337947f763f04485d5aa5f023ddc6deabf65764e55091ac8c0caf7602d7b9cbee952507d8f73e09d00e58ce6dd3774d0ce7ab6f3363c2d1430678956597b5dc192667d2a42fce64e02d7634bbcee4ddff6c400bd6bdb66c05be74b015a7dfd53c0958abe42d947dc4c9479454cda78f1c7605d264d3c79d17696e75ae14db9e679c8b62c11fc983e79af3cb068eb8f621d5273679f7387325c8b57dd4496c04e3a07d5cbee59b0743d34ccc796065e0100b563e690178c027d75c98b84584827351b5679a7ad18992cc854da6764a7a0eb0eb2fcb9d061720aa20fbd9c16368aa46b1bde09298307a8edc9a38a5bd983cad304eb0cef193b16f92d598d917ac67fe0496703ecbb873858b24ce736b9fe0cab7b0928b805669d67ffaddf35ab7f9fb30cc005752554bd523d6a50a82c8807819c5be644e5bb529bebfc9b91fd0c4935386d535fe27dec4c507737049c7d83ec6766d28c256eb64c5e31694c9c0f847f855b8af624585af1b9203a282f66c33a6c41f8f96cfb56f48e6b31d0303fe55f89444bedd1af2ac6e0a0a07f647ddbcddd5312267ebb8bd9b99740b114c4879b3da1d3b4bf27e09b1c1afa3449ecc189e78980d8eb7155c4659b83591f50ac15bfe7c5ba043c6c1638194a80ee1ccd5e48c5e5848977f5e30bbafc009d30729e1e041e37e95b21822da26df3b7ab33ea2eb1b64980dc300c02e27ef80ee9a2f83400634ad3ee3006664fddb7aeb9f017f6a17a4acb2176ebf7f6478ca9217a9577084473e2a6aa747e263b249cfd8ff909af3f359e568e22ab13071acaf972559a20151fcd12554bdb62d9bf97734441167c9ed8d733bf9137f2afafe14309ded64d16d32e2031f8f0070e072546eaa6b70c9a09098337b6b4cb876473e0efa9fcbf04c22581454b8b14aebea97bc34dcc200ee7b78744491207fce734e46a52f18262a62c2d58af0c3d9afbe8bef6850224cf0dc63628f085ec9b82fea0948c1de63ebad81c7aaa1b0e90c385449cb0e1b0ac880118772b0853f5a896dea2b87c6137aca7712a42bf70dfa0e7f0138291da05fbf7af42cca72231827728a22047a9dcc2d5605d405742b1ef17abc363694ffd74d54fc0d45db62425439ccca03c7c31781dbdfdbd3677ca450c81a2cd965509cca309fe35a1c1afad5ec5786f47ed9bc3e3748891e996fcf49442170bdfbaa8d007572bf35c4f5434c6bb8eb058e7270bae542a71ba57933c12c91161c19e1e385112cd1bcf70e2ccee633e5495fff7c2c773f67d92a9601d326c03836f3e5730d0c76f40a8558ce3c109428d36a6fa3411d1f2a593f90bf02a4893e1c381a77ded3810d5aed3422ffdc41e6da778ff7d4f67568e21c862d368622224b139f5e97f2210026f3efb632c8d132c524c297e011ce2604555694fba9a06991b314f58de76017e5ce65eca8cae1aa6d36791fd0e68d02ac41cced49ec8e953aceed4db8a476a0adb893c37a7fbcb6cfa13950f07f35e4dc1d94eb007c16e2d30f37192c6f4e5d1285fe872cdd1999d698b57cf598d6eb1e60a8104d40fb92bd64eb2b1ab166004958dbfac3ab16979d3c9c44db2a1f71d57d9c0a30c40583ac611268873b3864bfc96c1209bab048d7eece53f0544210eca95fccbf9ffb2d3b51dbf79e0c484f5db6a9b36f79a034e780d779b76f6502ddf3ffc97458688eefb6fd914353b09fa98a198ee7c649df965e75010cf374b8073a38f564d389e04af0d69e69ca3e9257dc065d3ba76eb0ba42b0f8ca7e77c21301948f90e478a2af30e9f7f32b23d166e9832e9bc49b1ce3609bef20b5a58263373d2e34e9d27bc8fc7522558ca9d471539927a5f7820b97d3d752735dd2d1c881720d79f8dc0cf4df91851aac41ddd70bace8ece7495e310e8e2240e1b03d8b16c0ef212308c7c12d878eb79fa30e075b16e519fefb129dfe290084e4087ea5d042abbea22399659c78eceb46b37c0f4e07dca50f24571b5b0ee6f7ea114e756eecb2f6313d13943d3d27694becca79431c4603dd 关注公众号，获取密码。"},{"title":"todo","path":"/wiki/cpp/cpp-todo.html","content":"计算机基础实战课 Linux 201: 问题调试"},{"title":"index","path":"/wiki/cpp/index.html","content":"工具DeepWikihttps://deepwiki.com/PlantUMLhttps://plantuml.com/zh/CS 自学指南https://csdiy.wiki/TemplateRepoCxxVS Code C++项目模板Linux Manpagesman 手册Linux Manpagesman 手册Linux 内核源码在线版Linux工具快速教程https://github.com/me115/linuxtools_rstLinux命令搜索工具https://github.com/jaywcjlove/linux-command C++恋恋风辰的官方博客https://llfc.club/homeCppGuide社区https://cppguide.cn/c++自救指南后端自救手册c++全栈知识体系https://stibel.icu/阿荣的个人网站https://www.arong-xu.com/ C阮一峰:C语言教程https://wangdoc.com/clang/intro linux开发内功修炼https://kfngxl.cn/熊喵君的博客https://pandaychen.github.io/文先生的博客https://wenfh2020.com/ArthurChiao's Bloghttps://arthurchiao.art/articles-zh/Linux 201 进阶教程中国科学技术大学 Linux 用户协会HelloGitHub发现和分享有趣、入门级开源项目的平台 other技术文章摘抄https://learn.lianglianglee.com/深入高可用系统原理与设计https://github.com/isno/theByteBookTCP/IP详解 卷1：协议在线阅读版（全网唯一）无处不在的小土个人很喜欢的博客创客技术知识库https://getiot.tech/"},{"title":"interview","path":"/wiki/cpp/interview.html","content":"CVLapisCVhttps://github.com/BingyanStudio/LapisCV 八股阿秀的学习笔记https://interviewguide.cn/小林codinghttps://xiaolincoding.com/卡码笔记https://notes.kamacoder.com/CS_Offerhttps://github.com/selfboot/CS_Offer 刷题代码随想录https://github.com/youngyangyang04/leetcode-master 面试反问面试官技术面试最后反问面试官的话"},{"title":"编译与运行","path":"/wiki/cpp/tws-build.html","content":"开发环境 WSL2 + Ubuntu-24.04 mysql-8.0.43 MySQL 安装与配置 mysql-server 安装 sudo apt-get updatesudo apt-get install mysql-server# 查看 mysql 的版本mysql --version 客户端库开发包安装，提供头文件和链接库 sudo apt-get install libmysqlclient-dev 数据库建立登录 MySQL 服务# 远程mysql -h localhost -P 3306 -u root -p# 本机mysql -u root -p 可能会遇到如下报错信息： ERROR 1698 (28000): Access denied for user root@localhost 这是因为MySQL默认使用了 UNIX auth_socket 插件进行认证。解决方案可参考：stackoverflow。 这里使用回答中推荐的第2种方案，即创建一个与系统用户一致的新的数据库用户： 注意：tws 可修改为自定义用户名 $ sudo mysql -u rootmysql USE mysql;mysql CREATE USER tws@localhost IDENTIFIED BY ;mysql GRANT ALL PRIVILEGES ON *.* TO tws@localhost;mysql FLUSH PRIVILEGES;mysql exit;$ sudo service mysql restart 之后登录 MySQL 服务就可以使用如下命令： $ mysql -u tws -p# 默认没有密码，回车即可登录 建立数据库$ mysql -u tws -p# 建立 twsdb 库mysql create database twsdb;# 创建 user 表mysql USE twsdb;mysql CREATE TABLE user( username char(50) NULL, passwd char(50) NULL)ENGINE=InnoDB;# 添加数据mysql INSERT INTO user(username, passwd) VALUES(admin, 123456); 编译代码修改 修改 main.cpp 中的如下内容: //需要修改的数据库信息,登录名,密码,库名string user = tws;string passwd = ;string databasename = twsdb; build$ chmod +x build.sh$ ./build.sh 运行run./server 服务访问 访问地址: http://127.0.0.1:9006/ 用户名: admin 密码：123456 其它MySQL 常用命令# 启动、关闭、重启 MySQL服务sudo service mysql startsudo service mysql stopsudo service mysql restart# 查看MySQL服务状态sudo service mysql status MySQL 用户认证方式查询$ sudo mysql -u rootmysql USE mysql;mysql SELECT User, Host, plugin FROM mysql.user;+------------------+-----------+-----------------------+| User | Host | plugin |+------------------+-----------+-----------------------+| debian-sys-maint | localhost | caching_sha2_password || mysql.infoschema | localhost | caching_sha2_password || mysql.session | localhost | caching_sha2_password || mysql.sys | localhost | caching_sha2_password || root | localhost | auth_socket || tws | localhost | auth_socket |+------------------+-----------+-----------------------+6 rows in set (0.00 sec) MySQL 删除用户mysql DROP USER tws@localhost;"},{"title":"功能梳理","path":"/wiki/cpp/tws-run.html","content":"参考资料：https://deepwiki.com/qinguoyi/TinyWebServer 功能梳理select, poll, epollselect 使用 线性表 来表示文件描述符集合 文件描述符 在 用户态 被加入文件描述符集合中 用户态到内核态的拷贝 遍历 只支持 LT 模式 poll 使用 链表 来表示文件描述符集合 epoll 使用 红黑树 来表示文件描述符集合，同时维护一个 ready list 用来保存已经就绪的事件 文件描述符集合 维护在 内核态 支持 LT 和 ET 模式 总结 当监测的 fd 数量较少，且各个 fd 都很活跃的情况下，建议使用 select 和 poll 当监测的 fd 数量较多，且单位时间内仅部分 fd 活跃的情况下，建议使用 epoll LT 和 ETLT (水平触发)ET (边缘触发)在使用 ET 模式时，必须要保证该文件描述符是非阻塞的（确保在没有数据可读时，该文件描述符不会一直阻塞）；并且每次调用 read 和 write 的时候都必须等到它们返回 EWOULDBLOCK（确保所有数据都已读完或写完）。 Reactor 和 Proactor服务器程序通常需要处理三类事件：IO事件，信号及定时事件。 有两种事件处理模式： Reactor 模式：要求主线程（IO处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。 Proactor 模式：将所有的IO操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后 users[sockfd].read()，选择一个工作线程来处理客户请求 pool-append(users + sockfd)。 通常使用同步 IO 模型（如 epoll_wait）实现 Reactor，使用异步 IO（如 aio_read 和 aio_write ）实现 Proactor。 本项目使用同步 IO 模拟的 Proactor 事件处理模式。 同步 IO 和 异步 IO同步(阻塞) IO: 在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待 IO 操作完成，才能继续进行下一步操作。 异步(非阻塞) IO：当代码需要执行一个耗时的 IO 操作时，它只发出 IO 指令，并不等待 IO 结果，然后就去执行其他代码了。一段时间后，当 IO 返回结果时，再通知 CPU 进行处理。 Asan"},{"title":"压测","path":"/wiki/cpp/tws-webbench.html","content":"保证 server 运行./server 压测$ cd test_pressure/webbench-1.5./webbench -c 500 -t 5 http://127.0.0.1:9006/Webbench - Simple Web Benchmark 1.5Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.Benchmarking: GET http://127.0.0.1:9006/1000 clients, running 5 sec.Speed=220188 pages/min, 411152 bytes/sec.Requests: 18349 susceed, 0 failed. QPS 是什么： QPS（Queries Per Second，每秒查询率）是衡量系统吞吐量的核心指标，代表服务器每秒能处理的有效请求数量。 QPS 如何计算： QPS = 总有效请求数 ÷ 总耗时（秒） 因此，上述压测的 QPS 18349 5 3669. webbench 原理 父进程 fork 若干个子进程，每个子进程在用户要求时间或默认的时间内，对目标 web 循环发出实际访问请求 父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息 子进程在时间到后结束；父进程在所有子进程退出后，统计并给用户显示最后的测试结果，然后退出"},{"title":"介绍","path":"/wiki/cpp/tws.html","content":"项目地址： https://github.com/qinguoyi/TinyWebServer 参考资料： https://deepwiki.com/qinguoyi/TinyWebServer 小白视角：一文读懂社长的TinyWebServer(Raw_Version) ZWiley的随记: WebServer项目"},{"title":"WSL 常用命令","path":"/wiki/cpp/wsl-cmd.html","content":"列出所有已安装的WSL发行版wsl --list --verbose 卸载某个WSL发行版wsl --unregister Ubuntu-18.04"},{"title":"WSL 开发环境配置","path":"/wiki/cpp/wsl-dev.html","content":"可根据需要选择安装 sudo apt install git cmake gdb build-essential clang clang-tidy \\ clang-format pkg-config tcpdump tshark"},{"title":"WSL 安装","path":"/wiki/cpp/wsl-install.html","content":"1. 以管理员身份打开 Windows PowerShell 启用 WSL 功能 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用虚拟机功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 2. 重启计算机3. 下载并安装 WSL 2 的 Linux 内核更新包 打开 PowerShell，运行以下命令 wsl --update 4. 设置 WSL 2 为默认版本 打开 PowerShell，运行以下命令 wsl --set-default-version 2 5. 通过 Microsoft Store 安装 Ubuntu 或其他 Linux 发行版 开始使用 WSL"},{"title":"bpftool","path":"/wiki/ebpf/bpftool.html","content":"项目地址bpftoolhttps://github.com/libbpf/bpftool FEATURE 获取可用当前内核版本中每种程序类型的辅助函数的列表 bpftool feature MAP查看加载到内核中的 mapbpftool map list 165: array name hello.bss flags 0x400 key 4B value 4B max_entries 1 memlock 4096B btf_id 254166: array name hello.rodata flags 0x80 key 4B value 15B max_entries 1 memlock 4096B btf_id 254 frozen 查看 map 的内容bpftool map dump name hello.bss [ value: .bss: [ counter: 11127 ] ] PROG将程序加载到内核中bpftool prog load hello.bpf.o /sys/fs/bpf/hello 查看发生的重定位bpftool -d prog load hello.bpf.o /sys/fs/bpf/hello 查看已加载的程序bpftool prog list 查看加载到内核中的某个程序bpftool prog show id 174 --prettybpftool prog show name hellobpftool prog show tag d35b94b4c0c10efbbpftool prog show pinned /sys/fs/bpf/hello 查看翻译后的 eBPF 程序bpftool prog dump xlated name hello tracelog 与 cat /sys/kernel/debug/tracing/trace_pipe 作用相同 bpftool prog tracelog BTF生成内核头文件bpftool btf dump file /sys/kernel/btf/vmlinux format c vmlinux.h 查看加载到内核中的所有 BTF 数据bpftool btf list 查看某个 BTF 数据的内容bpftool btf dump id id 查看特定 map 关联的 BTF 类型bpftool btf dump map name config 查看特定程序关联的 BTF 类型Usage: bpftool btf show | list [id BTF_ID] bpftool btf dump BTF_SRC [format FORMAT] [root_id ROOT_ID] bpftool btf help BTF_SRC := id BTF_ID | prog PROG | map MAP [key | value | kv | all] | file FILE FORMAT := raw | c [unsorted] MAP := id MAP_ID | pinned FILE | name MAP_NAME PROG := id PROG_ID | pinned FILE | tag PROG_TAG | name PROG_NAME OPTIONS := -j|--json [-p|--pretty] | -d|--debug | -B|--base-btf bpftool btf dump prog id 51bpftool btf dump prog name hello 查看目标文件中的 BTF 数据bpftool btf dump file hello-buffer-config.bpf.o skeleton从 ELF 文件格式的 eBPF 对象中自动生成框架代码bpftool gen skeleton hello-buffer-config.bpf.o hello-buffer-config.skel.h NET将 eBPF 程序附加到网络接口上的 XDP 事件bpftool net attach xdp tag d35b94b4c0c10efb dev eth0 列出挂载到网络栈的 BPF 程序bpftool net list 将程序从网络接口 eth0 分离（detach）bpftool net detach xdp dev eth0 ip link查看网卡已挂载的 BPF 程序ip link show 1: lo: LOOPBACK,UP,LOWER_UP mtu 65536 xdpgeneric qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 prog/xdp id 124 name ping tag 3c91b2e4d4590b11 jited 挂载 attach$ ip link set dev eth0 xdp obj hello.bpf.o sec xdp 分离 detach$ ip link set dev eth0 xdp off PERF查看附加到 perf 相关事件的程序bpftool perf show bpftool perf list"},{"title":"bpftrace","path":"/wiki/ebpf/bpftrace.html","content":"项目地址bpftracehttps://github.com/bpftrace/bpftrace 列出可用的跟踪点和 kprobesbpftrace -l *execve* bpftrace -e kprobe:do_execve @[comm] = count(); 列出 libc.so.6 里所有的 USDT 探针bpftrace -l usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:* | grep setjmp 读取 libc.so.6 文件中的 NOTE 段内容 readelf --notes /usr/lib/x86_64-linux-gnu/libc.so.6 | grep -A10 setjmp 使用场景参考：libbpf-bootstrap-usdt"},{"title":"WSL2 安装 BPF 工具链","path":"/wiki/ebpf/ebpf-install.html","content":"https://cardioid-line.github.io/ubuntu-an-zhuang-bcc-zhi-nan/"},{"title":"时间线","path":"/wiki/ebpf/ebpf-timeline.html","content":"todo BPF ring buffer：使用场景、核心设计及程序示例 BPF 进阶笔记 2025.12.10 - 2025.12.31 Learning eBPF 笔记整理 (汉化)，解决每个章节的 Exercises Learning eBPF: 02. eBPF’s “Hello World” Learning eBPF: 03. Anatomy of an eBPF Program Learning eBPF: 04. The bpf() System Call Learning eBPF: 05. CO-RE, BTF, and Libbpf Learning eBPF: 06. The eBPF Verifier 2025.11.21 - 2025.12.09 运行 libbpf-bootstrap 中的示例代码，回顾 《Learning eBPF》 中的相关内容 2025.11.04 - 2025.11.19 通读 《Learning eBPF》"},{"title":"index","path":"/wiki/ebpf/ebpf.html","content":"web eBPF.io eBPF Docs github bcc: 一套用于开发高性能内核跟踪与操控程序的工具集，内置多款实用工具及示例程序 bcc: libbpf-tools: BCC 工具集的 libbpf 版本 BTFhub: 为所有未原生支持嵌入式 BTF 的已发布内核提供 BTF 文件。确保即便是无内置 BTF 支持的内核，也能有效利用 eBPF 程序的优势，从而提升各类内核版本间的兼容性 Tutorial libbpf-bootstrap：帮你快速上手一系列示例程序 eunomia-bpf: eBPF Developer Tutorial：基于示例的 eBPF 循序渐进学习指南 blog Linux Extended BPF (eBPF) Tracing Tools 👍 Head First eBPF 酷壳: eBPF 介绍 (2022) Learning eBPF the Hard Way: 从 nginx eBPF 的实现说起 (2025) BPF 学习路径总结 (2021) Linux超能力BPF技术介绍及学习分享 (2020) eBPF技术实践白皮书 (2023) GREEN MEMORY: eBPF学习笔记 (2021) 👍 觅梦随笔: #EBPF (2025) 👍 selfboot: #eBPF (2023) eBPF 核心技术与实战 (2022) 性能调优：性能调优工具eBPF和调优方法 加餐06 BCC：入门eBPF的前端工具 bookLearning eBPF Learning eBPF (2023) Learning eBPF Chinese version (⭐26): 中文翻译版本 online version Learning eBPF Chinese version (⭐2): 中文翻译版本 learning-ebpf-exercises：课后习题答案（仅供参考）"},{"title":"Memleak","path":"/wiki/ebpf/eunomia-bpf-01.html","content":"https://eunomia.dev/zh/tutorials/16-memleak/ 编译运行 安装 Rust 和 Cargo curl https://sh.rustup.rs -sSf | sh 编译 git clone https://github.com/eunomia-bpf/bpf-developer-tutorial.gitcd bpf-developer-tutorialgit submodule update --init --recursive # Synchronize submodulecd src/16-memleakmake 运行 $ ./test_memleak $ sudo ./memleak -p $(pidof test_memleak) 调试内存泄露的挑战 Valgrind memcheck: 模拟 CPU 来检查所有内存访问，但可能会导致应用程序运行速度大大减慢 堆分析器 libtcmalloc：相对较快，但仍可能使应用程序运行速度降低五倍以上 gdb：可以获取应用程序的核心转储 (coredump)，并进行后处理以分析内存使用情 Address Sanitizer (ASAN) 这些工具通常在获取核心转储时需要暂停应用程序，或在应用程序终止后才能调用 free() 函数。 Memleak 实现原理memleak 的工作方式类似于在内存分配和释放路径上安装监控设备。它通过在内存分配和释放函数中插入 eBPF 程序来达到这个目标。 当分配内存的函数被调用时，memleak 就会记录一些重要信息，如调用者的进程 ID（PID）、分配的内存地址以及分配的内存大小等。 当释放内存的函数被调用时，memleak 则会在其内部的映射表（map）中删除相应的内存分配记录。 这种机制使得 memleak 能够准确地追踪到哪些内存块已被分配但未被释放。 用户态对于用户态的常用内存分配函数，如 malloc 和 calloc 等，memleak 利用了用户态探测（uprobe）技术来实现监控。 uprobe 是一种用于用户空间应用程序的动态追踪技术，它可以在运行时不修改二进制文件的情况下在任意位置设置断点，从而实现对特定函数调用的追踪。 内核态对于内核态的内存分配函数，如 kmalloc 等，memleak 则选择使用了 tracepoint 来实现监控。 Tracepoint 是一种在 Linux 内核中提供的动态追踪技术，它可以在内核运行时动态地追踪特定的事件，而无需重新编译内核或加载内核模块。 Memleak 代码实现数据结构alloc_info: 内存分配的基本信息 struct alloc_info __u64 size; // 分配的内存大小\t__u64 timestamp_ns; // 分配发生时的时间戳\tint stack_id; // 分配时的调用堆栈 ID; combined_alloc_info: union combined_alloc_info struct __u64 total_size : 40; // 所有未释放的总内存大小 __u64 number_of_allocs : 24; // 所有未释放的总分配次数\t;\t__u64 bits;; total_size 和 number_of_allocs 在存储时共有一个 unsigned long long 类型的变量 bits 可以通过在成员变量 bits 上进行位运算，来访问和修改 total_size 和 number_of_allocs mapssizes: 存储每个进程的分配大小 key: pid value: 内存分配的大小 struct __uint(type, BPF_MAP_TYPE_HASH);\t__type(key, pid_t);\t__type(value, u64);\t__uint(max_entries, 10240); sizes SEC(.maps); allocs: 存储每个内存分配的详细信息 key: 内存地址 value: struct __uint(type, BPF_MAP_TYPE_HASH);\t__type(key, u64); /* address */\t__type(value, struct alloc_info);\t__uint(max_entries, ALLOCS_MAX_ENTRIES); allocs SEC(.maps); // 存储所有未释放分配的总大小和总次数struct __uint(type, BPF_MAP_TYPE_HASH);\t__type(key, u64); /* stack id */\t__type(value, union combined_alloc_info);\t__uint(max_entries, COMBINED_ALLOCS_MAX_ENTRIES); combined_allocs SEC(.maps); // 在用户空间和内核空间之间传递内存指针struct __uint(type, BPF_MAP_TYPE_HASH);\t__type(key, u64);\t__type(value, u64);\t__uint(max_entries, 10240); memptrs SEC(.maps); // 存储堆栈 IDstruct __uint(type, BPF_MAP_TYPE_STACK_TRACE);\t__type(key, u32); stack_traces SEC(.maps);"},{"title":"00. Running the example code","path":"/wiki/ebpf/learning-ebpf-00.html","content":"项目地址：https://github.com/lizrice/learning-ebpf env WSL2 Ubuntu 24.04 sudo apt-get install git cmake gdb build-essential sudo apt-get install clang clang-tidy clang-format pkg-configsudo apt-get install llvmsudo apt-get install libclang-devsudo apt-get install zlib1g-devsudo apt-get install libelf-dev Install this repogit clone --recurse-submodules https://github.com/lizrice/learning-ebpfcd learning-ebpf Building libbpf and installing header filescd libbpf/srcmake install cd ../.. Building bpftoolcd ..git clone --recurse-submodules https://github.com/libbpf/bpftool.gitcd bpftool/src make install"},{"title":"01. What Is eBPF, and Why Is It Important?","path":"/wiki/ebpf/learning-ebpf-01.html","content":"eBPF 是一种革命性的内核技术，允许开发者编写自定义代码并动态加载到内核中，从而改变内核的行为。这种技术使得新一代高性能网络、可观察性和安全工具成为可能。 使用 eBPF 可以做的事情包括但不限于： 几乎对系统的任何方面的性能追踪 具有内置可见性的高性能网络 检测并（可选地）阻止恶意活动 eBPF’s Roots: The Berkeley Packet Filter我们今天所说的 “eBPF” 起源于 BSD 数据包过滤器 (BSD Packet Filter)，最早在 1993 年的一篇论文中提出。 该论文讨论了一种能够运行过滤器的伪机器，这些过滤器是用来决定是否接受或拒绝网络数据包的程序。这些程序是用 BPF 指令集编写的，这是一组通用的 32 位指令，与汇编语言非常相似。 ldh [12]jeq #ETHERTYPE IP, L1, L2L1: ret #TRUEL2: ret #0 这段简短的代码过滤掉不是互联网协议（IP 协议）的数据包。 该过滤器的输入是一个以太网数据包，第一条指令（ldh）从该数据包的第 12 字节开始加载一个 2 字节的值。 指令（jeq）将该值与代表 IP 数据包的值进行比较。如果匹配，则执行跳转到标记为 L1 的指令，并通过返回一个非零值（这里标识为 #TRUE）来接受数据包。 如果不匹配，则数据包不是 IP 数据包，通过返回 0 来拒绝该数据包。 您可以想象（或参考该论文找到示例）更复杂的过滤程序。重要的是，过滤器的作者可以编写自己的自定义程序在内核中执行，而这正是 eBPF 的核心功能。 BPF 是指 “Berkeley Packet Filter”，它首次引入 Linux 是在 1997 年的内核版本 2.1.75 中，作为一种高效的捕获数据包的方法用于 tcpdump 工具。 2012 年，seccomp-bpf 在内核版本 3.5 中引入。这使得 BPF 程序可以用来决定是否允许用户空间应用程序进行系统调用。"},{"title":"02. eBPF’s “Hello World”","path":"/wiki/ebpf/learning-ebpf-02.html","content":"2.1 BCC’s “Hello World”示例 [hello.py]: 一个使用 BCC 的 Python 库实现的 eBPF “Hello World” 应用 #!/usr/bin/python3from bcc import BPFprogram = rint hello(void *ctx) bpf_trace_printk(Hello World!); return 0;b = BPF(text=program)syscall = b.get_syscall_fnname(execve)b.attach_kprobe(event=syscall, fn_name=hello)b.trace_print() 这段代码由两部分组成： the eBPF program: 运行在内核中 user space code: 加载 eBPF 程序到内核中，并且读取其生成的跟踪信息 2.1.1 The eBPF programint hello(void *ctx) bpf_trace_printk(Hello World!); return 0; 这个 eBPF 程序所做的只是使用一个辅助函数(helper function) bpf_trace_printk() 来写一条消息。 内核中的 bpf_trace_printk() 辅助函数总是将输出发送到同一个预定义的伪文件位置：/sys/kernel/debug/tracing/trace_pipe。 2.1.2 user space code 创建 BPF 对象 b = BPF(text=program) 将hello函数附加到系统调用 execve。（只要机器上启动新的可执行文件，该程序就会被触发。） syscall = b.get_syscall_fnname(execve)b.attach_kprobe(event=syscall, fn_name=hello) 读取内核输出的跟踪信息并将其输出到屏幕上 b.trace_print() 2.2 Running “Hello World”NOTE:由于 eBPF 非常强大，因此需要特殊权限才能使用它。权限会自动分配给 root 用户，因此最简单的方法是以 root 身份运行 eBPF 程序，或使用 sudo 命令。 $ ./hello.py b ...-308664 [007] ...21 95181.438414: bpf_trace_printk: Hello World!b ...-308666 [003] ...21 95181.441516: bpf_trace_printk: Hello World!b ...-308665 [004] ...21 95181.443144: bpf_trace_printk: Hello World!b ...-308667 [002] ...21 95181.489473: bpf_trace_printk: Hello World!b ...-308668 [004] ...21 95181.492334: bpf_trace_printk: Hello World! eBPF 程序可用于动态更改系统行为。无需重新启动机器或重启现有进程。eBPF 代码一旦附加到事件上，就会立即生效。 无需更改其他应用程序，即可使它们对 eBPF 可见。 2.3 BPF Maps一个更好的从 eBPF 程序中获取信息的方法。 map 可以用于在多个 eBPF 程序之间共享数据，或在用户空间应用程序与内核中运行的 eBPF 代码之间进行通信。 典型的用途包括： 用户空间向 eBPF 程序写入待其获取的配置信息 eBPF 程序存储状态，以供另一个 eBPF 程序（或同一程序后续运行时）调取 eBPF 程序将结果或指标写入 map，供用户空间应用调取并展示结果 2.3.1 BPF Maps 类型定义bpf_map_typehttps://elixir.bootlin.com/linux/v5.15.86/source/include/uapi/linux/bpf.h#L878 BPF_MAP_TYPE_HASH BPF_MAP_TYPE_ARRAY 针对特定类型的操作进行了优化: BPF_MAP_TYPE_QUEUE: 先进先出 队列 BPF_MAP_TYPE_STACK: 先进后出 栈 BPF_MAP_TYPE_LRU_HASH: LRU 最近最少使用 BPF_MAP_TYPE_LRU_PERCPU_HASH: precpu BPF_MAP_TYPE_LPM_TRIE: 最长前缀匹配 BPF_MAP_TYPE_BLOOM_FILTER: 布隆过滤器 (一种概率数据结构，旨在提供非常快速的元素存在性检查) 保存特定类型对象的信息： BPF_MAP_TYPE_SOCKMAP：保存有关套接字的信息，并被网络相关的 eBPF 程序用来重定向流量 BPF_MAP_TYPE_DEVMAP：保存有关网络设备的信息，并被网络相关的 eBPF 程序用来重定向流量 存储一组索引的 eBPF 程序： BPF_MAP_TYPE_PROG_ARRAY：用于实现尾调用（tail calls），即一个程序可以调用另一个程序 存储关于 map 的信息： BPF_MAP_TYPE_ARRAY_OF_MAPS BPF_MAP_TYPE_HASH_OF_MAPS per-cpu 版本： BPF_MAP_TYPE_PERCPU_HASH BPF_MAP_TYPE_PERCPU_ARRAY: 每个 CPU 核心对于该 map 都有各自的版本，并且内核使用不同的内存块来存储它们。 内核文档中的相关信息： BPF mapshttps://docs.kernel.org/bpf/maps.html 2.3.2 Hash Table Map示例 [hello-map.py]：显示不同用户运行程序的次数。 // 定义一个 hash table mapBPF_HASH(counter_table);int hello(void *ctx) u64 uid; u64 counter = 0; u64 *p; // helper function, 获取触发此 kprobe 事件的进程的用户 ID // user ID 保存在返回的 64 位值的低 32 位中; 高 32 位保存 group ID uid = bpf_get_current_uid_gid() 0xFFFFFFFF; // 在哈希表中查找与 user ID 匹配的键条目 p = counter_table.lookup(uid); if (p != 0) counter = *p; counter++; // 更新哈希表中该 user ID 的 counter 值 counter_table.update(uid, counter); return 0; 你可能会注意到代码中的这两行并不是标准的 c 代码， p = counter_table.lookup(uid);counter_table.update(uid, counter); BCC 的 C 版本实际上是一种类 C 语言，BCC 在将代码发送到编译器之前会对其进行重写。 与 hello.py 不同的地方： while True: sleep(2) s = for k,v in b[counter_table].items(): s += fID k.value: v.value\\t print(s) 运行： $ ./hello-map.py ID 1000: 7ID 1000: 14ID 0: 1 ID 1000: 20 $ ls$ sudo ls 2.3.2 Perf and Ring Buffer MapsPerf Maps示例 [hello-buffer.py]： BPF_PERF_OUTPUT(output); struct data_t int pid; int uid; char command[16]; char message[12];; int hello(void *ctx) struct data_t data = ; char message[12] = Hello World; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); bpf_probe_read_kernel(data.message, sizeof(data.message), message); output.perf_submit(ctx, data, sizeof(data)); return 0; b = BPF(text=program) syscall = b.get_syscall_fnname(execve)b.attach_kprobe(event=syscall, fn_name=hello) def print_event(cpu, data, size): data = b[output].event(data) print(fdata.pid data.uid data.command.decode() data.message.decode()) b[output].open_perf_buffer(print_event) while True: b.perf_buffer_poll() 运行： $ ./hello-buffer.py 339833 1000 sh Hello World339834 1000 bash Hello World339836 0 sudo Hello World339837 1000 node Hello World 程序类型和触发事件的类型决定了可用的上下文(context)信息集合以及可用于检索信息的有效辅助函数集合。 上下文信息的可用性使得 eBPF 代码在可观测性方面极具价值。每当事件发生时，eBPF 程序不仅可以报告事件发生的事实，还可以报告触发事件的相关信息。由于所有这些信息都可以在内核内收集，而无需同步上下文切换到用户空间，因此性能也非常高。 Ring BufferNOTE:内核版本 5.8 及以上。 环形缓冲区 (Ring Buffer) 并不是 eBPF 独有的。 可以将环形缓冲区想象为一个环形的内存片段，具有独立的写指针(write pointer)和读指针(read pointer)。 写操作： 任意长度的数据从写指针(write pointer)所在的位置写入，数据的长度信息包含在该数据的头部中。 写指针(write pointer)移动到该数据的末尾，为下一次写操作做准备。 读操作： 数据从读指针(read pointer)所在的位置开始读取，使用头部的信息来确定要读取的长度。 读指针(read pointer)指向下一个可用的数据片段。 读指针(read pointer)与写指针(write pointer)沿着相同的方向移动。 如果读指针(read pointer)追上了写指针(write pointer)，表示没有数据可读。 如果写操作会使写指针(write pointer)超过读指针(read pointer)，数据将不会被写入，并且 drop counter 会增加。读操作会同时读取 drop counter 来查看自上次成功读取以来是否有数据丢失。 相关阅读： BPF ringbuf vs BPF perfbufhttps://nakryiko.com/posts/bpf-ringbuf/ 2.3.3 Function Calls在早期，eBPF 程序不允许调用辅助函数以外的其他函数。为了解决这个问题，程序员通常会指示编译器始终内联（always inline）他们的函数，如下所示： static __always_inline void my_function(void *ctx, int val) 如图，右侧显示了内联函数时的情况：没有跳转指令；相反，在调用函数内直接包含函数的指令副本。 有时编译器可能会出于优化目的，选择内联一个函数。这也是为什么可能无法附加 kprobe 到某些内核函数的原因之一。 NOTE:从 Linux 内核 4.16 和 LLVM 6.0 开始，解除了需要将函数内联的限制，以便 eBPF 程序员可以更自然地编写函数调用。 2.3.4 Tail CallseBPF 中的另一种将复杂功能拆分为更小模块的机制：尾调用。 正如 ebpf.io 所描述的那样，“尾调用可以调用并执行另一个 eBPF 程序，并替换执行上下文(context)，类似于 execve() 系统调用对常规进程的操作。” 换句话说，尾调用完成后执行不会返回给调用者。 NOTE:尾调用绝不仅仅限于 eBPF 编程。尾调用的总体动机是避免在函数递归调用时一遍又一遍地增加栈帧，最终可能导致栈溢出错误。尾调用允许调用一系列函数而不增加栈。这在 eBPF 中特别有用，因为栈被限制为 512 字节。 尾调用使用 bpf_tail_call() 辅助函数来完成，其签名如下： long bpf_tail_call(void *ctx, struct bpf_map *prog_array_map, u32 index) ctx: 将上下文从主动发起函数调用的 eBPF 程序段传递给被调用的目标程序。 prog_array_map: 一个 BPF_MAP_TYPE_PROG_ARRAY 类型的 eBPF map，用于保存一组文件描述符，这些描述符用于标识 eBPF 程序。 index: 应调用该组 eBPF 程序中的哪个程序。 这个辅助函数的特别之处在于：如果它成功执行，将永远不会返回。当前运行的 eBPF 程序的栈会被被调用的程序替换。如果指定的程序不存在于 map 中，则可能会失败。在这种情况下，调用程序会继续执行。 用户态代码必须将所有 eBPF 程序加载到内核中(与常规操作一致)，同时还需完成程序数组映射(prog_array_map)的初始化配置。 示例 [hello-tail.py]： // 定义一个名称为 syscall ，类型为 BPF_MAP_TYPE_PROG_ARRAY 的 eBPF map，可容纳 500 个元素BPF_PROG_ARRAY(syscall, 500);int hello(struct bpf_raw_tracepoint_args *ctx) int opcode = ctx-args[1]; // 在编译前，BCC 会重写为 bpf_tail_call(ctx, syscall, index); syscall.call(ctx, opcode); // 如果尾调用成功，下面这行打印将永远不会被执行 bpf_trace_printk(Another syscall: %d, opcode); return 0;// 一个会被载入 prog_array_map 的程序int hello_exec(void *ctx) bpf_trace_printk(Executing a program); return 0;// 一个会被载入 prog_array_map 的程序int hello_timer(struct bpf_raw_tracepoint_args *ctx) int opcode = ctx-args[1]; switch (opcode) case 222: bpf_trace_printk(Creating a timer); break; case 226: bpf_trace_printk(Deleting a timer); break; default: bpf_trace_printk(Some other timer operation); break; return 0;int ignore_opcode(void *ctx) return 0; 用户空间代码(user space code)： b = BPF(text=program)b.attach_raw_tracepoint(tp=sys_enter, fn_name=hello)ignore_fn = b.load_func(ignore_opcode, BPF.RAW_TRACEPOINT)exec_fn = b.load_func(hello_exec, BPF.RAW_TRACEPOINT)timer_fn = b.load_func(hello_timer, BPF.RAW_TRACEPOINT)prog_array = b.get_table(syscall)# Ignore all syscalls initiallyfor i in range(len(prog_array)): prog_array[ct.c_int(i)] = ct.c_int(ignore_fn.fd)# Only enable few syscalls which are of the interestprog_array[ct.c_int(59)] = ct.c_int(exec_fn.fd)prog_array[ct.c_int(222)] = ct.c_int(timer_fn.fd)prog_array[ct.c_int(223)] = ct.c_int(timer_fn.fd)prog_array[ct.c_int(224)] = ct.c_int(timer_fn.fd)prog_array[ct.c_int(225)] = ct.c_int(timer_fn.fd)prog_array[ct.c_int(226)] = ct.c_int(timer_fn.fd)b.trace_print() 运行： $ ./hello-tail.py NOTE:自内核版本 4.2 起，eBPF 开始支持尾调用，但在很长一段时间内，尾调用与 BPF 到 BPF 函数调用（BPF to BPF function calls）是不兼容的。这一限制在内核版本 5.10 中被解除。 尾调用最多可以链式组合达到 33 次，每个 eBPF 程序的指令复杂度限制为 100 万条指令。 2.4 Summary“extended” BPF 区别于 BPF 的几个特征： 辅助函数 (helper funciton) BPF map 尾调用： 尾调用使用 bpf_tail_call() 辅助函数来完成，如果它成功执行，将永远不会返回。 当前运行的 eBPF 程序的栈会被被调用的程序替换。 如果指定的程序不存在于 map 中，则可能会失败。在这种情况下，调用程序会继续执行。 2.5 Exerciseslearning-ebpf-exerciseshttps://github.com/gaoyangu/learning-ebpf-exercises"},{"title":"03. Anatomy of an eBPF Program","path":"/wiki/ebpf/learning-ebpf-03.html","content":"eBPF 程序从源代码到执行过程所经历的各个阶段: C（或 Rust）源代码会被编译为 eBPF 字节码，而这些 eBPF 字节码又会通过即时编译（JIT） 或解释的方式，转换为原生的机器码指令。 eBPF 程序是一组 eBPF 字节码指令。目前，绝大多数 eBPF 代码是用 C 语言编写的，然后编译成 eBPF 字节码。这些字节码运行在内核中的 eBPF 虚拟机内。 3.1 The eBPF Virtual MachineeBPF 虚拟机接收以 eBPF 字节码指令形式表示的程序，并将这些指令转换为在 CPU 上运行的原生机器指令。 早期，字节码指令是在内核中解释执行的。目前，很大程度上被即时（just-in-time，JIT）编译替代。编译(compilation)意味着当程序加载到内核时，从字节码到本机机器指令的转换只发生一次。 eBPF 字节码由一组指令组成，这些指令作用于（虚拟的）eBPF 寄存器。 3.1.1 eBPF RegisterseBPF 虚拟机使用 10 个通用寄存器，编号从 0 到 9。此外，还有一个寄存器 10 被用作栈帧指针（只能读取，不能写入）。在执行 BPF 程序时，这些寄存器中存储的值用于跟踪状态。 可以在 Linux 内核源代码的 includeuapilinuxbpf.h 头文件中看到 BPF_REG_0 到 BPF_REG_10 的定义： /* Register numbers */enum BPF_REG_0 = 0, // 函数的返回值\tBPF_REG_1, // 在 eBPF 程序开始执行之前，上下文(context)参数被加载到该寄存器\tBPF_REG_2,\tBPF_REG_3,\tBPF_REG_4,\tBPF_REG_5,\tBPF_REG_6,\tBPF_REG_7,\tBPF_REG_8,\tBPF_REG_9,\tBPF_REG_10, // 栈帧指针 (a stack frame pointer)\t__MAX_BPF_REG,; 在调用 eBPF 代码中的函数之前，该函数的参数被放置在 BPF_REG_1 到 BPF_REG_5 中（如果参数少于五个，则不会使用所有寄存器）。 3.1.2 eBPF Instructionsincludeuapilinuxbpf.h 中定义了一个名为 bpf_insn 的结构体，代表一个 BPF 指令。 struct bpf_insn __u8\tcode; /* opcode */\t__u8\tdst_reg:4;\t/* dest register */\t__u8\tsrc_reg:4;\t/* source register */\t__s16\toff; /* signed offset */\t__s32\timm; /* signed immediate constant */; code: 每条指令都包含一个操作码（opcode），该操作码定义了这条指令需要执行的操作：例如，将一个数值加到寄存器的内容中，或者跳转到程序内的另一条指令处。 Unofficial eBPF spec 中列出了有效指令的列表 dst_reg 和 src_reg: 不同的操作可能涉及最多两个寄存器。 off 和 imm: 根据操作的不同，可能还会有一个偏移值 off 和或 一个“立即” (immediate) 整数值 bpf_insn 结构体的长度为 64 位（8 字节）。然而，有时一条指令可能需要多于 8 字节的空间。在这些情况下，指令使用总长度为 16 字节的宽指令编码 (wide instruction encoding)。 当加载到内核中时，eBPF 程序的字节码由一系列 bpf_insn 结构体表示。验证器 (verifier) 对这些信息进行多项检查，以确保代码的运行安全。 相关阅读： BPF and XDP Reference Guidehttps://docs.cilium.io/en/stable/bpf/ the kernel documentationhttps://docs.kernel.org/bpf/standardization/instruction-set.html 3.2 eBPF “Hello World” for a Network Interface常见的约定:为了将 eBPF 程序与可能存在于相同源代码目录中的用户空间 C 代码区分开来，将 eBPF 程序放在以文件名以 bpf.c 结尾的文件中。 示例 [hello.bpf.c]: 这是一个附加到网络接口上的 XDP 钩子点的 eBPF 程序示例。您可以将 XDP 事件视为在网络数据包到达（物理或虚拟）网络接口时立即触发。 #include linux/bpf.h#include bpf/bpf_helpers.h// 全局变量int counter = 0;// 定义一个 eXpress Data Path（XDP）类型的 eBPF 程序SEC(xdp)int hello(struct xdp_md *ctx) bpf_printk(Hello World %d, counter); counter++; return XDP_PASS;char LICENSE[] SEC(license) = Dual BSD/GPL; XDP_PASS: 这是一条告知内核的判定结果，指示其按常规流程处理该网络数据包。 SEC(license): 定义许可证字符串的 SEC() 宏，这是 eBPF 程序的关键要求。 内核中的一些 BPF 辅助函数被定义为“仅限 GPL（GPL only）”。如果您想使用这些函数，您的 BPF 代码必须声明为具有 GPL 兼容的许可证。 如果声明的许可证与程序使用的函数不兼容，验证器会拒绝加载。 3.3 Compiling an eBPF Object FileeBPF 源代码需要编译成 eBPF 虚拟机能理解的机器指令：eBPF 字节码。Clang 编译器需要指定 -target bpf。 以下是从 Makefile 中截取的用于进行编译的部分： %.bpf.o: %.bpf.c\tclang \\ -target bpf \\ -I/usr/include/$(shell uname -m)-linux-gnu \\ -g \\ -O2 -o $@ -c $ 这将从 hello.bpf.c 源代码生成一个名为 hello.bpf.o 的目标文件。 这里的 -g 标志是可选的，它可以生成调试信息，这样当你查看目标文件时，可以同时看到源代码与字节码。 3.4 Inspecting an eBPF Object File使用 file命令来确定文件的内容： $ file hello.bpf.ohello.bpf.o: ELF 64-bit LSB relocatable, eBPF, version 1 (SYSV), with debug_info, not stripped 这表明它是一个 ELF（Executable and Linkable Format，可执行和可链接格式）文件，包含 eBPF 代码，适用于具有 LSB（最低有效位）架构的 64 位平台。 如果在编译步骤中使用了 -g 标志，它将包含调试信息。 可以使用 llvm-objdump 进一步检查此目标文件，以查看其中的 eBPF 指令： $ llvm-objdump -S hello.bpf.ohello.bpf.o: file format elf64-bpfDisassembly of section xdp:0000000000000000 hello:; bpf_printk(Hello World %d, counter); 0: 18 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r6 = 0x0 ll 2: 61 63 00 00 00 00 00 00 r3 = *(u32 *)(r6 + 0x0) 3: 18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r1 = 0x0 ll 5: b7 02 00 00 0f 00 00 00 r2 = 0xf 6: 85 00 00 00 06 00 00 00 call 0x6; counter++; 7: 61 61 00 00 00 00 00 00 r1 = *(u32 *)(r6 + 0x0) 8: 07 01 00 00 01 00 00 00 r1 += 0x1 9: 63 16 00 00 00 00 00 00 *(u32 *)(r6 + 0x0) = r1; return XDP_PASS; 10: b7 00 00 00 02 00 00 00 r0 = 0x2 11: 95 00 00 00 00 00 00 00 exit 在每行字节码的左侧，可以看到该指令在内存中相对于 hello 所在位置的偏移量。eBPF 指令长度通常是 8 字节，在 64 位平台上，每个内存位置可以容纳 8 字节，因此偏移量通常会每条指令递增 1。 然而，该程序中的第一条指令恰好需要 16 字节的宽指令编码，以便将寄存器 6 设置为 64 位值 0。因此，输出的第二行指令的偏移量为 2。 5: b7 02 00 00 0f 00 00 00 r2 = 0xf 操作码 (opcode) 是 0xb7, 查阅 Unofficial eBPF spec 其对应的伪代码是 dst = imm，可以理解为将目标寄存器设置为立即数。 0x02 代表寄存器 2 0x0f 是立即数，代表十进制中的 15 因此，这条指令可以理解为：将 Register 2 设置为值 15。 10: b7 00 00 00 02 00 00 00 r0 = 0x2 与之类似的，该指令表示将 Register 0 设置为值 2。 3.5 Loading the Program into the KernelNOTE:您可能需要以 root 身份（或使用 sudo）获得 bpftool 所需的 BPF 权限。 使用 bpftool 将程序加载到内核。该操作从已编译的目标文件中加载 eBPF 程序，并将其固定到路径 /sys/fs/bpf/hello 下。 $ bpftool prog load hello.bpf.o /sys/fs/bpf/hello 查看是否加载成功： $ ls /sys/fs/bpfhello 3.6 Inspecting the Loaded Program查看加载到内核中的所有程序: $ bpftool prog list...174: xdp name hello tag d35b94b4c0c10efb gpl loaded_at 2025-12-12T11:42:16+0800 uid 0 xlated 96B jited 71B memlock 4096B map_ids 90,91 btf_id 187 将输出内容整理为格式化的 JSON 格式: $ bpftool prog show id 174 --pretty id: 174, type: xdp, name: hello, tag: d35b94b4c0c10efb, gpl_compatible: true, loaded_at: 1765510936, uid: 0, orphaned: false, bytes_xlated: 96, jited: true, bytes_jited: 71, bytes_memlock: 4096, map_ids: [90,91 ], btf_id: 187 uid: 0, 表示 root 用户加载的程序。 bytes_xlated: 96, 此程序中有 96 字节的翻译后的 eBPF 字节码。 jited: true,bytes_jited: 71, 该程序已经过 JIT 编译，编译产生了 71 字节的机器码。 bytes_memlock: 4096, 此程序保留了 4096 字节的内存，这些内存不会被分页。 map_ids: [90,91], 该程序引用了 ID 为 90 和 91 的 BPF map。(与全局变量有关)。 btf_id: 187 表示该程序有一个 BTF 信息块。只有在使用 -g 标志进行编译时，才会将此信息包含在目标文件中。 3.6.1 The BPF Program Tag标签（tag）是所有程序指令的 SHA（Secure Hashing Algorithm，安全哈希算法）散列值，可以用作程序的另一个标识符。 NOTE:每次加载或卸载程序时，ID 可能会变化，但标签(tag)将保持不变。 bpftool prog show id 174bpftool prog show name hellobpftool prog show tag d35b94b4c0c10efbbpftool prog show pinned /sys/fs/bpf/hello 3.6.2 The Translated Bytecodebytes_xlated 字段告诉我们有多少字节的“翻译后”eBPF 代码。这是 eBPF 字节码在通过验证器之后（并可能被内核修改）得到的结果。 查看翻译后的 eBPF 代码： $ bpftool prog dump xlated name helloint hello(struct xdp_md * ctx):; bpf_printk(Hello World %d, counter); 0: (18) r6 = map[id:24][0]+0 2: (61) r3 = *(u32 *)(r6 +0) 3: (18) r1 = map[id:25][0]+0 5: (b7) r2 = 15 6: (85) call bpf_trace_printk#-82848; counter++; 7: (61) r1 = *(u32 *)(r6 +0) 8: (07) r1 += 1 9: (63) *(u32 *)(r6 +0) = r1; return XDP_PASS; 10: (b7) r0 = 2 11: (95) exit 这与之前从 llvm-objdump 输出中看到的反汇编代码非常相似。偏移地址相同，指令也相似。例如，可以看到偏移量为 5 的指令是 r2 = 15。 3.6.3 The JIT-Compiled Machine Code翻译后的字节码非常底层，但它还不完全是机器码。eBPF 会使用即时编译器（JIT），将 eBPF 字节码转换为可在目标 CPU 上原生运行的机器码。 bytes_jited 字段显示，经过该转换后，程序的长度为 71 字节。 bpftool 工具可以生成这份即时编译（JIT）代码的汇编语言 dump 文件（即汇编代码快照）: $ bpftool prog dump jited name helloint hello(struct xdp_md * ctx):bpf_prog_d35b94b4c0c10efb_hello:; bpf_printk(Hello World %d, counter); 0: hint #34 4: stp x29, x30, [sp, #-16]! 8: mov x29, sp c: stp x19, x20, [sp, #-16]! 10: stp x21, x22, [sp, #-16]! 14: stp x25, x26, [sp, #-16]! 18: mov x25, sp 1c: mov x26, #0 20: hint #36 24: sub sp, sp, #0 28: mov x19, #-140733193388033 2c: movk x19, #2190, lsl #16 30: movk x19, #49152 34: mov x10, #0 38: ldr w2, [x19, x10] 3c: mov x0, #-205419695833089 40: movk x0, #709, lsl #16 44: movk x0, #5904 48: mov x1, #15 4c: mov x10, #-6992 50: movk x10, #29844, lsl #16 54: movk x10, #56832, lsl #32 58: blr x10 5c: add x7, x0, #0; counter++; 60: mov x10, #0 64: ldr w0, [x19, x10] 68: add x0, x0, #1 6c: mov x10, #0 70: str w0, [x19, x10]; return XDP_PASS; 74: mov x7, #2 78: mov sp, sp 7c: ldp x25, x26, [sp], #16 80: ldp x21, x22, [sp], #16 84: ldp x19, x20, [sp], #16 88: ldp x29, x30, [sp], #16 8c: add x0, x7, #0 90: ret 注： 我在执行该命令时，并没有执行成功，而是返回如下错误信息： $ bpftool prog dump jited name helloError: No JIT disassembly support 结合查到的信息，应该是我使用的内核（Ubuntu 24.04）没有编译这些功能。 $ zcat /proc/config.gz | grep -E CONFIG_BPF_JIT|CONFIG_BPF_JIT_DISASM|CONFIG_DEBUG_INFO_BPFCONFIG_BPF_JIT=yCONFIG_BPF_JIT_ALWAYS_ON=yCONFIG_BPF_JIT_DEFAULT_ON=y# 值为 2 表示启用 JIT + 反汇编# 值为 1 表示仅启用JIT$ cat /proc/sys/net/core/bpf_jit_enable 3.7 Attaching to an EventHello World 这个 eBPF 程序被加载到了内核中，但此时它还没有与任何事件 (Event) 相关联，因此不会有任何触发条件使其运行。它需要被挂载到某个事件(Event)上。 eBPF 程序类型必须与其要挂载的事件类型相匹配。 使用 bpftool 将示例 eBPF 程序附加到网络接口上的 XDP 事件： $ bpftool net attach xdp tag d35b94b4c0c10efb dev eth0 查看挂载到网络协议栈 (network-attached) 的 BPF 程序: $ bpftool net listxdp:eth0(2) driver id 174tc:flow_dissector:netfilter: 这份输出中还可以看到网络协议栈中其他可挂载 eBPF 程序的潜在事件，如 tc 和 flow_dissector。 查看网络接口： $ ip link1: lo: LOOPBACK,UP,LOWER_UP mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: eth0: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 xdp qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether 00:01:02:03:04:05 brd ff:ff:ff:ff:ff:ff prog/xdp id 174 name hello tag d35b94b4c0c10efb jited 查看输出信息： $ cat /sys/kernel/debug/tracing/trace_pipe 或者： $ bpftool prog tracelog 3.8 全局变量eBPF map 是一种可以从 eBPF 程序或者用户空间访问的数据结构。 同一程序的不同流程可以多次访问同一个 map，多个程序也可以访问同一个 map。由于这些特性，eBPF map 可以作为全局变量使用。 NOTE:eBPF 在 2019 年才支持全局变量。 查看加载到内核中的 map $ bpftool map list165: array name hello.bss flags 0x400 key 4B value 4B max_entries 1 memlock 4096B btf_id 254166: array name hello.rodata flags 0x80 key 4B value 15B max_entries 1 memlock 4096B btf_id 254 frozen 查看 map 的内容 在从 C 程序编译的目标文件中，bss 段通常保存全局变量 $ bpftool map dump name hello.bss[ value: .bss: [ counter: 11127 ] ] 只有当 BTF 信息可用时，bpftool 才能美观地打印出 map 中的字段名；而要包含该 BTF 信息，需在编译时添加 -g 标志。 $ bpftool map dump name hello.rodata[ value: .rodata: [ hello.____fmt: Hello World %d ] ] 3.9 Detaching the Program 将程序从网络接口分离（detach） $ bpftool net detach xdp dev eth0 列出挂载到网络栈的 BPF 程序 $ bpftool net listxdp:tc:flow_dissector:netfilter: 但是，程序仍加载在内核中： $ bpftool prog show name hello395: xdp name hello tag 9d0e949f89f1a82c gpl loaded_at 2022-12-19T18:20:32+0000 uid 0 xlated 48B jited 108B memlock 4096B map_ids 4 3.10 Unloading the Program目前，还没有 bpftool prog load 的反向命令，可以通过删除固定的伪文件来从内核中移除该程序： $ rm /sys/fs/bpf/hello$ bpftool prog show name hello 3.11 BPF to BPF Calls在上一章中看到了尾调用的应用，现在还可以从 eBPF 程序中调用函数。 示例：[hello-func.bpf.c] static __attribute((noinline)) int get_opcode(struct bpf_raw_tracepoint_args *ctx) return ctx-args[1]; __attribute((noinline)) 确保编译器不会内联该函数 调用该函数的 eBPF 函数如下所示： SEC(raw_tp)int hello(struct bpf_raw_tracepoint_args *ctx) int opcode = get_opcode(ctx); bpf_printk(Syscall: %d, opcode); return 0; 将其编译为 eBPF 目标文件后，可以使用 bpftool 将其加载到内核中，并确认它已加载： $ bpftool prog load hello-func.bpf.o /sys/fs/bpf/hello$ bpftool prog list name hello893: raw_tracepoint name hello tag 3d9eb0c23d4ab186 gpl loaded_at 2023-01-05T18:57:31+0000 uid 0 xlated 80B jited 208B memlock 4096B map_ids 204 btf_id 302 值得注意的是在 eBPF 字节码中查看 get_opcode() 函数： $ bpftool prog dump xlated name helloint hello(struct bpf_raw_tracepoint_args * ctx):; int opcode = get_opcode(ctx); 0: (85) call pc+7#bpf_prog_cbacc90865b1b9a5_get_opcode; bpf_printk(Syscall: %d, opcode); 1: (18) r1 = map[id:39][0]+0 3: (b7) r2 = 12 4: (bf) r3 = r0 5: (85) call bpf_trace_printk#-82848; return 0; 6: (b7) r0 = 0 7: (95) exitint get_opcode(struct bpf_raw_tracepoint_args * ctx):; return ctx-args[1]; 8: (79) r0 = *(u64 *)(r1 +8); return ctx-args[1]; 9: (95) exit 其中， 0: (85) call pc+7#bpf_prog_cbacc90865b1b9a5_get_opcode 0x85 在 Unofficial eBPF spec 中可以看到该指令是函数调用 (Function call)。 因此，接下来不会继续执行下一条指令（即偏移量为 1 的指令），而是会跳过七条指令（pc+7），这意味着将执行偏移量为 8 的指令。 函数调用 (Function call) 指令需要将当前状态放在 eBPF 虚拟机的栈空间，以便在被调用函数退出时，可以在调用函数中继续执行。由于栈大小限制为 512 字节，因此 BPF 到 BPF 的调用不能嵌套得太深。 相关阅读： Assembly within! BPF tail calls on x86 and ARMhttps://blog.cloudflare.com/assembly-within-bpf-tail-calls-on-x86-and-arm/ 3.12 Summary JIT (just-in-time) compilation: 即时编译 3.13 Exerciseslearning-ebpf-exerciseshttps://github.com/gaoyangu/learning-ebpf-exercises"},{"title":"04. The bpf() System Call","path":"/wiki/ebpf/learning-ebpf-04.html","content":"如果用户空间应用程序 (user space application) 想将 eBPF 程序加载到内核中，必然会涉及到一些系统调用，这个系统调用是 bpf()。系统调用接口仅供用户空间应用程序使用。 运行在内核中的 eBPF 代码并不使用系统调用 (syscalls) 来访问映射 (maps)。eBPF 程序使用辅助函数 (helper functions) 来读写映射 (maps)。 如果你之后自己编写 eBPF 程序，大概率不需要直接调用这些 bpf() 系统调用。在后续内容中介绍了一些库，它们提供了更上层的抽象封装，能简化开发流程。 这些抽象封装基本都是直接对应你将在本章中看到的底层系统调用命令。无论你使用哪一个库，都需要掌握本章会介绍的底层操作 —— 比如加载程序、创建并访问映射等等。 查看 man 手册 可以看到 bpf() 被用来在 eBPF 映射 (map) 或程序上执行命令。其函数签名如下: int bpf(int cmd, union bpf_attr *attr, unsigned int size); cmd, 要执行的命令 attr, 指定命令参数所需的全部数据 size, attr 中数据的字节长度 示例 [hello-bufer-config.py] struct user_msg_t char message[12];;// 定义一个名为 config 的 hash table map// key: u32// vlaue: user_msg_t// 未指定时，BCC 默认都为 u64BPF_HASH(config, u32, struct user_msg_t);BPF_PERF_OUTPUT(output);struct data_t int pid; int uid; char command[16]; char message[12];;int hello(void *ctx) struct data_t data = ; struct user_msg_t *p; char message[12] = Hello World; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); p = config.lookup(data.uid); if (p != 0) bpf_probe_read_kernel(data.message, sizeof(data.message), p-message); else bpf_probe_read_kernel(data.message, sizeof(data.message), message); output.perf_submit(ctx, data, sizeof(data)); return 0; 在 python 代码中，在 config 哈希表中定义了用户 ID 0 和 1000 的消息，它们对应于该虚拟机上的 root 用户 ID 和我的用户 ID。 b[config][ct.c_int(0)] = ct.create_string_buffer(bHey root!)b[config][ct.c_int(1000)] = ct.create_string_buffer(bHi user 1000!) Linux如何查看用户ID:$ id 运行： $ ./hello-buffer-config.py 70268 1000 sh Hi user 100070270 0 sudo Hey root! $ ls$ sudo ls 查看程序运行时使用的 bpf() 系统调用： $ strace -e bpf ./hello-buffer-config.pybpf(BPF_BTF_LOAD, ...) = 3bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_PERF_EVENT_ARRAY, ...) = 4bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_HASH, ...) = 5bpf(BPF_PROG_LOAD, prog_type=BPF_PROG_TYPE_KPROBE, ... prog_name=hello, ...) = 6bpf(BPF_MAP_UPDATE_ELEM, ...) = 0 4.1 Loading BTF Data cmd: BPF_BTF_LOAD bpf(BPF_BTF_LOAD, btf=\\237\\353\\1\\0... , 32) = 3 将一块 BTF 数据加载到内核中 bpf() 系统调用的返回值（在我的示例中为 3）是引用该数据的文件描述符 如果使用的 Linux 内核版本较低，可能看不到这个命令。这与 BTF ( BPF Type Format) 有关，这一特性在 Linux 内核版本 5.1 被引入。 BTF 可以让 eBPF 程序跨不同内核版本进行移植，你可以在一台机器上编译程序，然后在另一台机器上使用它，哪怕这台机器运行的是不同的内核版本，对应拥有不同的内核数据结构。 4.2 Creating Maps cmd: BPF_MAP_CREATE：创建一个 eBPF map bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_PERF_EVENT_ARRAY, key_size=4, value_size=4, max_entries=22, ... map_name=output, ..., 80) = 4 类型为 BPF_MAP_TYPE_PERF_EVENT_ARRAY，名为 output key 和 vlaue 的长度都为 4 字节 bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_HASH, key_size=4, value_size=13, max_entries=10240, ... map_name=config, ... btf_fd=3, ..., 80) = 5 类型为 BPF_MAP_TYPE_HASH，名为 config key 的大小为 4 字节，value 的大小为 13 字节 没有指定该 table 的大小，但 BCC 默认大小为 10240 btf_fd=3，告诉内核使用之前获得的 BTF 文件描述符 3。 BTF 信息描述了数据结构的布局，将其包含在映射定义中意味着拥有关于映射中使用的键和值类型布局的信息。 4.3 Loading a Program通过以下 bpf() 系统调用将 eBPF 程序加载到内核中 bpf(BPF_PROG_LOAD, prog_type=BPF_PROG_TYPE_KPROBE, insn_cnt=47, insns=0x7408c9814000, license=GPL, ... prog_name=hello, ... expected_attach_type=BPF_CGROUP_INET_INGRESS, prog_btf_fd=3, ..., 152) = 6 prog_type: eBPF 程序的类型为 BPF_PROG_TYPE_KPROBE insn_cnt: 程序中字节码指令的数量。 insns: 构成这个 eBPF 程序的字节码指令在内存中的地址。 license: GPL 许可 prog_name: eBPF 程序的名字为 hello expected_attach_type: BPF_CGROUP_INET_INGRESS 恰好是 BPF 附加类型列表中的第一个，它的值为 0 prog_btf_fd: 告知内核，该程序要使用此前加载的哪一段 BTF 数据块。此处的数值 3 对应之前看到的、由 BPF_BTF_LOAD 系统调用返回的文件描述符 NOTE:如果程序验证失败，这个系统调用会返回负值。 4.4 Modifying a Map from User Spaceb[config][ct.c_int(0)] = ct.create_string_buffer(bHey root!)b[config][ct.c_int(501)] = ct.create_string_buffer(bHi user 501!) 可以看到这些条目被通过如下系统调用，在 map 中定义: bpf(BPF_MAP_UPDATE_ELEM, map_fd=5, key=0x7408c92a9020, value=0x7408c92a8520, flags=BPF_ANY, 32) = 0 BPF_MAP_UPDATE_ELEM 命令用于更新 map 中的键值对 BPF_ANY: 表示如果 key 在 map 中不存在，则创建它 map_fd: 正在操作的 map 的文件描述符 文件描述符是由内核为特定进程分配的，所以这个值 5 只对该特定用户空间进程有效。访问内核中同一映射（map）结构的两个用户态程序，所被分配的文件描述符数值很可能不同；同理，两个用户态程序也可能针对完全不同的映射（map），拥有相同的文件描述符数值。 使用 bpftool 查看 map 的内容： bpftool map dump name config [ key: 0, value: message: Hey root! , key: 1000, value: message: Hi user 1000! ] bpftool 是怎么知道如何格式化输出的呢？答案是，它会使用在定义该映射(map)的 BPF_MAP_CREATE 系统调用中所包含的 BTF 信息里的定义。 4.5 BPF Program and Map References 引用计数 当停止运行程序后会发生什么？你会发现程序和映射 (maps) 会被自动卸载 (unloaded)，出现这种情况的原因是内核会通过引用计数 (reference counts) 对它们进行追踪管理。 通过 bpf() 系统调用将 BPF 程序加载到内核中会返回一个文件描述符。在内核中，这个文件描述符是该程序的一个引用。发起这个系统调用的用户态进程拥有这个文件描述符；当该进程退出时，文件描述符会被释放，程序的引用计数会递减。当一个 BPF 程序的引用计数归零时，内核就会移除该程序。 4.5.1 PinningeBPF program当将程序固定(pinning)到文件系统时，会创建一个额外的引用。因此该程序会在命令执行完成后仍保持加载状态。 bpftool prog load hello.bpf.o /sys/fs/bpf/hello 这些被固定的对象并非是持久化存储到磁盘的真实文件，它们创建于一个伪文件系统之上，这个伪文件系统的行为与基于磁盘的常规文件系统类似，也具备目录和文件的结构。但这些对象都存储在内存中，这意味着系统重启之后它们就不会再保留在原来的位置。 当 BPF 程序被挂载到一个会触发它的钩子 (hook) 上时，引用计数器也会递增。引用计数的行为依赖于 BPF 的程序类型。 与追踪 (tracing) 相关（比如 kprobes 和 tracepoints）的类型，与一个用户态进程相关联（当对应的进程退出时，内核的引用计数就会递减） 附加到网络协议栈或 cgroups (control groups) 类型的程序，不与任何用户态进程相关联，即使加载它们的用户态程序退出 (exits) 了，它们仍会保留在原有位置。 如，使用 ip link 命令加载一个 XDP 类型的程序： ip link set dev eth0 xdp obj hello.bpf.o sec xdp 可以看到当命令执行完成后，使用 bpftool 仍然可以看到加载到内核中的 XDP 程序。 $ bpftool prog list…1255: xdp name hello tag 9d0e949f89f1a82c gpl loaded_at 2022-11-01T19:21:14+0000 uid 0 xlated 48B jited 108B memlock 4096B map_ids 612 eBPF mapeBPF maps 同样拥有引用计数器，当它们的引用计数降至零时，就会被清理掉。 eBPF 程序的源代码有可能会定义一个程序实际并未引用的映射。此时程序不会自动对该映射生成引用计数。 BPF(BPF_PROG_BIND_MAP)系统调用，可以将一个映射与一个程序进行关联，这样一来，就算加载程序的用户态进程退出、不再持有该映射的文件描述符引用，这个映射也不会被立即清理。 映射也可以被固定到文件系统中，用户态程序可以通过该映射的路径来获取对它的访问权限。 相关阅读： Lifetime of BPF objectshttps://facebookmicrosites.github.io/bpf/blog/2018/08/31/object-lifetime.html 4.5.2 BPF Links创建 BPF 程序引用的另一种方式。 BPF 链接为 eBPF 程序与其附加的事件之间提供了一个抽象层。BPF 链接本身可以被固定到文件系统中，这为程序创建了另一个引用。这意味着将程序加载到内核的用户空间进程可以终止，而程序仍然被加载。用户空间加载程序的文件描述符被释放，减少了程序的引用计数，但由于 BPF 链接的存在，引用计数将不为零。 本章结尾的练习中将看到 BPF 链接的实际应用。 4.6 Additional Syscalls Involved in eBPFstrace 输出中接下来显示的内容与设置 perf buffer 有关。 4.6.1 Initializing the Perf Buferbpf(BPF_MAP_UPDATE_ELEM, map_fd=4, key=0x770d75d708a0, value=0x770d75d70520, flags=BPF_ANY, 32) = 0 映射的文件描述符是 4，它代表 output perf 缓冲区映射 (buffer map)。 使用 strace 运行此示例时，显示更多系统调用： strace -e bpf,perf_event_open,ioctl,ppoll ./hello-buffer-config.py 4.6.2 Attaching to Kprobe Events当 eBPF 程序 hello 被加载到内核中后，系统分配了文件描述符 6 来表示它。要将这个 eBPF 程序挂载到某个事件上，还需要一个代表该特定事件的文件描述符。 以下是 strace 输出中的一行内容，展示了为 execve() kprobe 创建文件描述符的过程： perf_event_open(type=0x8 /* PERF_TYPE_??? */, ..., ...) = 7 根据 main 手册 ，调用 perf_event_open() 会创建一个文件描述符，该文件描述符可用于测量性能信息。 从输出可以看到，strace 无法解释值为 8 的类型参数，但如果进一步查看手册，会发现 Linux 如何支持性能测量单元（Performance Measurement Unit）的动态类型： $ cat /sys/bus/event_source/devices/kprobe/type perf_event_open() 的返回码是 7，这代表 kprobe 的 perf 事件的文件描述符，并且文件描述符 6 代表的是 eBPF 程序 hello。在 main 手册 中还解释了如何使用 ioctl() 在这两者之间创建关联: PERF_EVENT_IOC_SET_BPF: 此操作允许将 BPF 程序挂载到已有的 kprobe 追踪点事件上。其参数为一个 BPF 程序文件描述符。 这解释了您将在 strace 输出中看到的以下 ioctl() 系统调用，其中的参数指的是两个文件描述符： ioctl(7, PERF_EVENT_IOC_SET_BPF, 6) = 0 还有一个 ioctl() 调用用来启动 kprobe 事件： ioctl(7, PERF_EVENT_IOC_ENABLE, 0) = 0 完成此设置后，只要这台机器上运行 execve()，就会触发这个 eBPF 程序。 4.6.3 Setting Up and Reading Perf Events看到与 output perf 缓冲区相关的 bpf(BPF_MAP_UPDATE_ELEM) 调用重复出现几次与使用的处理器的核心数量有关。 perf_event_open(type=PERF_TYPE_SOFTWARE, size=0 /* PERF_ATTR_SIZE_??? */, config=PERF_COUNT_SW_BPF_OUTPUT, ..., -1, X, -1, PERF_FLAG_FD_CLOEXEC) = 8ioctl(Y, PERF_EVENT_IOC_ENABLE, 0) = 0bpf(BPF_MAP_UPDATE_ELEM, map_fd=4, key=0x7644407f88a0, value=0x7644407f8520, flags=BPF_ANY, 32) = 0 在上面的输出中，使用 X 的位置表示值 0、1、2 和 3 。查阅 main 手册 会看到这是 cpu，它前面的字段是 pid 或进程 ID。 当 pid -1 且 cpu 0 时，会测量指定 CPU 上所有的进程线程。 这个过程会发生四次，与使用的笔记本电脑有四个 CPU 核心的情况相对应。 这终于解释了为什么 “output” 性能事件缓冲区映射中有四个条目：每个 CPU 核心对应一个条目。 这也解释了映射类型名称 BPF_MAP_TYPE_PERF_EVENT_ARRAY 中的 “array（数组）” 部分 —— 因为这个映射并非只代表一个性能事件环形缓冲区，而是一个缓冲区数组，每个核心对应一个缓冲区。 perf_event_open() 的每次调用都会返回一个文件描述符，将其表示为 Y；这些文件描述符的值分别为 8、9、10 和 11。 ioctl ()系统调用会为每一个这类文件描述符启用性能事件输出。 BPF_MAP_UPDATE_ELEM 类型的 bpf() 系统调用会设置映射条目，使其指向每个 CPU 核心的性能事件环形缓冲区，以此指定该核心可以提交数据的位置。 用户空间代码可以在这四个输出流文件描述符上使用 ppoll()，以便无论哪个核心恰好运行给定 execue() kprobe 事件的 eBPF 程序 hello，它都可以获得数据输出。 以下是 ppoll() 的系统调用： ppoll([fd=8, events=POLLIN, fd=9, events=POLLIN, fd=10, events=POLLIN,fd=11, events=POLLIN], 4, NULL, NULL, 0) = 1 ([fd=8, revents=POLLIN]) 注： 我在运行 strace -e bpf,perf_event_open,ioctl,ppoll ./hello-buffer-config.py 时，并没有看到 ppoll 的相关调用。在将 ppoll 改为 poll 后，可以看到如下系统调用： poll([fd=8, events=POLLIN, fd=9, events=POLLIN, ...], 22, -1) = 1 ([fd=23, revents=POLLIN]) 4.7 Ring Bufers在内核版本 5.8 及以上，相比于性能事件缓冲区 (perf buffer)，更倾向于使用 BPF 环形缓冲区 (ring buffer)。这一方面是出于性能考量，另一方面也是为了确保数据的顺序性不会被打乱 —— 即便这些数据是由不同的 CPU 核心提交的。环形缓冲区的实现形式为单个缓冲区，供所有核心共享使用。 示例 [hello-ring-buffer-config.py]: 创建 output 环形缓冲区映射的 bpf() 系统调用如下所示： bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_RINGBUF, key_size=0, value_size=0, max_entries=4096, ..., map_name=output, ..., 80) = 4 在撰写本文时，BCC 使用在前面展示的 ppoll 机制来处理 perf 缓冲区，但它使用较新的 epoll 机制来等待环形缓冲区的数据。 ppoll[hello-buffer-config.py] 中产生的 ppoll() 系统调用如下： ppoll([fd=8, events=POLLIN, fd=9, events=POLLIN, fd=10, events=POLLIN,fd=11, events=POLLIN], 4, NULL, NULL, 0) = 1 ([fd=8, revents=POLLIN]) 需要注意的是，这里传入了一组文件描述符（8、9、10、11），用户态进程正是要从这些描述符中读取数据。每当这个 poll 事件返回数据时，都必须再次调用 ppoll()，重新传入这同一组文件描述符。而在使用 epoll 时，这组文件描述符会由一个内核对象来管理。 epoll当使用 strace 运行 [hello-ring-buffer-config.py] 时，会看到如下 epoll 相关的系统调用： 首先，用户空间程序请求在内核中创建一个新的 epoll 实例： epoll_create1(EPOLL_CLOEXEC) = 8 随后会调用 epoll_ctl()，该函数会告知内核，将文件描述符 4（即 output 缓冲区）添加到这个 epoll 实例所管理的文件描述符集合中。 epoll_ctl(8, EPOLL_CTL_ADD, 4, events=EPOLLIN, data=u32=0, u64=0) = 0 用户态程序调用 epoll_wait() 等待环形缓冲区中出现可用数据。只有当数据就绪时，该调用才会返回。 epoll_wait(8, [events=EPOLLIN, data=u32=0, u64=0], 1, -1) = 1 4.8 Reading Information from a Map对 bpftool 行为的分析展示了用户空间程序如何遍历可用的映射以及存储在映射中的键值对。 以下命令展示了 bpftool 在读取 config 映射内容时，所调用的 bpf() 系统调用的片段： strace -e bpf bpftool map dump name config 你将会看到，该流程包含两个主要步骤： 遍历所有映射，查找名称为 config 的映射。 若找到匹配的映射，则遍历该映射内的所有元素。 4.8.1 Finding a Mapbpftool 会遍历所有映射，查找名称为 config 的映射: bpf(BPF_MAP_GET_NEXT_ID, start_id=0, ..., 12) = 0bpf(BPF_MAP_GET_FD_BY_ID, map_id=25, ..., 12) = 3bpf(BPF_OBJ_GET_INFO_BY_FD, info=bpf_fd=3, ..., 16) = 0bpf(BPF_MAP_GET_NEXT_ID, start_id=25, ..., 12) = 0bpf(BPF_MAP_GET_FD_BY_ID, map_id=26, ..., 12) = 3bpf(BPF_OBJ_GET_INFO_BY_FD, info=bpf_fd=3, ..., 16) = 0 BPF_MAP_GET_NEXT_ID 用于获取在 start_id 指定的值之后的下一个映射的 ID。 BPF_MAP_GET_FD_BY_ID 会返回指定映射 ID 对应的文件描述符。 BPF_OBJ_GET_INFO_BY_FD 用于获取由文件描述符所指向的对象（此处即映射）的相关信息。这些信息包含该对象的名称， bpftool 可以据此判断该对象是否为其要查找的映射。 内核中加载的每个映射，都会对应这样一组三条系统调用。你还会发现，start_id 和 map_id 所使用的值，与这些映射的 ID 是相匹配的。当再也没有可供查找的映射时，这个重复的调用模式便会终止，此时 BPF_MAP_GET_NEXT_ID 会返回 ENOENT 错误值，如下所示： bpf(BPF_MAP_GET_NEXT_ID, start_id=37, next_id=0, open_flags=0, 12) = -1 ENOENT (No such file or directory) 4.8.2 Reading Map Elements如果找到了匹配的映射，bpftool 会持有该映射的文件描述符，以便从中读取元素。下面我们来看读取该信息对应的系统调用序列： bpf(BPF_MAP_GET_NEXT_KEY, map_fd=3, key=NULL, next_key=0x5897d6dd81c0, 24) = 0bpf(BPF_MAP_LOOKUP_ELEM, map_fd=3, key=0x5897d6dd81c0, value=0x5897d6dd81e0, flags=BPF_ANY, 32) = 0 [ key: 0, value: message: Hey root! bpf(BPF_MAP_GET_NEXT_KEY, map_fd=3, key=0x5897d6dd81c0, next_key=0x5897d6dd81c0, 24) = -1 ENOENT (No such file or directory) ]+++ exited with 0 +++ 首先，应用程序需要找到一个存在于该映射中的有效键 (key)。它通过 bpf() 系统调用的 BPF_MAP_GET_NEXT_KEY 类型来实现这一操作。其中，key 参数是一个指向键的指针，该系统调用会返回此键之后的下一个有效键。若传入的是一个空指针（NULL），则表示应用程序请求获取该映射中的第一个有效键。内核会将这个键写入到 next_key 指针所指向的内存地址中。 BPF_MAP_LOOKUP_ELEM：给定一个键后，应用程序会请求获取其对应的数值，该数值会被写入 value 指针所指定的内存地址中。 bpftool 获取到第一组键值对的内容，并将该信息输出到屏幕上。 当再次调用 BPF_MAP_GET_NEXT_KEY 时，系统会返回 ENOENT 错误码，表明该映射中已无更多条目。 最后，bpftool 完成屏幕输出的收尾工作并退出。 4.9 Summary BPF_PROG_LOAD 和 BPF_MAP_CREATE eBPF 程序和 maps 的引用计数 (reference counts) BPF links 用户空间程序使用 perf_event_open() 和 ioctl() 将 eBPF 程序附加到 kprobe 事件 如何使用 BPF_MAP_GET_NEXT_ID、BPF_MAP_GET_FD_BY_ID 和 BPF_OBJ_GET_INFO_BY_FD 来定位内核持有的映射和其他对象 4.10 Exerciseslearning-ebpf-exerciseshttps://github.com/gaoyangu/learning-ebpf-exercises"},{"title":"05. CO-RE, BTF, and Libbpf","path":"/wiki/ebpf/learning-ebpf-05.html","content":"CO-RE: compile once, run everywhere BTF: BPF Type Format 许多 eBPF 程序都会访问内核数据结构，因此 eBPF 程序员需要引入相关的 Linux 头文件，才能让自己的 eBPF 代码正确定位这些数据结构中的字段。但 Linux 内核始终处于持续开发状态，这意味着内核内部的数据结构可能会在不同内核版本之间发生变化。 BTF (BPF Type Format) 是 BPF 技术 “一次编译，处处运行”（CO-RE） 方案的核心组成部分，该方案专门解决 eBPF 程序在不同内核版本间移植的难题。 CO-RE 方案允许 eBPF 程序内置其编译时所基于的数据结构布局信息，并提供了一套适配机制 —— 当程序运行的目标机器上的数据结构布局与编译时存在差异时，该机制可自动调整字段的访问方式。只要程序不会试图访问目标内核中根本不存在的字段或数据结构，它就能在不同的内核版本间实现跨版本兼容运行。 5.1 BCC’s Approach to Portability为解决跨内核版本的可移植性问题，BCC 采用了在目标机器上实时编译 eBPF 代码的方案。 这样的方案存在很多问题： 你需要在所有希望运行代码的目标机器上安装编译工具链，同时还得安装内核头文件（这类文件在默认情况下并非总会预装）。 工具启动前，必须等待编译完成，这意味着每次启动工具时，都可能产生数秒的延迟。 如果要在一大批配置相同的机器上运行这款工具，那么在每台机器上重复执行编译操作，会造成计算资源的浪费。 部分基于 BCC 构建的项目会将自身的 eBPF 源代码与工具链打包成容器镜像，这种方式能更便捷地将程序分发到每台目标机器。但这并不能解决内核头文件的预装问题，甚至可能导致新的问题 —— 如果在同一台机器上安装了多个这类 BCC 容器，会造成更多的资源冗余。 嵌入式设备则可能没有足够的内存资源来完成编译步骤。 5.2 CO-RE Overview BTF BTF 是一种用于描述数据结构布局与函数签名的格式。在 CO-RE 技术中，它被用来判断编译期与运行期所使用的数据结构之间存在的任何差异。 bpftool 这类工具也会借助 BTF，以人类可读的格式导出数据结构。 Linux 5.4 及以上版本的内核均支持 BTF 格式。 Kernel headers Linux 内核源代码中包含用于描述其所用数据结构的头文件，且这些头文件的内容会随 Linux 版本的更迭发生变化。 eBPF 程序员既可以选择引入单个头文件，也可以借助 bpftool 工具从运行中的系统生成一个名为 vmlinux.h 的头文件 —— 该文件包含了 eBPF 程序可能需要的、关于当前内核的所有数据结构信息。 Compiler support 使用 Clang 编译器通过 -g 编译选项编译 eBPF 程序时，会自动嵌入一种名为 CO-RE 重定位信息 的内容，这类信息衍生自用于描述内核数据结构的 BTF 信息。 GCC 编译器也在其 12 版本中，新增了针对 BPF 目标程序的 CO-RE 支持功能。 Library support for data structure relocations 在用户态程序将 eBPF 程序加载至内核时，CO-RE 方案要求根据编译到目标文件中的 CO-RE 重定位信息，对字节码进行调整，以补偿程序编译时所基于的数据结构，与即将运行的目标机器上的数据结构之间存在的任何差异。 libbpf 是最早具备该重定位能力的 C 语言类库 (自动完成) Cilium eBPF 类库为 Go 语言开发者提供了相同的功能 Aya 则面向 Rust 语言实现了该特性。 Optionally, a BPF skeleton 可以从已编译的 BPF 目标文件中自动生成一个骨架文件 (skeleton)，该文件包含若干便捷函数，用户态代码可调用这些函数来管理 BPF 程序的生命周期 —— 包括将程序加载至内核、挂载到事件上等操作。 如果用户态代码使用 C 语言编写，可通过 bpftool gen skeleton 命令生成该骨架文件。 这些函数属于更上层的抽象封装，相比直接调用底层类库（如 libbpf、ciliumebpf 等），能为开发者带来更高的开发效率。 相关阅读： BPF CO-RE (Compile Once – Run Everywhere)https://nakryiko.com/posts/bpf-portability-and-co-re/ BPF CO-RE reference guidehttps://nakryiko.com/posts/bpf-core-reference-guide/#bpf-core-read Building BPF applications with libbpf-bootstraphttps://nakryiko.com/posts/libbpf-bootstrap/ 5.3 BPF Type FormatBTF 信息描述了数据结构 (data structures) 与代码 (code) 在内存中的布局方式。 5.3.1 BTF Use Cases本章在讲解 CO-RE 技术时引入 BTF 相关内容，核心原因在于：掌握 eBPF 程序编译时所基于的数据结构布局，与即将运行的目标环境中的数据结构布局之间的差异，能够让程序在加载至内核的过程中，完成对应的适配调整。 bpftool 工具借助 BTF 信息，对映射导出（map dump）的输出内容进行格式化处理 BTF 信息还包含行号与函数信息，这让 bpftool 工具能够在反编译或即时编译（JIT）后的程序导出内容中，穿插显示对应的源代码。 (Chapter 3) 源代码信息被穿插显示在验证器 (verifier) 日志输出中 —— 而这些信息同样来自于 BTF 数据。(Chapter 6) BPF 自旋锁 (spin locks) 的实现同样需要依赖 BTF 信息。 该锁必须作为映射值结构的一部分，示例如下： struct my_value ... other fields struct bpf_spin_lock lock;... other fields; 在内核中，eBPF 程序通过 bpf_spin_lock() 和 bpf_spin_unlock() 这两个辅助函数来获取和释放自旋锁。只有当存在能够描述锁字段在结构体中位置的 BTF 信息时，才能调用这些辅助函数。 NOTE:自旋锁功能在 5.1 版本内核中被引入。使用自旋锁存在诸多限制：它仅适用于哈希（hash）或数组（array）类型的映射，且不能在跟踪（tracing）或套接字过滤器（socket filter）类型的 eBPF 程序中使用。 相关阅读： Concurrency management in BPFhttps://lwn.net/Articles/779120/ 5.3.2 Listing BTF Information with bpftool列出内核中加载的所有 BTF data: bpftool btf list 1: name [vmlinux] size 6050732B2: name [tun] size 78483B3: name [ip_tables] size 54242B4: name [llc] size 37035B5: name [stp] size 36698B6: name [bridge] size 526851B7: name [br_netfilter] size 87947B8: name [autofs4] size 28681B9: name [configfs] size 49125B10: name [sch_fq_codel] size 56146B11: name [ac] size 556B12: name [battery] size 10709B13: name [crc32c_intel] size 505B14: name [irqbypass] size 943B15: name [kvm] size 210513B16: name [kvm_intel] size 66832B17: name [intel_rapl_common] size 12653B18: name [intel_rapl_msr] size 10427B28: name anon size 40669B pids bpftool(1749) 列表中的第一项是 vmlinux，它对应于之前提到的承载当前运行内核 BTF 信息的 vmlinux 文件。 示例： $ cd learning-ebpf/chapter4$ ./hello-buffer-config.py $ bpftool btf list...100: name anon size 2292B prog_ids 123 map_ids 70 这段 BTF 信息块的 ID 为 100 这是一块大小约 2KB 的匿名 BTF 信息数据块。 它被程序 ID 为 123 的 BPF 程序，以及映射 ID 为 70 的 BPF 映射所使用。 $ bpftool prog show name hello123: kprobe name hello tag ce68c6b13b45c753 gpl loaded_at 2025-12-26T11:10:22+0800 uid 0 xlated 392B jited 216B memlock 4096B map_ids 70,69 btf_id 100 5.3.3 BTF Types知道该 BTF 信息的 ID，就可以通过命令 bpftool btf dump id id 来查看它的内容。 $ bpftool btf dump id 100 [1] TYPEDEF ‘u32’ type_id2[2] TYPEDEF ‘__u32’ type_id3[3] INT ‘unsigned int’ size4 bits_offset0 nr_bits32 encoding(none)[4] STRUCT ‘user_msg_t’ size13 vlen1 ‘message’ type_id6 bits_offset0[5] INT ‘char’ size1 bits_offset0 nr_bits8 encodingSIGNED[6] ARRAY ‘(anon)’ type_id5 index_type_id7 nr_elems13[7] INT ‘ARRAY_SIZE_TYPE‘ size4 bits_offset0 nr_bits32 encoding(none)[8] STRUCT ‘____btf_map_config’ size20 vlen2 ‘key’ type_id1 bits_offset0 ‘value’ type_id4 bits_offset32[9] INT ‘(anon)’ size4 bits_offset0 nr_bits32 encoding(none)[10] PTR ‘(anon)’ type_id0[11] FUNC_PROTO ‘(anon)’ ret_type_id12 vlen1 ‘ctx’ type_id10[12] INT ‘int’ size4 bits_offset0 nr_bits32 encodingSIGNED[13] FUNC ‘hello’ type_id11 linkagestatic[14] INT ‘(anon)’ size4 bits_offset0 nr_bits32 encoding(none)[15] STRUCT ‘config_table_t’ size160 vlen20 ‘key’ type_id1 bits_offset0 ‘leaf’ type_id4 bits_offset32 ‘lookup’ type_id16 bits_offset192 ‘lookup_or_init’ type_id20 bits_offset256 ‘lookup_or_try_init’ type_id20 bits_offset320 ‘update’ type_id22 bits_offset384 ‘insert’ type_id22 bits_offset448 ‘delete’ type_id24 bits_offset512 ‘call’ type_id26 bits_offset576 ‘increment’ type_id28 bits_offset640 ‘atomic_increment’ type_id28 bits_offset704 ‘get_stackid’ type_id30 bits_offset768 ‘sk_storage_get’ type_id35 bits_offset832 ‘sk_storage_delete’ type_id37 bits_offset896 ‘inode_storage_get’ type_id35 bits_offset960 ‘inode_storage_delete’ type_id37 bits_offset1024 ‘task_storage_get’ type_id35 bits_offset1088 ‘task_storage_delete’ type_id37 bits_offset1152 ‘max_entries’ type_id1 bits_offset1216 ‘flags’ type_id12 bits_offset1248[16] PTR ‘(anon)’ type_id17[17] FUNC_PROTO ‘(anon)’ ret_type_id18 vlen1 ‘(anon)’ type_id19[18] PTR ‘(anon)’ type_id4[19] PTR ‘(anon)’ type_id1[20] PTR ‘(anon)’ type_id21[21] FUNC_PROTO ‘(anon)’ ret_type_id18 vlen2 ‘(anon)’ type_id19 ‘(anon)’ type_id18[22] PTR ‘(anon)’ type_id23[23] FUNC_PROTO ‘(anon)’ ret_type_id12 vlen2 ‘(anon)’ type_id19 ‘(anon)’ type_id18[24] PTR ‘(anon)’ type_id25[25] FUNC_PROTO ‘(anon)’ ret_type_id12 vlen1 ‘(anon)’ type_id19[26] PTR ‘(anon)’ type_id27[27] FUNC_PROTO ‘(anon)’ ret_type_id0 vlen2 ‘(anon)’ type_id10 ‘(anon)’ type_id12[28] PTR ‘(anon)’ type_id29[29] FUNC_PROTO ‘(anon)’ ret_type_id0 vlen2 ‘(anon)’ type_id1 ‘(anon)’ type_id0[30] PTR ‘(anon)’ type_id31[31] FUNC_PROTO ‘(anon)’ ret_type_id12 vlen2 ‘(anon)’ type_id10 ‘(anon)’ type_id32[32] TYPEDEF ‘u64’ type_id33[33] TYPEDEF ‘__u64’ type_id34[34] INT ‘unsigned long long’ size8 bits_offset0 nr_bits64 encoding(none)[35] PTR ‘(anon)’ type_id36[36] FUNC_PROTO ‘(anon)’ ret_type_id10 vlen3 ‘(anon)’ type_id10 ‘(anon)’ type_id10 ‘(anon)’ type_id12[37] PTR ‘(anon)’ type_id38[38] FUNC_PROTO ‘(anon)’ ret_type_id12 vlen1 ‘(anon)’ type_id10[39] INT ‘(anon)’ size4 bits_offset0 nr_bits32 encoding(none)[40] STRUCT ‘output_table_t’ size32 vlen5 ‘key’ type_id12 bits_offset0 ‘leaf’ type_id1 bits_offset32 ‘perf_submit’ type_id41 bits_offset64 ‘perf_submit_skb’ type_id43 bits_offset128 ‘max_entries’ type_id1 bits_offset192[41] PTR ‘(anon)’ type_id42[42] FUNC_PROTO ‘(anon)’ ret_type_id12 vlen3 ‘(anon)’ type_id10 ‘(anon)’ type_id10 ‘(anon)’ type_id1[43] PTR ‘(anon)’ type_id44[44] FUNC_PROTO ‘(anon)’ ret_type_id12 vlen4 ‘(anon)’ type_id10 ‘(anon)’ type_id1 ‘(anon)’ type_id10 ‘(anon)’ type_id1[45] INT ‘(anon)’ size4 bits_offset0 nr_bits32 encoding(none)[46] ARRAY ‘(anon)’ type_id5 index_type_id7 nr_elems4[47] INT ‘(anon)’ size4 bits_offset0 nr_bits32 encoding(none)[48] PTR ‘(anon)’ type_id0[49] PTR ‘(anon)’ type_id0[50] PTR ‘(anon)’ type_id0[51] PTR ‘(anon)’ type_id0[52] PTR ‘(anon)’ type_id0[53] PTR ‘(anon)’ type_id0[54] PTR ‘(anon)’ type_id0[55] PTR ‘(anon)’ type_id0[56] PTR ‘(anon)’ type_id0[57] PTR ‘(anon)’ type_id0 开头这几行的 BTF 信息，对应的是代码中定义的 config hash map，其源代码定义如下： struct user_msg_t char message[13];;BPF_HASH(config, u32, struct user_msg_t); BTF 输出信息的前三行如下： [1] TYPEDEF u32 type_id=2[2] TYPEDEF __u32 type_id=3[3] INT unsigned int size=4 bits_offset=0 nr_bits=32 encoding=(none) [1] 代表 type_id 1。 Type 1 定义了一个名为 u32 的类型，而该类型的具体定义由 type_id 2 给出 —— 也就是以 [2] 开头的那一行所定义的类型。正如你所知，config hash map 中的键的类型正是 u32。 Type 2 的名为 __u32，类型由 type_id 3 给出 Type 3 的名为 unsigned int，类型为整数 (INT), 大小为 4 字节。 这三种类型均为 32 位无符号整数类型的别名。在 C 语言中，整数类型的长度是与平台相关的，因此 Linux 内核定义了 u32 这类类型，用于显式指定特定长度的整数。在当前设备中，u32 对应的就是无符号整数类型。用户态代码中若要引用这类类型，应使用带双下划线前缀的别名，例如 __u32。 [4] STRUCT user_msg_t size=13 vlen=1 message type_id=6 bits_offset=0[5] INT char size=1 bits_offset=0 nr_bits=8 encoding=SIGNED[6] ARRAY (anon) type_id=5 index_type_id=7 nr_elems=13[7] INT __ARRAY_SIZE_TYPE__ size=4 bits_offset=0 nr_bits=32 encoding=(none) 这些内容对应 config map 中用作值类型的 user_msg_t 结构体： Type 4 就是 user_msg_t 结构体本身，其总长度为 13 字节。该结构体包含一个名为 message 的字段，此字段由 type_id 6 定义。vlen 字段表示该结构体定义中包含的字段数量。 Type 5 命名为 char，是 1 字节长度的整数 —— 这完全符合 C 语言程序员对 char 类型的预期定义。 Type 6 将 message 字段的类型定义为一个包含 13 个元素的数组。数组中的每个元素类型为 5（即 char 类型），且该数组的索引类型由 type_id 7 定义。 Type 7 是 4 字节长度的整数 目前为止，所有条目均将 bits_offset 设为 0，但下一行输出则对应一个包含多个字段的结构体： [8] STRUCT ____btf_map_config size=20 vlen=2 key type_id=1 bits_offset=0 value type_id=4 bits_offset=32 这是一个用于定义存储在名为 config 的映射中键值对的结构体定义。 我并未在源代码中自行定义 ____btf_map_config 这个类型，它是由 BCC 自动生成的。其中键的类型为 u32，值的类型则是 user_msg_t 结构体，这两种类型分别对应之前看到的 type 1 和 type 4。 关于该结构体的 BTF 信息中，还有一个关键内容：value 字段的起始位置相较于结构体起始地址偏移了 32 位。这完全符合逻辑，因为前 32 位的存储空间需要用来存放 key 字段。 5.3.4 Maps with BTF Information在第四章中已经了解到，map 是通过 bpf(BPF_MAP_CREATE) 系统调用创建的。 bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_HASH, key_size=4, value_size=13, max_entries=10240, map_flags=0, inner_map_fd=0, map_name=config, map_ifindex=0, btf_fd=3, btf_key_type_id=1, btf_value_type_id=4, btf_vmlinux_value_type_id=0, map_extra=0, 72) = 5 该系统调用会接收一个 bpf_attr 结构体作为参数，这个结构体在内核中的定义如下（省略了部分细节）： struct /* anonymous struct used by BPF_MAP_CREATE command */ __u32 map_type; /* one of enum bpf_map_type */ __u32 key_size; /* size of key in bytes */ __u32 value_size; /* size of value in bytes */ __u32 max_entries; /* max number of entries in a map */ ... char map_name[BPF_OBJ_NAME_LEN]; ... __u32 btf_fd; /* fd pointing to a BTF type data */ __u32 btf_key_type_id; /* BTF type_id of the key */ __u32 btf_value_type_id; /* BTF type_id of the value */ ...; ____btf_map_config 并未被内核用于 map 定义；它仅由 BCC 在用户空间使用。 5.3.5 BTF Data for Functions and Function PrototypesBTF 数据还包含有关函数和函数原型的信息。 [10] PTR (anon) type_id=0[11] FUNC_PROTO (anon) ret_type_id=12 vlen=1 ctx type_id=10[12] INT int size=4 bits_offset=0 nr_bits=32 encoding=SIGNED[13] FUNC hello type_id=11 linkage=static Type 13 可以看到函数名为 hello，type_id 为 11。 Type 11 是一个函数原型，返回值类型为 type_id 12；一个名为 ctx 的参数，type_id 为 10。 Type 10 是一个匿名指针，type_id 为 0，它没有显式的包含在 BTF 输出中，但被定义为 void 类型。 encoding=SIGNED 表示这是一个有符号的整数。 对应 hello-buffer-config.py 中的函数定义为： int hello(void *ctx) 5.3.6 Inspecting BTF Data for Maps and Programs查看与特定映射关联的 BTF 类型： $ bpftool btf dump map name config[1] TYPEDEF u32 type_id=2[4] STRUCT user_msg_t size=13 vlen=1 message type_id=6 bits_offset=0 查看特定程序的 BTF 信息： $ bpftool btf dump prog id 123$ bpftool btf dump prog name hello 参考： man 手册https://manpages.ubuntu.com/manpages/jammy/man8/bpftool-btf.8.html 5.4 Generating a Kernel Header File$ bpftool btf list1: name [vmlinux] size 6050732B... 列表中第一项的 ID 为 1、名称为 vmlinux，它是一份 BTF 信息，涵盖了当前（虚拟）机器上运行的内核所使用的所有数据类型、结构体以及函数定义。 通过 bpftool 工具能够从内核自带的 BTF 信息中，生成被命名为 vmlinux.h的头文件，你可以使用如下命令生成它： bpftool btf dump file /sys/kernel/btf/vmlinux format c vmlinux.h 当你将源码编译为 eBPF 目标文件时，该目标文件会包含一份与该头文件中所用定义相匹配的 BTF 信息。 后续在目标机器上运行该程序时，负责将程序加载至内核的用户态程序会自动进行适配调整，以消除编译期 BTF 信息与目标机器上运行内核的 BTF 信息之间的差异。 自 5.4 版本起，Linux 内核便已内置以 /sys/kernel/btf/vmlinux 文件形式存在的 BTF 信息。不过，也可以为旧版本内核生成可供 libbpf 调用的原始 BTF 数据。 若你希望在一台未预装 BTF 信息的目标机器上运行支持 CO-RE 特性的 eBPF 程序，可以自行为该目标机器提供对应的 BTF 数据。关于如何生成 BTF 文件的方法，以及适用于多种 Linux 发行版的 BTF 文件归档包，均可在 BTFHub 上获取。 5.5 CO-RE eBPF Programs5.5.1 Header Fileshello-buffer-config.bpf.c 文件的前几行代码指定了该程序所需的头文件： #include vmlinux.h#include bpf/bpf_helpers.h#include bpf/bpf_tracing.h#include bpf/bpf_core_read.h#include hello-buffer-config.h Kernel header information:如果你要使用 libbpf 库中的任何 BPF 辅助函数，就需要引入 vmlinux.h 或 linux/types.h 头文件，以获取 u32、u64 等类型的定义 —— 这些类型是 BPF 辅助函数的源码会引用到的。 vmlinux.h 文件派生自内核源码头文件，但它并未包含这些头文件中通过 #define 定义的常量值。 例如，若你的 eBPF 程序需要解析以太网数据包，你很可能会用到一些常量定义 —— 这些常量用于标识数据包承载的协议类型（比如 0x0800 代表 IP 数据包，0x0806 代表 ARP 数据包）。如果不引入为内核定义了这些常量的 if_ether.h 文件，你就需要在自己的代码中手动复写这一系列常量值。 Headers from libbpf:若要在你的 eBPF 代码中调用任意 BPF 辅助函数，需要引入 libbpf 库中提供这些函数定义的头文件。 在撰写本书时，eBPF 项目的常见做法是将 libbpf 作为子模块引入，并基于源码进行编译和安装。 若你将其作为子模块引入，只需进入 libbpf/src 目录，执行 make install 命令即可完成操作。 Application-speciic headers:在项目中专门编写一个应用专属头文件，用于定义同时被程序用户态部分和eBPF 部分使用的所有结构体，是一种十分常见的做法。 hello-buffer-config.h 头文件定义了 data_t 结构体，通过这个结构体将事件数据从 eBPF 程序传递至用户态。 5.5.2 Deining Maps引入头文件后，hello-buffer-config.bpf.c 源码中接下来的几行代码定义了用于映射（map）的结构体，具体如下： struct __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY); __uint(key_size, sizeof(u32)); __uint(value_size, sizeof(u32)); output SEC(.maps);struct user_msg_t char message[12];;struct __uint(type, BPF_MAP_TYPE_HASH); __uint(max_entries, 10240); __type(key, u32); __type(value, struct user_msg_t); my_config SEC(.maps); 在 BCC 中，这个名为 config 的映射是通过以下宏定义创建的： BPF_HASH(config, u64, struct user_msg_t); __uint, __type, __array 定义在头文件 bpf_helpers.h 中定义： #define __uint(name, val) int (*name)[val]#define __type(name, val) typeof(val) *name#define __array(name, val) typeof(val) *name[] 这些宏在基于 libbpf 的程序中通常遵循惯例使用，而且它们能让 map 定义的可读性稍好一些。 5.5.3 eBPF Program Sections使用 libbpf 时，要求每个 eBPF 程序都需通过 SEC() 宏进行标记，该宏会定义程序的类型，示例如下： SEC(kprobe) 这会在编译生成的 ELF 目标文件中创建一个名为 kprobe 的段，如此一来 libbpf 便知晓要将其加载为 BPF_PROG_TYPE_KPROBE 类型的 eBPF 程序。 根据程序类型的不同，可以通过段名称来指定程序要挂载的事件。libbpf 库会利用这一信息自动完成挂载配置，而非要求你在用户态代码中显式地手动完成这项操作。例如，若要在基于 ARM 架构的机器上自动挂载到 execve 系统调用对应的 kprobe 上，可以像这样指定段名称： SEC(kprobe/__arm64_sys_execve) 这就要求你必须知晓该架构下系统调用对应的函数名。（也可以自行查找获取，比如查看目标机器上的 /proc/kallsyms 文件 —— 这个文件会列出内核的所有符号信息，其中就包含函数名） libbpf 还能通过 k(ret)syscall 段名称进一步简化操作 —— 该段名称会告知加载器，自动将程序挂载到与架构相关的函数对应的 kprobe 上。 libbpf 文档 中列举了有效的 section 名称和格式 SEC(ksyscall/execve)int BPF_KPROBE_SYSCALL(hello, const char *pathname) struct data_t data = ; struct user_msg_t *p; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); // 注意：内存拷贝需要使用 BPF helper function bpf_probe_read_user_str(data.path, sizeof(data.path), pathname); // 根据指定的键 (key) 查询映射 (map) 中的值 (value) p = bpf_map_lookup_elem(my_config, data.uid); if (p != 0) bpf_probe_read_kernel_str(data.message, sizeof(data.message), p-message); else bpf_probe_read_kernel_str(data.message, sizeof(data.message), message); bpf_perf_event_output(ctx, output, BPF_F_CURRENT_CPU, data, sizeof(data)); return 0; BPF_KPROBE_SYSCALL 是在 libbpf 中定义的宏，通过这个宏可以按名称便捷地访问系统调用的参数。 eBPF 程序的名称为 hello，execve() 的第一个参数为要执行的程序的路径名 在 BCC 版本的代码中，将消息字符串定义为 hello() 函数内的局部变量。这是因为 BCC（至少在撰写本文时）不支持全局变量。而在当前这个版本里，将它定义成了全局变量。 char message[12] = Hello World; 在 chapter4/hello-buffer-config.py 中 hello() 函数的定义如下： int hello(void *ctx) BPF_KPROBE_SYSCALL 宏是由 libbpf 提供的便利功能之一。你并非必须使用这个宏，但它能大幅简化开发流程。该宏会自动处理所有繁琐的底层工作，为传递给系统调用的所有参数提供按名访问的能力。在本示例中，它提供了一个 pathname 参数，这个参数指向一个字符串，该字符串存储了即将运行的可执行文件的路径 —— 而这正是 execve() 系统调用的第一个参数。 在 hello-buffer-config.bpf.c 中你会发现，ctx 变量并没有被显式定义，但是却在向 output perf 缓冲区提交数据时使用： bpf_perf_event_output(ctx, output, BPF_F_CURRENT_CPU, data, sizeof(data)); ctx 变量确实是存在的，它隐藏在 libbpf 库的头文件 bpfbpf_tracing.h 中定义的 BPF_KPROBE_SYSCALL 宏里。 5.5.4 Memory Access with CO-RE用于跟踪的 eBPF 程序对内存的访问受到限制，需要通过 bpf_probe_read_*() 系列的 BPF 辅助函数来实现。（此外还有一个 bpf_probe_write_user() 辅助函数，但它仅适用于实验场景）。在下一章将会看到，eBPF 验证器通常不允许你像在标准 C 语言中那样，直接通过指针读取内存（例如 x = p-y 这种写法）。 libbpf 库为 bpf_probe_read_*() 系列辅助函数提供了 CO-RE 封装，借助 BTF 信息的优势，让内存访问调用可以在不同内核版本间实现可移植。下面是 bpf_core_read.h 中定义的一个封装器的示例： #define bpf_core_read(dst, sz, src) \\\tbpf_probe_read_kernel(dst, sz, (const void *)__builtin_preserve_access_index(src)) __builtin_preserve_access_index 会指示 Clang 在生成访问该内存地址的 eBPF 指令时，一并生成一个 CO-RE 重定位项。 正如你将在本章后续内容中看到的，CO-RE 重定位项 (relocation entry) 会指示 libbpf 在将 eBPF 程序加载至内核的过程中重写内存地址，以此适配不同内核间的 BTF 差异。如果 src 字段在其所属结构体中的偏移量，在目标内核上存在不同，重写后的指令也会将这一情况纳入考量。 libbpf 库提供了一个 BPF_CORE_READ() 宏，你可以通过它在单行代码中完成多次 bpf_core_read() 调用，而无需为每次指针解引用操作都单独调用一次辅助函数。例如，对于 d = a-b-c-d, 你可以通过下列代码实现： struct b_t *b;struct c_t *c;bpf_core_read(b, 8, a-b);bpf_core_read(c, 8, b-c);bpf_core_read(d, 8, c-d); 但可以使用更加紧凑的写法： d = BPF_CORE_READ(a, b, c, d); 相关阅读： https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/#field-accesseshttps://nakryiko.com/posts/bcc-to-libbpf-howto-guide/#field-accesses 5.5.5 License Deinition正如在第 3 章中已经了解到的，eBPF 程序必须声明其许可证。 char LICENSE[] SEC(license) = Dual BSD/GPL; 5.6 Compiling eBPF Programs for CO-RE5.6.1 Debug Information你必须向 Clang 传入 -g 编译选项，让它生成调试信息 —— 这是 BTF 所必需的。 不过，-g 选项同时也会在输出的目标文件中添加 DWARF 调试信息，而这部分信息对 eBPF 程序来说并非必需。因此，可以执行以下命令剥离该部分内容，以减小目标文件的体积： llvm-strip -g object file 5.6.2 OptimizationClang 必须启用 -O2 优化选项（或更高优化级别），才能生成可通过验证器校验的 BPF 字节码。这一要求的必要性体现在一个典型场景中：默认情况下，Clang 会生成 callx register 指令来调用辅助函数，但 eBPF 并不支持通过寄存器寻址的方式完成函数调用。 5.6.3 Target Architecture如果你要使用 libbpf 定义的某些宏，就需要在编译时指定目标架构。 libbpf 的头文件 bpf/bpf_tracing.h 中定义了多个平台相关的宏，比如本示例中用到的 BPF_KPROBE 和 BPF_KPROBE_SYSCALL。其中，BPF_KPROBE 宏可用于挂载到 kprobe 上的 eBPF 程序，而 BPF_KPROBE_SYSCALL 则是专门针对系统调用 kprobe 的变体宏。 kprobe 的入参是一个 pt_regs 结构体，该结构体存储了一份 CPU 寄存器内容的副本。由于寄存器具有架构相关性，pt_regs 结构体的定义也取决于程序运行所在的架构。这意味着，如果你想要使用这些宏，就必须告知编译器目标架构的具体类型。 你可以通过设置编译选项 -D __TARGET_ARCH_($ARCH) 来实现这一点，其中 $ARCH 代表具体的架构名称，例如 arm64、amd64 等。 5.6.4 Makeile以下是用于编译 CO-RE 目标的示例 Makefile 指令: %.bpf.o: %.bpf.c vmlinux.h\tclang \\ -target bpf \\ -D __TARGET_ARCH_$(ARCH) \\ -Wall \\ -O2 -g -o $@ -c $\tllvm-strip -g $@ 5.6.5 BTF Information in the Object File内核中关于 BTF 的文档描述了 BTF 数据在 ELF 目标文件中的编码方式，其对应两个段：.BTF 段存储数据与字符串信息，.BTF.ext 段则包含函数与行号信息。 $ readelf -S hello-buffer-config.bpf.o | grep BTF [ 8] .BTF PROGBITS 0000000000000000 000003b0 [ 9] .rel.BTF REL 0000000000000000 000010a8 [10] .BTF.ext PROGBITS 0000000000000000 00000ca4 [11] .rel.BTF.ext REL 0000000000000000 000010f8 bpftool 工具可用于查看目标文件中的 BTF 数据，用法如下： bpftool btf dump file hello-buffer-config.bpf.o 5.7 BPF Relocationslibbpf 库使 eBPF 程序适应其运行的目标内核上的数据结构体布局，即使该布局与编译代码的内核不同。为此，libbpf 需要 Clang 在编译过程中生成的 BPF CO-RE 重定位信息。 可以通过 linuxbpf.h 头文件中 struct bpf_core_relo 的定义了解有关重定位如何工作的更多信息： struct bpf_core_relo __u32 insn_off; __u32 type_id; __u32 access_str_off; enum bpf_core_relo_kind kind;; eBPF 程序的 CO-RE 重定位数据，会为每条需要重定位的指令配备一个此类结构体。 假设某条指令要将一个寄存器的值设置为某个结构体中某个字段的值，那么该指令对应的 bpf_core_relo 结构体（通过 insn_off 字段来标识）会对该结构体的 BTF 类型（type_id 字段）进行编码，同时还会指明该字段相对于此结构体的访问方式（access_str_off 字段）。 内核数据结构的重定位数据会由 Clang 自动生成，并编码到 ELF 目标文件中。正是在 vmlinux.h 文件开头附近找到的下一行代码，促使 Clang 执行了这一操作： #pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record) preserve_access_index: 指示 Clang 为类型定义生成 BPF CO-RE 重定位信息。 clang attribute push: 将应用于所有后续的类型定义，直至文件末尾出现 clang attribute pop 为止。这意味着 Clang 会为 vmlinux.h 中定义的所有类型都生成对应的重定位信息。 当加载 BPF 程序时，可通过 bpftool 工具并添加 -d 参数开启调试信息，来查看重定位操作的执行过程。 bpftool -d prog load hello.bpf.o /sys/fs/bpf/hello 会看到类似下面的输出信息： libbpf: CO-RE relocating [22] struct pt_regs: found target candidate [134] struct pt_regs in [vmlinux]libbpf: prog hello: relo #0: byte_off [22] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #0: matching candidate #0 byte_off [134] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #0: patched insn #5 (ALU/ALU64) imm 112 - 112libbpf: prog hello: relo #1: byte_off [22] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #1: matching candidate #0 byte_off [134] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #1: patched insn #6 (LDX/ST/STX) off 112 - 112libbpf: prog hello: relo #2: byte_off [22] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #2: matching candidate #0 byte_off [134] struct pt_regs.di (0:14 @ offset 112)libbpf: prog hello: relo #2: patched insn #48 (LDX/ST/STX) off 112 - 112 5.8 CO-RE User Space Code在许多应用场景中，你不会希望要求用户通过运行 bpftool 工具来加载 eBPF 程序。相反，更希望将该功能集成到一个专用的用户态程序中，并将其编译为可执行文件提供给用户。 不同编程语言中都存在若干支持 CO-RE 技术的框架，它们的实现原理是在将 eBPF 程序加载至内核时完成重定位操作。 本章将演示基于 libbpf 库的 C 语言实现代码；除此之外，其他可选方案还包括 Go 语言的 ciliumebpf 和 libbpfgo 包，以及适用于 Rust 语言的 Aya 框架。关于这些方案的更多内容，会在第 10 章展开详细探讨。 5.9 The Libbpf Library for User Spacelibbpf 库提供了一系列函数，这些函数对第 4 章中讲到的 bpf() 系统调用及其相关系统调用进行了封装，可用于执行各类操作，例如将程序加载至内核并挂载到事件上，或是从用户态访问映射的相关信息。使用这些抽象功能的标准且最简便的方法，是借助自动生成的 BPF 骨架代码 (BPF skeleton code)。 5.9.1 BPF Skeletons使用 bpftool 从现有的 ELF 文件格式的 eBPF 对象中自动生成框架代码: bpftool gen skeleton hello-buffer-config.bpf.o hello-buffer-config.skel.h 查看这个骨架头文件你会发现，它包含了 eBPF 程序与映射的结构体定义，同时还包含若干名称均以 hello_buffer_config_bpf__ 开头的函数（该前缀基于目标文件的名称生成）。这些函数负责管理 eBPF 程序与映射的生命周期。 在生成的骨架文件末尾，你会看到一个名为 hello_buffer_config_bpf__elf_bytes 的函数，该函数会返回 ELF 目标文件 hello-buffer-config.bpf.o 的字节内容。骨架文件生成完成后，我们实际上就不再需要这个目标文件了。你可以通过以下步骤验证这一点：先运行 make 命令生成 hello-buffer-config 可执行文件，然后删除上述 .o 文件 —— 此时可执行文件本身已包含所需的 eBPF 字节码。 示例：[hello-bufer-config.c] Loading programs and maps into the kernelskel = hello_buffer_config_bpf__open_and_load(); 顾名思义，该函数包含两个阶段：打开与加载。 “打开” 阶段负责读取 ELF 数据，并将其各个段转换为用于表示 eBPF 程序和映射的结构体。 “加载” 阶段则会将这些映射和程序加载至内核，并根据需要执行各类 CO-RE 修正操作。 这两个阶段可以很方便地分开处理，因为骨架代码提供了独立的 name__open() 和 name__load() 函数。这让你能够在加载 eBPF 程序之前，对相关信息进行操作。这种做法常用于在加载程序前完成配置工作。例如，我可以像这样将一个全局计数器变量 c 初始化为某个值： skel = hello_buffer_config_bpf__open();if (!skel) // Error ...skel-data-c = 10;err = hello_buffer_config_bpf__load(skel); hello_buffer_config_bpf__open() 函数与 hello_buffer_config_bpf__load() 函数的返回数据类型，均为一个名为 hello_buffer_config_bpf 的结构体。该结构体定义在骨架头文件中，包含了目标文件内所有映射、程序以及数据的相关信息。 Accessing existing maps bpftool 遍历所有的映射，查找与指定名称相匹配的那一个。 在两个不同的 eBPF 程序之间使用映射 (map) 共享信息。 bpf_map__set_autocreate() 函数允许覆盖 libbpf 的自动创建（映射）行为。 映射(map)支持被固定（pin），如果已知其固定路径，就可以通过 bpf_obj_get() 函数获取一个指向已有映射的文件描述符。 示例：[find-map.c] struct bpf_map_info info = ; unsigned int len = sizeof(info); int findme = bpf_obj_get(/sys/fs/bpf/findme);if (findme = 0) printf(No FD ); else bpf_obj_get_info_by_fd(findme, info, len); printf(name %s , info.name); 使用 bpftool 创建 map: bpftool map create /sys/fs/bpf/findme type array key 4 value 32 entries 4 name findme 运行 find-map $ ./find-map name findme Attaching to events本示例中的下一个骨架函数会将该程序挂载到 execve 系统调用函数上： err = hello_buffer_config_bpf__attach(skel); libbpf 库会自动从该程序的 SEC() 定义中提取挂载点信息。如果未完整定义挂载点，libbpf 还提供了一系列专用函数，例如 bpf_program__attach_kprobe、bpf_program__attach_xdp 等，用于挂载不同类型的 eBPF 程序。 Managing an event bufer性能缓冲区的配置需调用 libbpf 库自身定义的函数，而非骨架代码中定义的函数。 pb = perf_buffer__new(bpf_map__fd(skel-maps.output), 8, handle_event, lost_event, NULL, NULL); perf_buffer__new() 函数将 “output” 映射的文件描述符作为第一个参数。 参数 handle_event 是一个回调函数，当有新数据写入性能缓冲区时，该函数会被调用 如果性能缓冲区空间不足，导致内核无法写入数据条目时，lost_event 函数则会被触发执行。 最后，程序必须对性能缓冲区进行持续轮询： while (true) err = perf_buffer__poll(pb, 100); ... 参数 100 代表超时时间，单位为毫秒。当有数据写入或缓冲区被写满时，此前设置好的回调函数便会相应触发执行。 清理阶段，会释放性能缓冲区，并销毁内核中的 eBPF 程序与映射，具体操作如下： perf_buffer__free(pb);hello_buffer_config_bpf__destroy(skel); libbpf 库中提供了一整套与 perf_buffer_* 和 ring_buffer_* 相关的函数，用于帮助开发者管理事件缓冲区。 5.9.2 Libbpf Code Examples有大量基于 libbpf 的优质 eBPF 程序示例可供参考，你可以将其作为灵感来源和指导，用于编写自己的程序。 libbpf-bootstrap: 帮你快速上手一系列示例程序。 libbpf-tools directory: BCC 项目已将许多原本基于 BCC 框架的工具，迁移至 libbpf 版本。 5.10 Summary BTF 数据中 type_id 0 表示是 void 类型。 vmlinux.h 文件派生自内核源码头文件，但它并未包含这些头文件中通过 #define 定义的常量值。 BPF Skeletons 5.11 Exerciseslearning-ebpf-exerciseshttps://github.com/gaoyangu/learning-ebpf-exercises"},{"title":"06. The eBPF Verifier","path":"/wiki/ebpf/learning-ebpf-06.html","content":"the verifier works on eBPF bytecode, not directly on the source. That bytecode depends on the output from the compiler. 6.1 The Verification ProcessAs it goes along it keeps track of the state of each register in a structure called bpf_reg_state. This structure includes a field called bpf_reg_type, which describes what type of value is held in that register. NOT_INIT, indicating that the register has not yet been set to a value. SCALAR_VALUE, indicating that the register has been set to a value that doesn’t represent a pointer Several PTR_TO_* types, indicating that the register holds a pointer to something. PTR_TO_CTX: The register holds a pointer to the context passed as the argument to a BPF program. PTR_TO_PACKET: The register points to a network packet (held in the kernel as skb-data). PTR_TO_MAP_KEY or PTR_TO_MAP_VALUE There are several other PTR_TO_* types, and you can find the full set enumerated in the linuxbpf.h header file. 6.2 The Verifier LogWhen the verification of a program fails, the verifier generates a log showing how it reached the conclusion that the program is invalid. If you’re using bpftool prog load, the verifier log gets output to stderr. When you’re writing a program with libbpf, you can use the function libbpf_set_print() to set a handler that will display (or do something else useful with) any errors. When an eBPF program is called, Register 1 always holds the context argument passed to the program. Register 0 is used for the return value from a helper function and also for the return value from an eBPF program. Register 10 always holds a pointer to the eBPF stack frame (and the eBPF program can’t modify it). 6.3 Visualizing Control Flowbpftool prog dump xlated name kprobe_exec visual out.dotdot -Tpng out.dot out.png 6.4 Validating Helper FunctionsYou’re not allowed to call directly from eBPF programs to any kernel function, but eBPF provides a number of helper functions that enable programs to access information from the kernel. Different helper functions are valid for different BPF program types. 6.5 Helper Function Argumentsconst struct bpf_func_proto bpf_map_lookup_elem_proto = .func = bpf_map_lookup_elem,\t.gpl_only\t= false,\t.pkt_access\t= true,\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\t.arg1_type\t= ARG_CONST_MAP_PTR,\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,; This structure defines the constraints for arguments to and return values from the helper function. 6.6 Checking the LicenseThe verifier also checks that if you are using a BPF helper function that’s licensed under GPL, your program also has a GPL-compatible license. 6.7 Checking Memory Accessan XDP program is only permitted to access the memory locations that make up that network packet. SEC(xdp)int xdp_load_balancer(struct xdp_md *ctx) void *data = (void *)(long)ctx-data; void *data_end = (void *)(long)ctx-data_end;... 6.8 Checking Pointers Before Dereferencing ThemThe eBPF verifier requires all pointers to be checked before they are dereferenced so that this type of crash can’t happen. Some helper functions incorporate the pointer check for you. long bpf_probe_read_kernel(void *dst, u32 size, const void *unsafe_ptr) The third argument to this function is called unsafe_ptr. This is an example of a BPF helper function that helps programmers write safe code by handling checks for you. 6.9 Accessing ContextEvery eBPF program is passed some context information as an argument, but depending on the program and attachment type, it may be allowed to access only some of that context information. 6.10 Running to CompletionIf the verifier hasn’t reached the end of the BPF program before it has processed this many instructions, it rejects the program. 6.11 LoopsFrom version 5.3 onward the verifier follows branches backward as well as forward as part of its process of checking all the possible execution paths. This means it can accept some loops, provided the execution path remains within the limit of one million instructions. In version 5.17 a new helper function, bpf_loop(), was introduced that makes it much easier for the verifier not only to accept loops but also to do it in a much more efficient way. There’s also a helper function bpf_for_each_map_elem() that calls a provided callback function for each item in a map. 6.12 Checking the Return CodeThe return code from an eBPF program is stored in Register 0 (R0). Register 0 is also used to hold the return code from a helper function. After returning from a helper function in an eBPF program, Register 0 is no longer uninitialized. 6.13 Invalid InstructionsThe verifier checks that the instructions in a program are valid bytecode instructions—for example, using only known opcodes. 6.14 Unreachable InstructionsThe verifier also rejects programs that have unreachable instructions. Oftentimes, these will get optimized out by the compiler anyway. 6.15 SummaryThe verifier keeps track of the types and possible range of values for each register to ensure that eBPF programs are safe to run. 6.16 Exercisestodo"},{"title":"07. eBPF Program and Attachment Types","path":"/wiki/ebpf/learning-ebpf-07.html","content":"There are currently around 30 program types enumerated in uapilinuxbpf.h, and more than 40 attachment types. 7.1 Program Context ArgumentsAll eBPF programs take a context argument that is a pointer, but the structure it points to depends on the type of event that triggered it. Defining different types of programs allows the verifier to ensure that the contextual information is handled appropriately and to enforce rules about what helper functions are permissible. 7.2 Helper Functions and Return Codesthe verifier checks that all helper functions used by a program are compatible with its program type. The program type also determines the meaning of the return code from the program. Again using XDP as an example, the return code value tells the kernel what to do with the packet once the eBPF program has finished processing it—which could involve passing it to the network stack, dropping it, or redirecting it to a different interface. get a list of which helper functions are available for each program type in your version of the kernel: bpftool feature 7.3 Kfuncsbe able to access some internal functions from eBPF programs. This can be achieved using the mechanism called BPF kernel functions, or kfuncs Kfuncs allow internal kernel functions to be registered with the BPF subsystem so that the verifier will allow them to be called from eBPF programs. the type of an eBPF program determines what events it can be attached to, which in turn defines the type of context information it receives. The program type also defines the set of helper functions and kfuncs it can call. 7.4 Tracing附加到 kprobes、tracepoints、raw tracepoints、fentryfexit probes 和 perf events 的程序，都是为了内核中的 eBPF 程序能够高效的将跟踪信息传递到用户空间中。 查看附加到 perf 相关事件的程序： bpftool perf show 7.4.1 Kprobes and Kretprobes几乎可以将 kprobe 程序附加到内核的任何位置。 通常情况下，使用 kprobes 附加到函数的入口，使用 kretprobes 附加到函数的出口，但也可以使用 kprobes 附加到函数入口后的某个指定偏移量。 bpftool perf list Attaching kprobes to syscall entry points 附加到系统调用 execve() 的 kprobe SEC(ksyscall/execve)int BPF_KPROBE_SYSCALL(kprobe_sys_execve, const char *pathname) Attaching kprobes to other kernel functions kprobes 也可以附加到内核中的任何非内联函数 SEC(kprobe/do_execve)int BPF_KPROBE(kprobe_do_execve, struct filename *filename) filename 是根据内核中 do_execve 的函数原型确定。由于参数在内存中按顺序排列，可以忽略最后 n 个参数，但如果想使用后面的参数，则不能忽略列表中靠前的参数。 int do_execve(struct filename *filename, const char __user *const __user *__argv, const char __user *const __user *__envp) Kretprobes 与 kprobes 非常相似，不同之处在于它们在函数返回时触发，并且可以访问返回值而不是参数。 7.4.2 FentryFexit从内核版本 5.5 开始（适用于 x86 处理器；BPF trampoline 支持在 Linux 6.0 之前不适用于 ARM 处理器），引入了一种更高效的机制来跟踪进入和退出内核函数的方式以及 BPF trampoline 的概念。 fentryfexit 现在是首选的跟踪进入或退出内核函数的方法。 SEC(fentry/do_execve)int BPF_PROG(fentry_execve, struct filename *filename) fentry 和 fexit 的附加点设计得比 kprobes 更高效，且 fexit hook 可以访问函数的输入参数，而 kretprobe 不能。 在 libbpf-bootstrap 的示例中 可以看到两个等效的示例： kprobe.bpf.c SEC(kretprobe/do_unlinkat)int BPF_KRETPROBE(do_unlinkat_exit, long ret) fentry.bpf.c SEC(fexit/do_unlinkat)int BPF_PROG(do_unlinkat_exit, int dfd, struct filename *name, long ret) 7.4.3 TracepointsTracepoints 是内核开发者预先在代码中设置的、可用于触发事件记录的特定位置，在不同内核版本之间具有稳定性。 查看内核上可用的跟踪子系统集合： cat /sys/kernel/tracing/available_events 如下所示，当内核开始处理系统调用 ececve() 时，tracepoint syscalls:sys_enter_execve 会被触发。 SEC(tp/syscalls/sys_enter_execve)int tp_sys_enter_execve(struct my_syscalls_enter_execve *ctx) BTF 可以帮助我们处理 tracepoint 的上下文(context)。 但是在 BTF 不可用的情况下，以下是一些应对措施：每个 tracepoint 都有一个格式（format），用来描述从跟踪点中被追踪输出的字段（fields）。 以下是 execve() 系统调用入口处跟踪点的格式说明： cat /sys/kernel/tracing/events/syscalls/sys_enter_execve/format name: sys_enter_execveID: 761format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:const char * filename; offset:16; size:8; signed:0; field:const char *const * argv; offset:24; size:8; signed:0; field:const char *const * envp; offset:32; size:8; signed:0;print fmt: filename: 0x%08lx, argv: 0x%08lx, envp: 0x%08lx, ((unsigned long)(REC-filename)), ((unsigned long)(REC-argv)), ((unsigned long)(REC-envp)) 可以使用上述信息定义一个名为 my_syscalls_enter_execve 的结构体： NOTE:eBPF 程序不允许访问前四个字段。 struct my_syscalls_enter_execve unsigned short common_type; unsigned char common_flags; unsigned char common_preempt_count; int common_pid;\tlong syscall_nr;\tvoid *filename_ptr;\tlong argv_ptr;\tlong envp_ptr;; 附加到该跟踪点的 eBPF 示例程序，可以将指向此类型的指针用作其上下文(context)参数，然后就可以访问这个结构体的内容了。 int tp_sys_enter_execve(struct my_syscalls_enter_execve *ctx) struct data_t data = ; ... bpf_probe_read_user(data.path, sizeof(data.path), ctx-filename_ptr); 当使用跟踪点（tracepoint）程序类型时，传递给 eBPF 程序的结构体已由一组原始参数映射而来。 为获得更优性能，可以通过原始跟踪点（raw tracepoint）eBPF 程序类型直接访问这些原始参数。此时，段定义（section definition）应以 raw_tp（或 raw_tracepoint）开头，而非 tp。 SEC(raw_tp/sched_process_exec)int raw_tp_exec(struct bpf_raw_tracepoint_args *ctx) struct data_t data = ; bpf_probe_read_kernel(data.message, sizeof(data.message), raw_tp_exec_msg); data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_perf_event_output(ctx, output, BPF_F_CURRENT_CPU, data, sizeof(data)); return 0; 7.4.4 BTF-Enabled Tracepoints在 BTF 支持下，在 vmlinux.h 中会定义一个与传递给跟踪点 eBPF 程序的上下文结构体相匹配的结构体。 eBPF 程序应该使用 SEC(tp_btf/tracepoint name)，其中跟踪点名称是 /sys/kernel/tracing/available_events 中列出的可用事件之一。 SEC(tp_btf/sched_process_exec)int handle_exec(struct trace_event_raw_sched_process_exec *ctx) 结构名称与跟踪点名称匹配，前缀为 trace_event_raw_ 。 7.4.5 User Space Attachmentsuprobes 和 uretprobes 用于挂载到用户态函数的入口和出口。用户态静态定义跟踪点 user statically defined tracepoints (USDTs) 用于挂载应用程序代码或用户态库中指定的跟踪点。这些都是用 BPF_PROG_TYPE_KPROBE 类型。 如果你正在使用 libbpf，那么 SEC() 宏可用于为这些用户态探测程序 (user space probes) 定义自动挂载点。具体格式可参考 Program Types and ELF Sections。 比如，将用户态入口探测（uprobe）挂载到 OpenSSL 中 SSL_write() 函数的起始处： SEC(uprobe/usr/lib/aarch64-linux-gnu/libssl.so.3/SSL_write) 一些例子： bashreadline.bpf.c funclatency.c usdt_sample.md 7.4.6 LSMBPF_PROG_TYPE_LSM 程序附加到 Linux 安全模块 (LSM) API，这是内核中的一个稳定接口，最初供内核模块用来强制执行安全策略。 BPF_PROG_TYPE_LSM 程序使用 bpf(BPF_RAW_TRACEPOINT_OPEN) 附加，并且在许多方面它们被视为跟踪程序。 BPF_PROG_TYPE_LSM 程序的一个有趣特征是返回值会影响内核的行为方式。非零返回值表示安全检查未通过，因此内核不会继续执行要求完成的任何操作。这与忽略返回值的 perf 相关程序类型有显着差异。 7.5 NetworkingThese program types all require CAP_NET_ADMIN and CAP_BPF, or CAP_SYS_ADMIN, capabilities to be permitted. The context passed to these types of programs is the network message in question, although the type of structure depends on the data the kernel has at the relevant point in the network stack. Layer 7 covers formats intended for applications to use, such as HTTP, DNS, or gRPC; TCP is at Layer 4; IP is at Layer 3; and Ethernet and WiFi are at Layer 2. 7.5.1 Sockets BPF_PROG_TYPE_SOCKET_FILTER was the first program type to be added to the kernel. It’s used to filter a copy of socket data that can be sent to an observability tool such as tcpdump. A socket is specific to a Layer 4 (TCP) connection. BPF_PROG_TYPE_SOCK_OPS allows eBPF programs to intercept various operations and actions that take place on a socket, and to set for that socket parameters such as TCP timeout values. BPF_PROG_TYPE_SK_SKB programs are used in conjunction with a special map type that holds a set of references to sockets to provide what’s known as sockmap operations: redirecting traffic to different destinations at the socket layer. 7.5.2 Traic ControleBPF programs can be attached to provide custom filters and classifiers for network packets for both ingress and egress traffic. 7.5.3 XDPXDP (eXpress Data Path) The roughly equivalent command for loading and attaching the program to eth0 would be this: ip link set dev eth0 xdp obj hello.bpf.o sec xdp Removing the XDP program with ip link can be done like this: ip link set dev eth0 xdp off 7.5.4 Flow DissectoreBPF programs of type BPF_PROG_TYPE_FLOW_DISSECTOR can implement custom packet dissection. 7.5.5 Lightweight TunnelsThe family of BPF_PROG_TYPE_LWT_* program types can be used to implement network encapsulation in eBPF programs. 7.5.6 Cgroups control groups Cgroups are a concept in the Linux kernel that restricts the set of resources a given process or group of processes can have access to. Attaching eBPF programs to a cgroup allows for custom behavior that only applies to that cgroup’s processes. a BPF_CGROUP_SYSCTL program type that can be attached to sysctl commands affecting a particular cgroup. BPF_PROG_TYPE_CGROUP_SOCK and BPF_PROG_TYPE_CGROUP_SKB. eBPF programs can determine whether a given cgroup is permitted to perform a requested socket operation or data transmission. 7.5.7 Infrared ControllersPrograms of type BPF_PROG_TYPE_LIRC_MODE2 can be attached to the file descriptor for an infrared controller device to provide decoding for infrared protocols. 7.6 BPF Attachment TypesThe attachment type offers more fine-grained control over where a program can be attached in the system. For example, XDP programs are attached to XDP hooks in the network stack. The attachment type is involved in deciding which helper functions are valid, and it also restricts access to parts of the context information in some cases. You can also see which program types need an attachment type to be specified, and which attachment types are valid, in the kernel function bpf_prog_load_check_attach (defined in bpfsyscall.c). For example case BPF_PROG_TYPE_CGROUP_SOCK: switch (expected_attach_type) case BPF_CGROUP_INET_SOCK_CREATE: case BPF_CGROUP_INET_SOCK_RELEASE: case BPF_CGROUP_INET4_POST_BIND: case BPF_CGROUP_INET6_POST_BIND: return 0; default: return -EINVAL; 7.7 SummaryIf you want to write code that responds to a particular event, you’ll need to determine the program type(s) that are appropriate for hooking onto that event. The context passed into the program depends on the program type, and the kernel may also respond differently to the return code from your program, depending on its type. 7.8 Exercisestodo"},{"title":"08. eBPF for Networking","path":"/wiki/ebpf/learning-ebpf-08.html","content":"eBPF 允许开发者构建满足特定需求的网络功能，而无需将这些功能强制推行给所有上游内核用户。 基于 eBPF 的网络工具现在被广泛使用，并已被证明在大规模应用中非常有效。 Cilium 自 2017 年以来，所有进出 Facebook 的数据包都经过了 XDP 程序的处理 Cloudflare 使用 eBPF 来进行 DDoS（分布式拒绝服务）保护 8.1 Packet Drops有几种涉及丢弃特定传入数据包和允许其他数据包的网络安全功能。 防火墙 根据源、目的 IP 地址以及端口号，逐个数据包决定是否允许数据包。 DDoS 防护 可能要跟踪来自特定来源的数据包的到达速度，检测数据包内容的某些特征，以确定攻击者或一组攻击者正试图用流量淹没接口。 致命数据包漏洞 (packet-of-death vulnerabilities) 传统上，当发现这种内核漏洞时，需要安装修复的新内核，这需要停机维护。 能检测并丢弃这些恶意数据包的 eBPF 程序可以动态安装，在不影响机器上运行的任何应用程序的情况下立即保护主机。 8.1.1 XDP Program Return Codes网络数据包的到达会触发 XDP 程序。程序会检查数据包，检查完毕后，返回值会给出一个决策(verdict)，指出下一步该如何处理该数据包： XDP_PASS 数据包应以正常方式发送到网络协议栈（就像没有 XDP 程序时的执行流程） XDP_DROP 立即丢弃数据包 XDP_TX 将数据包从其到达的同一接口发送回去 XDP_REDIRECT 将数据包从不同的网络接口发送回去 XDP_ABORTED 丢弃数据包，但它的使用意味着出现错误或出现意外情况，而不是 “正常” 决定丢弃数据包 决定是否丢弃数据包的 XDP 程序大致如下： SEC(xdp)int hello(struct xdp_md *ctx) bool drop; drop = examine packet and decide whether to drop it; if (drop) return XDP_DROP; else return XDP_PASS; 每当一个入站网络数据包到达其所连接的接口时，XDP 程序就会被触发。ctx 参数是一个指向 xdp_md 结构体的指针，该结构体保存了传入数据包的元数据。 8.1.2 XDP Packet Parsingxdp_md 结构体的定义如下： struct xdp_md __u32 data; __u32 data_end; __u32 data_meta; /* Below access go through struct xdp_rxq_info */ __u32 ingress_ifindex; /* rxq-dev-ifindex */ __u32 rx_queue_index; /* rxq-queue_index */ __u32 egress_ifindex; /* txq-dev-ifindex */; 不要被前三个字段的 __u32 类型所迷惑，因为它们实际上是指针。 data 字段指示数据包在内存中的起始位置，data_end 表示数据包的结束位置。 数据包前面的内存中还有一个区域，位于 data_meta 和 data 之间，用于存储有关该数据包的元数据。该区域可用于协调多个 eBPF 程序，这些程序可能会在数据包通过网络协议栈的不同位置处理同一个数据包。 hello ping示例代码中有一个名为 ping() 的 XDP 程序，每当检测到 ping (ICMP) 数据包时，它就会简单地生成一行跟踪信息。该程序的代码如下： SEC(xdp)int ping(struct xdp_md *ctx) long protocol = lookup_protocol(ctx); if (protocol == 1) // ICMP bpf_printk(Hello ping); return XDP_PASS; 运行方式如下： $ cd learning-ebpf/chapter8$ makebpftool net detach xdp dev lorm -f /sys/fs/bpf/hellobpftool prog load hello.bpf.o /sys/fs/bpf/hellobpftool net attach xdp pinned /sys/fs/bpf/hello dev lo $ ping localhost $ cat /sys/kernel/tracing/trace_pipe ping-62820 [001] ..s21 177285.227847: bpf_trace_printk: Hello ping ping-62820 [001] ..s21 177285.228119: bpf_trace_printk: Hello ping ping-62820 [001] ..s21 177286.232176: bpf_trace_printk: Hello ping ping-62820 [001] ..s21 177286.232185: bpf_trace_printk: Hello ping 每秒有两行跟踪信息，是因为回环接口同时接收 ping 请求和 ping 响应。 通过添加如下代码，在协议匹配时返回 XDP_DROP，可以实现丢弃 ping 数据包： if (protocol == 1) // ICMP bpf_printk(Hello ping);+ return XDP_DROP; 在这个 XDP 程序中，大部分工作都是在一个名为 lookup_protocol() 的函数中完成的，该函数用于确定第 4 层协议类型。这只是一个示例，并不是解析网络数据包的高质量实现！ 接收到的网络数据包由一串字节组成，其布局如图所示： ethhdr 和 iphdr 的定义如下： struct ethhdr unsigned char\th_dest[ETH_ALEN];\t/* destination eth addr\t*/\tunsigned char\th_source[ETH_ALEN];\t/* source ether addr\t*/\t__be16 h_proto; /* packet type ID field\t*/ __attribute__((packed));struct iphdr #if defined(__LITTLE_ENDIAN_BITFIELD)\t__u8\tihl:4, version:4;#elif defined (__BIG_ENDIAN_BITFIELD)\t__u8\tversion:4, ihl:4;#else#error\tPlease fix asm/byteorder.h#endif\t__u8\ttos;\t__be16\ttot_len;\t__be16\tid;\t__be16\tfrag_off;\t__u8\tttl;\t__u8\tprotocol;\t__sum16\tcheck;\t__be32\tsaddr;\t__be32\tdaddr;\t/*The options start here. */; lookup_protocol() 函数接收 ctx 结构体作为参数，该结构体保存数据包在内存中的位置信息，并返回它在 IP 报头中找到的协议类型。代码如下： // Returns the protocol byte for an IP packet, 0 for anything else// static __always_inline unsigned char lookup_protocol(struct xdp_md *ctx)unsigned char lookup_protocol(struct xdp_md *ctx) unsigned char protocol = 0; // 记录网络数据包的起始位置和结束位置 void *data = (void *)(long)ctx-data; void *data_end = (void *)(long)ctx-data_end; // 以太网报头开始 struct ethhdr *eth = data; // 验证器要求明确检查这个网络数据包足够容纳以太网报头 if (data + sizeof(struct ethhdr) data_end) return 0; // Check that its an IP packet if (bpf_ntohs(eth-h_proto) == ETH_P_IP) // Return the protocol of this packet // 1 = ICMP // 6 = TCP // 17 = UDP // 如果是 IP 数据包，则 IP 报头紧跟在以太网报头之后 struct iphdr *iph = data + sizeof(struct ethhdr); // 验证器要求明确检查这个网络数据包足够容纳 IP 报头 if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) = data_end) protocol = iph-protocol; return protocol; bpf_ntohs() 函数可确保两个字节按照主机序排列。网络协议是大端字节序，但大多数处理器是小端字节序，这意味着它们以不同的顺序保存多字节值。此函数将从网络序转换为主机序（如有必要）。 NOTE:当从长度超过一个字节的网络数据包中提取字段信息时，都应该使用 bpf_ntohs()。 8.2 Load Balancing and ForwardingXDP 程序不仅限于检查数据包的内容，还可以修改数据包的内容。 如图所示，这是一组在同一主机上运行的容器。有一个客户端、一个负载均衡器和两个后端，每个后端都在自己的容器中运行。负载均衡器接收来自客户端的流量并将其转发到任意一个后端容器。 示例代码仅用于学习，请勿用于生产环境。 SEC(xdp_lb)int xdp_load_balancer(struct xdp_md *ctx) // 定位数据包中的以太网报头，然后定位 IP 报头。 void *data = (void *)(long)ctx-data; void *data_end = (void *)(long)ctx-data_end; struct ethhdr *eth = data; if (data + sizeof(struct ethhdr) data_end) return XDP_ABORTED; if (bpf_ntohs(eth-h_proto) != ETH_P_IP) return XDP_PASS; struct iphdr *iph = data + sizeof(struct ethhdr); if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) data_end) return XDP_ABORTED; // 这次它将只处理 TCP 数据包，将收到的任何其他数据包传递给网络协议栈，就好像什么也没发生一样。 if (iph-protocol != IPPROTO_TCP) return XDP_PASS; // 检查源 IP 地址。 if (iph-saddr == IP_ADDRESS(CLIENT)) // 在后端 A 和 B 之间生成伪随机选择。 char be = BACKEND_A; if (bpf_get_prandom_u32() % 2) be = BACKEND_B; // 更新目标 IP 和 MAC 地址，以匹配所选的后端... iph-daddr = IP_ADDRESS(be); eth-h_dest[5] = be; // 如果该数据包不是来自客户端，就认为它是发给客户端的响应。 else // 更新目标 IP 和 MAC 地址以匹配客户端。 iph-daddr = IP_ADDRESS(CLIENT); eth-h_dest[5] = CLIENT; // 无论该数据包流向何处，都需要更新源地址，以便该数据包看起来像是源自负载均衡器。 iph-saddr = IP_ADDRESS(LB); eth-h_source[5] = LB; iph-check = iph_csum(iph); return XDP_TX; 8.3 XDP Offloading有一些网卡支持完整的 XDP 卸载 (XDP Offloading) 功能，它们确实可以在自己的处理器上运行 eBPF 程序来处理传入的数据包。 这就意味着，从同一物理接口丢弃或重定向回来的数据包（如本章前面的数据包丢弃和负载均衡示例），主机内核永远不会看到，主机上的 CPU 周期也不会用于处理这些数据包，因为所有工作都是在网卡上完成的。 即使物理网卡不支持完整的 XDP 卸载，许多 NIC 驱动程序也支持 XDP 钩子，这可以最大限度地减少 eBPF 程序处理数据包所需的内存复制。 8.4 Traic Control (TC)当网络数据包到达这一附加点时，它将以 sk_buff 的形式存在于内核内存中，sk_buff 在整个内核的网络协议栈都有使用。 在 TC 子系统中附加的 eBPF 程序会接收一个指向 sk_buff 结构体的指针作为上下文参数。 NOTE:您可能想为什么 XDP 程序不在其上下文中使用 sk_buff 结构。答案是，XDP 钩子发生在网络数据到达网络协议栈之前以及 sk_buff 结构体建立之前。 TC 子系统旨在调节网络流量的调度方式。例如，您可能希望限制每个应用程序的可用带宽，以便它们都能获得公平的机会。但在调度单个数据包时，带宽并不是一个非常有意义的术语，因为它是指发送或接收的平均数据量。某个特定的应用程序可能非常容易有突发流量，或者另一个应用程序可能对网络延迟非常敏感，因此 TC 可以对数据包的处理方式和优先级进行更精细的控制。 延伸阅读： Understanding tc “direct action” mode for BPF 引入 eBPF 程序是为了对 TC 内使用的算法进行自定义控制。但由于 eBPF 程序具有操纵、丢弃或重定向数据包的功能，因此也可用作复杂网络行为的构建模块。 网络协议栈中给定的网络数据流有两个方向：入口（ingress，从网络接口进入）或出口（egress，向网络接口输出）。eBPF 程序可以附加在任一方向上，并只影响该方向上的流量。 NOTE:与 XDP 不同， TC 可以附加多个 eBPF 程序，并按顺序进行处理。 传统的流量控制分为： 分类器 (classifers)：根据某些规则对数据包进行分类 单独的操作 (separate actions)：根据分类器的输出决定如何处理数据包。 可以有一系列分类器，它们都被定义为 qdisc 或排队规则（queuing discipline）的一部分。 eBPF 程序是作为分类器附加在程序上的，但它们也可以决定在同一程序中采取什么行动。该操作由程序的返回值（其值在 linux/pkt_cls.h 中定义）表示： TC_ACT_SHOT: 告诉内核丢弃数据包 TC_ACT_UNSPEC: 就像 eBPF 程序尚未在此数据包上运行一样（因此它将被传递到序列中的下一个分类器（如果有）） TC_ACT_OK: 告诉内核将数据包传递到网络协议栈的下一层 TC_ACT_REDIRECT: 将数据包发送到不同网络设备的入口或出口路径 示例1：只是生成一行跟踪信息，然后告诉内核丢弃数据包： int tc_drop(struct __sk_buff *skb) bpf_trace_printk([tc] dropping packet ); return TC_ACT_SHOT; 示例2：丢弃 ICMP (ping) 请求数据包 int tc(struct __sk_buff *skb) void *data = (void *)(long)skb-data; void *data_end = (void *)(long)skb-data_end; if (is_icmp_ping_request(data, data_end)) struct iphdr *iph = data + sizeof(struct ethhdr); struct icmphdr *icmp = data + sizeof(struct ethhdr) + sizeof(struct iphdr); bpf_trace_printk([tc] ICMP request for %x type %x , iph-daddr, icmp-type); return TC_ACT_SHOT; return TC_ACT_OK; sk_buff 结构体具有指向数据包数据开始和结束的指针，这与 xdp_md 结构体非常相似，数据包的解析过程也大致相同。同样，要通过验证，必须明确检查对数据的任何访问是否在 data 和 data_end 之间的范围内。 既然 XDP 已经实现了同样的功能，为什么还要在 TC 层实现这样的功能呢？ 可以使用 TC 程序处理出口流量，而 XDP 只能处理入口流量。 由于 XDP 会在数据包到达时立即触发，此时并不存在与数据包相关的 sk_buff 内核数据结构。如果 eBPF 程序对内核为该数据包创建的 sk_buff 感兴趣或想对其进行操作，那么 TC 附加点是合适的。 延伸阅读： BPF and XDP Reference Guide 示例3：识别收到的 ping 请求，并作出 ping 响应。 int tc_pingpong(struct __sk_buff *skb) void *data = (void *)(long)skb-data; void *data_end = (void *)(long)skb-data_end; if (!is_icmp_ping_request(data, data_end)) return TC_ACT_OK; struct iphdr *iph = data + sizeof(struct ethhdr); struct icmphdr *icmp = data + sizeof(struct ethhdr) + sizeof(struct iphdr); swap_mac_addresses(skb); swap_ip_addresses(skb); // Change the type of the ICMP packet to 0 (ICMP Echo Reply) (was 8 for ICMP Echo request) update_icmp_type(skb, 8, 0); // sends a clone of the packet back through the interface (skb-ifindex) on which it was received. bpf_clone_redirect(skb, skb-ifindex, 0); //the original packet should be dropped return TC_ACT_SHOT; 如今，许多网络功能都是由用户空间服务处理的，但如果用 eBPF 程序来替代，很可能会大大提高性能。在内核中处理的数据包不需要通过协议栈的所有部分；数据包不需要传输到用户空间进行处理，而响应也不需要传回内核。更重要的是，两者可以并行运行——eBPF 程序可以为任何需要复杂处理而自己又无法处理的数据包返回 TC_ACT_OK，这样它就可以正常传递到用户空间服务。 8.5 Packet Encryption and DecryptionIn many cases an application will encrypt data using a library like OpenSSL or BoringSSL that lives in user space. If you want to trace out this data in its unencrypted form, you can use an eBPF program attached to the right place in the user space code. 8.5.1 User Space SSL LibrariesAn application using OpenSSL sends data to be encrypted by making a call to a function called SSL_write() and retrieves cleartext data that was received over the network in encrypted form using SSL_read(). https://github.com/pixie-io/pixie-demos/tree/main/openssl-tracer static int process_SSL_data(struct pt_regs* ctx, uint64_t id, enum ssl_data_event_type type, const char* buf) int len = (int)PT_REGS_RC(ctx); if (len 0) return 0; struct ssl_data_event_t* event = create_ssl_data_event(id); if (event == NULL) return 0; event-type = type; // This is a max function, but it is written in such a way to keep older BPF verifiers happy. event-data_len = (len MAX_DATA_SIZE ? (len (MAX_DATA_SIZE - 1)) : MAX_DATA_SIZE); bpf_probe_read(event-data, event-data_len, buf); tls_events.perf_submit(ctx, event, sizeof(struct ssl_data_event_t)); return 0; 8.6 eBPF and Kubernetes NetworkingIn Kubernetes environments, applications are deployed in pods. Each pod is a group of one or more containers that share kernel namespaces and cgroups, isolating pods from each other and from the host machine they are running on. eBPF enables replacing iptables and conntrack with a more efficient solution for managing network rules and connection tracking. 8.6.1 Avoiding iptablespods – and their IP addresses – come and go dynamically, and each time a pod is added or removed, the iptables rules have to be rewritten in their entirety, and this impacts performance at scale. Cilium uses eBPF hash table maps to store network policy rules, connection tracking, and load balancer lookup tables, which can replace iptables for kube-proxy. 8.6.2 Coordinated Network Programsflat networking mode, in which Cilium allocates IP addresses for all the pods in a cluster from the same CIDR and directly routes traffic between them. Different eBPF programs get invoked to handle traffic depending on whether a packet is destined for a local container, the local host, another host on this network, or a tunnel. 8.6.3 Network Policy EnforcementCilium uses Kubernetes identities to determine whether a given network policy rule applies. In the same way labels define which pods are part of a service in Kubernetes, labels also define Cilium’s security identity for the pod. eBPF hash tables, indexed by these service identities, make for very efficient rule lookups. 8.6.4 Encrypted Connectionstransparent encryption. It’s called “transparent” because it takes place entirely at the network layer. There are two in-kernel encryption protocols in common usage, IPsec and WireGuard. they set up a secure tunnel between two machines. The CNI can choose to connect the eBPF endpoint for a pod via this secure tunnel. eBPF is now enabling a new approach that builds on transparent encryption but uses TLS for the initial certificate exchange and endpoint authentication so that the identities can represent individual applications rather than the nodes they are running on. 8.7 Summarytodo 8.8 Exercises and Further Readingtodo"},{"title":"09. eBPF for Security","path":"/wiki/ebpf/learning-ebpf-09.html","content":"9.1 Security Observability Requires Policy and Contexta security tool needs to be able to distinguish between events that are expected under normal circumstances and events that suggest malicious activity might be taking place. Policies have to take into account not just normal behavior when systems are fully functional, but also the expected error path behavior. Defining what is and isn’t expected behavior is the job of a policy. The more contextual information that’s available to the investigator, the more likely they will be able to find out the root cause of the event and determine whether it was an attack, which components were affected, how and when the attack took place, and who was responsible. 9.2 Using System Calls for Security EventsSystem calls (or syscalls) are the interface between user space applications and the kernel. 9.2.1 SeccompSECure COMPuting seccomp is used to limit the set of syscalls a process can use to a very small subset: read(), write(), _exit(), and sigreturn(). seccomp-bpf: Instead of having a fixed subset of syscalls that it permits, this mode of seccomp uses BPF code to filter the syscalls that are and aren’t allowed. The outcome is one of a set of possible actions that include: Allowing the syscall to go ahead Returning an error code to the user space application Killing the thread Notifying a user space application (seccomp-unotify) (as of kernel version 5.0) Generating Seccomp ProilesIn the early days, seccomp profiles were generally compiled using strace to gather the set of syscalls an application calls. There are a couple of tools that do this, using eBPF to gather information about all the syscalls being called: Inspektor Gadget includes a seccomp profiler that allows you to generate a custom seccomp profile for the containers in a Kubernetes pod. Red Hat created a seccomp profiler in the form of an OCI runtime hook. Syscall-Tracking Security Toolsthe CNCF project Falco, which provides security alerts Users can define rules to determine what events are security relevant, and Falco can generate alerts in a variety of formats when events happen that don’t match the policies defined in these rules. BPF_PROBE(raw_syscalls/, sys_enter, sys_enter_args)BPF_PROBE(raw_syscalls/, sys_exit, sys_exit_args) Since eBPF programs can be loaded dynamically and can detect events triggered by preexisting processes, tools like Falco can apply policies to application workloads that are already running. Unfortunately there is a problem with this approach of using syscall entry points for security tooling: there is a Time Of Check to Time Of Use (TOCTOU) issue. When an eBPF program is triggered at the entry point to a system call, it can access the arguments that user space has passed to that system call. If those arguments are pointers, the kernel will need to copy the pointed-to data into its own data structures before acting on that data. there is a window of opportunity for an attacker to modify this data, after it has been inspected by the eBPF program but before the kernel copies it. The Sysmon for Linux tool addresses the TOCTOU window by attaching to both the entry and exit points for syscalls. if the syscall returns a file descriptor, the eBPF program attached to the exit can retrieve correct information about the object that the file descriptor represents by looking into the related process’s file descriptor table. 9.3 BPF LSMLSM 接口提供了一组钩子函数，这些钩子函数均会在内核即将对内核数据结构执行操作之前触发。钩子调用的函数可决定是否允许该操作继续执行。该接口最初是为了支持以内核模块的形式实现安全工具而设计的；而 BPF LSM 对其进行了扩展，使得 eBPF 程序也能挂载到这些相同的钩子点上。 内核源代码中存在数百个 LSM 钩子。需要明确的是，系统调用与 LSM 钩子之间并非一一对应的关系，但如果某个系统调用从安全角度来看可能会执行一些需要关注的操作，那么对该系统调用的处理就会触发一个或多个 LSM 钩子。 示例：当使用 chmod 命令时被调用 SEC(lsm/path_chmod)int BPF_PROG(path_chmod, const struct path *path, umode_t mode) bpf_printk(Change mode of file name %s , path-dentry-d_iname); return 0; 返回非零值会拒绝执行此修改的权限，因此内核不会继续进行该操作。值得注意的是，像这样完全在内核内部进行策略检查的方式，具备极高的性能。 NOTE:LSM BPF 在内核版本 5.7 中被加入。 9.4 Cilium TetragonTetragon is part of the Cilium project. Tetragon’s approach is to build a framework for attaching eBPF programs to arbitrary functions in the Linux kernel. Tetragon is designed for use in a Kubernetes environment, and the project defines a custom Kubernetes resource type called a TracingPolicy. spec: kprobes: - call: fd_install... matchArgs: - index: 1 operator: Prefix values: - /etc/... 9.4.1 Attaching to Internal Kernel FunctionsThe “fd” stands for “file descriptor,” and the comment in the source code for this function tells us this function “Install[s] a file pointer in the fd array.” This happens when a file is opened, and it’s called after the file’s data structure has been populated in the kernel. 9.4.2 Preventative SecurityIn kernel versions 5.3 and up, there is a BPF helper function called bpf_send_signal(). Tetragon uses this function to implement preventative security. If a policy defines a Sigkill action, any matching events will cause Tetragon eBPF code to generate a SIGKILL signal that terminates the process that was attempting the out-of-policy action. Sigkill policies need to be used with care, because an incorrectly configured policy could result in terminating applications unnecessarily, but it’s an incredibly powerful use of eBPF for security purposes. 9.5 Network SecurityNetwork security tools are very often used in a preventative mode, dropping packets rather than just auditing malicious activity. Firewalling and DDoS protection are a natural fit for eBPF programs attached early in the ingress path for network packets. And with the possibility of XDP programs offloaded to hardware, malicious packets may never even reach the CPU! For implementing more sophisticated network policies, such as Kubernetes policies determining which services are allowed to communicate with one another, eBPF programs that attach to points in the network stack can drop packets if they are determined to be out of policy. 9.6 SummaryIn this chapter you saw how eBPF’s use in security has evolved from low-level checks on system calls to much more sophisticated use of eBPF programs for security policy checks, in-kernel event filtering, and runtime enforcement."},{"title":"10. eBPF Programming","path":"/wiki/ebpf/learning-ebpf-10.html","content":"eBPF programming consists of two parts: Writing eBPF programs that run in the kernel Writing the user space code that manages and interacts with eBPF programs 10.1 BpftraceThe bpftrace command-line tool converts programs written in this high-level language into eBPF kernel code and provides some output formatting for the results within the terminal. a nice tutorial that takes you from writing a simple “Hello World” script up to writing more sophisticated scripts that can trace out data read from within kernel data structures. list the available tracepoints and kprobes on a machine with the -l option bpftrace -l *execve* it’s possible to attach to a kprobe called do_execve. bpftrace -e kprobe:do_execve @[comm] = count(); The @[comm] = count(); part is the script attached to that event. opensnoop.bt reports on files being opened. /usr/sbin/opensnoop.bt 10.2 Language Choices for eBPF in the KerneleBPF programs can be written directly in eBPF bytecode, but in practice, most are compiled to bytecode from either C or Rust. These languages have compilers that support eBPF bytecode as a target output. eBPF bytecode isn’t a suitable target for all compiled languages. BPF programs are required to be single threaded, so any concurrency features in a language couldn’t be used. 10.3 BCC PythonLuaC++10.4 C and LibbpfIf you’re comfortable with programming in C, using libbpf can make a lot of sense. To write your own libbpf programs in C, the best place to start is libbpf-bootstrap. libxdp that builds on libbpf to allow for easier development and management of XDP programs. the XDP Tutorial 10.5 Go10.5.1 GobpfPossibly the first serious Golang implementation. However, it hasn’t been actively maintained for a while. 10.5.2 Ebpf-goThe eBPF Go library included as part of the Cilium project is widely used. 10.5.3 LibbpfgoThe libbpfgo project by Aqua Security implements a Go wrapper around libbpf’s C code, providing utilities for loading and attaching programs and using Go-native features like channels for receiving events. 10.6 Rust10.6.1 Libbpf-rsLibbpf-rs is part of the libbpf project, and provides a Rust wrapper around the libbpf C code so that you can write the user space parts of eBPF code in Rust. 10.6.2 RedbpfRedbpf is a set of Rust crates that interface with libbpf, developed as part of foniod, an eBPF-based security monitoring agent. 10.6.3 AyaAya is built in Rust directly to the syscall level, so it doesn’t depend on libbpf. 10.6.4 Rust-bccRust-bcc provides Rust bindings that mimic the BCC project’s Python bindings, along with some Rust implementations of some of the BCC set of tracing tools. 10.7 Testing BPF ProgramsThere’s a bpf() command, BPF_PROG_RUN, that allows for running an eBPF program from user space for test purposes. You can also get information about eBPF program performance with some built-in statistics information. Run the following command to enable it: sysctl -w kernel.bpf_stats_enabled=1 10.8 Multiple eBPF ProgramsAn eBPF program is a function attached to an event in the kernel. Many applications need to track more than one event to achieve their goals. 10.9 Summaryan up-to-date list of the major language projects around eBPF 10.10 Exercisestodo"},{"title":"env","path":"/wiki/ebpf/libbpf-bootstrap-00.html","content":"Githublibbpf-bootstraphttps://github.com/libbpf/libbpf-bootstrap DeepWikideepwikihttps://deepwiki.com/libbpf/libbpf-bootstrap Env WSL2 Ubuntu 24.04 BuildingInstall Dependenciessudo apt install clang libelf1 libelf-dev zlib1g-dev Getting the source codegit clone --recurse-submodules https://github.com/libbpf/libbpf-bootstrap.git C Examples$ git submodule update --init --recursive # check out libbpf$ cd examples/c$ make$ sudo ./bootstrapTIME EVENT COMM PID PPID FILENAME/EXIT CODE00:21:22 EXIT python3.8 4032353 4032352 [0] (123ms)00:21:22 EXEC mkdir 4032379 4032337 /usr/bin/mkdir00:21:22 EXIT mkdir 4032379 4032337 [0] (1ms)00:21:22 EXEC basename 4032382 4032381 /usr/bin/basename00:21:22 EXIT basename 4032382 4032381 [0] (0ms)00:21:22 EXEC sh 4032381 4032380 /bin/sh00:21:22 EXEC dirname 4032384 4032381 /usr/bin/dirname00:21:22 EXIT dirname 4032384 4032381 [0] (1ms)00:21:22 EXEC readlink 4032387 4032386 /usr/bin/readlink^C"},{"title":"minimal","path":"/wiki/ebpf/libbpf-bootstrap-01.html","content":"运行$ cd examples/c$ make minimal$ sudo ./minimal $ sudo cat /sys/kernel/debug/tracing/trace_pipe ...-3840345 [010] d... 3220701.101143: bpf_trace_printk: BPF triggered from PID 3840345. ...-3840345 [010] d... 3220702.101265: bpf_trace_printk: BPF triggered from PID 3840345. QA你可能会发现`sudocat/sys/kernel/debug/tracing/trace_pipe`没有任何的输出信息。这是因为在 WSL 中运行的进程处于一个 PID 命名空间（PID namespace）内，因此从用户空间（userspace）获取的 PID 是该命名空间内的 PID，而通过 eBPF 代码中的 bpf_get_current_pid_tgid 函数获取的 PID 则是全局 PID（global PID）。 以下是我的分析和调试过程： 使用 strace 确认 sys_enter_write 是否被调用，通过以下命令重新运行 minimal # 使用 root 用户$ strace ./minimal 可以看到如下输出信息，确认 sys_enter_write 被调用： execve(./minimal, [./minimal], 0x7ffc2c4a8660 /* 35 vars */) = 0...write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0 在 handle_tp 的函数入口和函数返回前，通过 bpf_printk 增加打印信息，确认函数的执行流程 SEC(tp/syscalls/sys_enter_write)int handle_tp(void *ctx)+ bpf_printk(handle_tp );\tint pid = bpf_get_current_pid_tgid() 32;\tif (pid != my_pid)+ bpf_printk(pid != my_pid ); return 0;\tbpf_printk(BPF triggered from PID %d. , pid);\treturn 0; 通过查找代码库的 Issues ，我发现如下两条相关信息： libbpflibbpf-bootstrap#75 microsoftWSL#8461 实际上代码库已经给出了解决方案😅，那就是使用 minimal_ns 。 代码梳理这是一个实用的最小化 BPF 应用程序示例。该示例不使用也不依赖 BPF CO-RE（BPF 编译时重定位）技术，因此可在相当老旧的内核版本上运行。 它会安装一个跟踪点（tracepoint）处理程序，该处理程序每秒触发一次。示例中使用 bpf_printk() 这个 BPF 辅助函数与外部环境进行通信。 The BPF side minimal.bpf.c #include linux/bpf.h#include bpf/bpf_helpers.h #include linux/bpf.h 导入了一些基础的、必要的 BPF 相关的类型和常量，以便使用内核侧的 BPF API。 #include bpf/bpf_helpers.h 由 libbpf 提供的，包含了大多数常用的宏、常量和 BPF helper 的定义，几乎会在每个 BPF 应用中用到。 char LICENSE[] SEC(license) = Dual BSD/GPL; LICENSE 变量定义了你的 BPF 代码的 license。在内核开发中，明确 license 是必须的。一些 BPF 功能对于不兼容 GPL 的代码是不可用的。 int my_pid = 0; 定义了一个全局变量，BPF 代码可以读取和更新它。这样的全局变量能够从用户侧读写。这个特性是从 Linux 5.5 之后才支持的。它也经常用于在内核中的 BPF 代码和用户侧的控制代码之间传递数据。 SEC(tp/syscalls/sys_enter_write)int handle_tp(void *ctx) ... 定义了一个 tracepoint BPF 程序，每次用户空间的应用调用了系统调用 write() 的时候，就会触发它。 在同一个 BPF C 程序文件中，可能有多个 BPF 程序。他们可以是不同类型的，有着不同的 SEC() 宏。在同一个 BPF C 代码文件中的所有的 BPF 程序共享所有的全局状态，例如上面例子中的 my_pid 变量，如果使用了 BPF map，它也是共享的。这常常用在 BPF 程序的协作中。 下面看下 BPF 程序 handle_tp 在做什么： int pid = bpf_get_current_pid_tgid() 32;if (pid != my_pid)\treturn 0; 这部分获取了 PID，或者说是内核术语中的 “TGID” ，它存储在 bpf_get_current_pid_tgid() 返回值的高 32 位。 接着，查看触发了 write() 系统调用的进程是否是我们的 minimal 进程。 全局变量 my_pid 是通过下面的用户空间的代码进行初始化的，它会被初始化成真实的 PID 值。 bpf_printk(BPF triggered from PID %d. , pid); 这就是 BPF 中的 printf(“Hello, world! ”)。它输出格式化的字符串到一个特殊的文件，叫作 /sys/kernel/debug/tracing/trace_pipe。 bpf_printk() 和 trace_pipe 文件一般不在生产环境中使用，它们是用来辅助 BPF 程序的 debug 的，帮助开发者知道自己的代码到底干了些什么事情。 The user-space side minimal.c #include minimal.skel.h 这里导入了 BPF 代码 minimal.bpf.c 中的 BPF skeleton。 它是在 Makefile中的某一步，由 bpftool 自动生成的文件，像这样： bpftool gen skeleton minimal.bpf.o minimal.skel.h 它高度抽象了 minimal.bpf.c 的结构，也简化了 BPF 代码部署的逻辑，将编译出的 BPF 目标代码嵌入到了头文件中，该头文件又会被用户空间的代码所引用。你的应用程序的二进制文件中不会有其他多余的文件了，只导入它就好了。 关于 BPF skeleton 的更多信息可以参考: Learning eBPF: 5.9 The Libbpf Library for User Spacehttps://gaoyangu.github.io/wiki/ebpf/learning-ebpf-05/#5-9-The-Libbpf-Library-for-User-Space minimal 应用的 main() 函数在做什么： static int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)\treturn vfprintf(stderr, format, args);int main(int argc, char **argv)\tstruct minimal_bpf *skel;\tint err;\t/* Set up libbpf errors and debug info callback */\tlibbpf_set_print(libbpf_print_fn); libbpf_set_print() 提供了一个自定义的回调给所有的 libbpf 日志输出。它允许捕获有用的 libbpf 调试日志。默认情况下，libbpf 将只打印错误级别的信息。调试日志则会帮助我们更快地定位问题。 /* Open BPF application */skel = minimal_bpf__open();if (!skel) fprintf(stderr, Failed to open BPF skeleton );\treturn 1;/* ensure BPF program only handles write() syscalls from our process */skel-bss-my_pid = getpid();/* Load verify BPF programs */err = minimal_bpf__load(skel);if (err) fprintf(stderr, Failed to load and verify BPF skeleton );\tgoto cleanup; 使用自动生成的 BPF skeleton，加载 BPF 程序到内核中，然后让 BPF verifier 校验它是否合法，如果这步成功了，你的 BPF 代码就是正确的。 我们需要与 BPF 传递我们的用户态程序的 PID，以便它能够过滤掉不相关的进程触发的 write() 事件。上面的代码会直接设置映射过的内存区域的 BPF 全局变量 my_pid。 关于 my_pid 存储在 bss 段的原因，可参考： c语言内存分配https://gaoyangu.github.io/wiki/ebpf/sections/ /* Attach tracepoint handler */err = minimal_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton );\tgoto cleanup; 将 handle_tp BPF 程序附加到对应的内核跟踪点（tracepoint）上。这一操作会 “激活” 该 BPF 程序，此后每当有 write() 系统调用被触发时，内核便会在内核上下文中执行我们自定义的 BPF 代码。 for (;;) /* trigger our BPF program */\tfprintf(stderr, .);\tsleep(1); 周期性地（每秒）调用 fprintf(stderr, .)，从而触发 write() 系统调用。 cleanup:\tminimal_bpf__destroy(skel);\treturn -err; 在内核和用户空间清除所有的资源。也有一些类型的 BPF 程序，会在内核中一直保持活跃，即使它自己的用户空间的进程已经结束了。"},{"title":"minimal_ns","path":"/wiki/ebpf/libbpf-bootstrap-02.html","content":"描述:如何获取 namespace 中的进程ID minimal_ns 与 minimal 功能相同，但其适用于命名空间环境。 minimal 在存在命名空间的环境中（如容器或 WSL2）无法正常工作，原因是该环境下进程的 “感知 PID”（perceived pid）并非进程的 “实际 PID”（actual pid）。 代码梳理The BPF side minimal_ns.bpf.c SEC(“tpsyscallssys_enter_write”)SEC(tp/syscalls/sys_enter_write)int handle_tp(void *ctx) bpf_get_ns_current_pid_tgidint my_pid = 0;unsigned long long dev;unsigned long long ino;bpf_get_ns_current_pid_tgid(dev, ino, ns, sizeof(ns));if (ns.pid != my_pid)\treturn 0; The user-space side minimal_ns.c procselfnspid/* ensure BPF program only handles write() syscalls from our process */if (stat(/proc/self/ns/pid, sb) == -1) fprintf(stderr, Failed to acquire namespace information); return 1;skel-bss-dev = sb.st_dev;skel-bss-ino = sb.st_ino;skel-bss-my_pid = getpid(); stat(/proc/self/ns/pid, sb) 用于获取当前进程所属的「PID 命名空间（PID Namespace）」的元数据，通过返回的 struct stat 结构体中的 st_ino（inode 号），识别当前进程的 PID 命名空间归属（判断两个进程是否在同一个 PID 命名空间）。"},{"title":"minimal_Legacy","path":"/wiki/ebpf/libbpf-bootstrap-03.html","content":"描述:SEC(.maps)的使用方式 在 2019 年才增加了对全局变量的支持，在此之前只能使用 eBPF map 来实现。 minimal_Legacy 可在不支持全局变量的更老旧内核上运行。全局变量 my_pid 已替换为一个仅含一个元素的数组，用于存储进程 ID（pid）。 在包含 bpf_helpers.h 头文件之前，若未定义 BPF_NO_GLOBAL_DATA 宏，则 bpf_printk 函数会使用全局变量。 代码梳理The BPF sideSEC(“.maps”)typedef unsigned int u32;typedef int pid_t;/* Create an array with 1 entry instead of a global variable * which does not work with older kernels */struct __uint(type, BPF_MAP_TYPE_ARRAY);\t__uint(max_entries, 1);\t__type(key, u32);\t__type(value, pid_t); my_pid_map SEC(.maps); SEC(“tpsyscallssys_enter_write”)SEC(tp/syscalls/sys_enter_write)int handle_tp(void *ctx) bpf_map_lookup_elemu32 index = 0;pid_t *my_pid = bpf_map_lookup_elem(my_pid_map, index);if (!my_pid || *my_pid != pid)\treturn 1; The user-space sidebpf_map__update_elempid_t pid;unsigned index = 0;/* ensure BPF program only handles write() syscalls from our process */pid = getpid();err = bpf_map__update_elem(skel-maps.my_pid_map, index, sizeof(index), pid, sizeof(pid_t), BPF_ANY);if (err 0) fprintf(stderr, Error updating map with pid: %s , strerror(err)); goto cleanup;"},{"title":"bootstrap","path":"/wiki/ebpf/libbpf-bootstrap-04.html","content":"描述:适用于生产环境下的BPF应用的通用基础模板 bootstrap 是一个简单但适用于生产环境下的 BPF 应用。它依赖 BPF CO-RE，同时要求内核编译时配置 CONFIG_DEBUG_INFO_BTF=y。 它会跟踪进程的启动和退出事件，并输出相关数据，包括文件名、进程 ID（PID）、父进程 ID（PPID），以及进程的退出状态和生命周期。 它展示了几个典型的 BPF 功能的使用方式: 协调工作的 BPF 程序 用于维护状态的 BPF map 用于向用户空间发送数据的 BPF ring buffer 用于实现应用程序行为参数化的全局变量 利用 BPF CO-RE 和 vmlinux.h 头文件，从内核的 task_struct 结构体中读取额外的进程信息 运行 显示存活时间至少 50ms 的进程 $ ./bootstrap -d 50TIME EVENT COMM PID PPID FILENAME/EXIT CODE10:38:01 EXIT tail 48249 48247 [0] (133ms)10:38:01 EXIT tail 48327 48325 [0] (52ms)10:38:01 EXIT tail 48365 48363 [0] (52ms)10:38:01 EXIT manpath 48416 48193 [0] (53ms)10:38:38 EXIT ping 48530 48193 [0] (5654ms) 开启 libbpf 的 debug 日志 $ ./bootstrap -v The BPF side头文件#include vmlinux.h#include bpf/bpf_helpers.h#include bpf/bpf_tracing.h#include bpf/bpf_core_read.h#include bootstrap.h vmlinux.h 头文件中包含了 BPF 程序可能需要的、与某个内核相关的所有数据结构信息。它是在 libbpf-bootstrap 项目里预先生成的，开发者也可以自动使用 bpftool 生成，具体可参考 gen_vmlinux_h.sh。 TIPS:只使用 libbpf 提供的 vmlinux.h 头文件就可以，如果同时包含其它内核头文件，会出现重复定义的问题。 Read-only global variableconst volatile unsigned long long min_duration_ns = 0; const volatile 表示该变量不论是在 BPF side，还是在 user-space side，都是只读的。如果不使用 volatile，Clang 就可能假设该变量的值为 0，并将其彻底移除。 BPF mapsBPF_MAP_TYPE_HASHstruct __uint(type, BPF_MAP_TYPE_HASH);\t__uint(max_entries, 8192);\t__type(key, pid_t);\t__type(value, u64); exec_start SEC(.maps); 定义一个名为 exec_start，类型为 BPF_MAP_TYPE_HASH 的哈希表。最大容纳 8192 个元素，key 是 pid_t 类型，value 是 u64 类型，用于存储进程运行事件的纳秒粒度的时间戳。 SEC(“tpschedsched_process_exec”)SEC(tp/sched/sched_process_exec)int handle_exec(struct trace_event_raw_sched_process_exec *ctx) bpf_map_update_elempid_t pid;u64 ts;/* remember time exec() was executed for this PID */pid = bpf_get_current_pid_tgid() 32;ts = bpf_ktime_get_ns();bpf_map_update_elem(exec_start, pid, ts, BPF_ANY); 在哈希表中添加，更新元素。 BPF_ANY: 添加一个新的键（key），或者更新已有的键值对 BPF_NOEXIST：仅当键（key）不存在时才会执行更新操作，以防止覆盖已有的数据。 BPF_EXIST：仅当键（key）已存在时才会执行更新操作，以确保仅对已有键进行更新，而不创建新的键 SEC(“tpschedsched_process_exit”)SEC(tp/sched/sched_process_exit)int handle_exit(struct trace_event_raw_sched_process_template *ctx) bpf_map_lookup_elem在另一个 BPF 程序 (handle_exit) 中，从同一个 BPF map 中查询元素，然后删除它。 start_ts = bpf_map_lookup_elem(exec_start, pid);if (start_ts) duration_ns = bpf_ktime_get_ns() - *start_ts;else if (min_duration_ns) return 0;bpf_map_delete_elem(exec_start, pid); BPF ring bufferBPF_MAP_TYPE_RINGBUFstruct __uint(type, BPF_MAP_TYPE_RINGBUF);\t__uint(max_entries, 256 * 1024); rb SEC(.maps); 定义一个名为 rb，类型为 BPF_MAP_TYPE_RINGBUF 的环形缓冲区。 bpf_ringbuf_reserve/* reserve sample from BPF ringbuf */e = bpf_ringbuf_reserve(rb, sizeof(*e), 0);if (!e) return 0; bpf_ringbuf_reserve 用于在环形缓冲区申请连续的内存块，第一个参数为指向环形缓冲区的指针，第二个参数为要在环形缓冲区中预留的字节数，第三个参数必须为 0。 BPF_CORE_READ/* fill out the sample with data */task = (struct task_struct *)bpf_get_current_task();e-exit_event = false;e-pid = pid;e-ppid = BPF_CORE_READ(task, real_parent, tgid);bpf_get_current_comm(e-comm, sizeof(e-comm)); BPF_CORE_READ 用于简化 BPF CO-RE 可重定位读取操作，尤其适用于指针追踪步骤较少的场景。BPF_CORE_READ(task, real_parent, tgid) 相当于 task-real_parent-tgid。 ctx-__data_loc_filenamefname_off = ctx-__data_loc_filename 0xFFFF;bpf_probe_read_str(e-filename, sizeof(e-filename), (void *)ctx + fname_off); libbpf 访问 tracepoint 上下文字段的格式： __data_loc_some_field。（低 16 位偏移 + 高 16 位长度） 0xFFFF 用于提取低 16 位的偏移量。 参考： Learning eBPF: 7.4.3 Tracepointshttps://gaoyangu.github.io/wiki/ebpf/learning-ebpf-07/#7-4-3-Tracepoints 每个跟踪点（tracepoint）都有一个格式（format），该格式用于描述从该跟踪点中会被跟踪输出的字段： $ cat /sys/kernel/tracing/events/sched/sched_process_exec/formatname: sched_process_execID: 317format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1;signed:0; field:int common_pid; offset:4; size:4; signed:1; field:__data_loc char[] filename; offset:8; size:4; signed:0; field:pid_t pid; offset:12; size:4; signed:1; field:pid_t old_pid; offset:16; size:4; signed:1;print fmt: filename=%s pid=%d old_pid=%d, __get_str(filename), REC-pid, REC-old_pid bpf_ringbuf_submit/* successfully submit it to user-space for post-processing */bpf_ringbuf_submit(e, 0); bpf_ringbuf_submit 会使环形缓冲区中预留的数据变为可读取状态。 0：发送自适应的新数据可用通知 BPF_RB_NO_WAKEUP：不发送新数据可用通知 BPF_RB_FORCE_WAKEUP：无条件发送新数据可用通知 The user-space sideopen load/* Load and verify BPF application */skel = bootstrap_bpf__open();if (!skel) fprintf(stderr, Failed to open and load BPF skeleton ); return 1;/* Parameterize BPF code with minimum duration parameter */skel-rodata-min_duration_ns = env.min_duration_ms * 1000000ULL;/* Load verify BPF programs */err = bootstrap_bpf__load(skel);if (err) fprintf(stderr, Failed to load and verify BPF skeleton ); goto cleanup; 只读全局变量需要在 BPF skeleton 加载到内核之前完成设置，因此需要分 __open 和 __load 两步进行。当 BPF skeleton 完成 __load 之后，不论是在 BPF side，还是在 user-space side 都只能读该变量。 attach/* Attach tracepoints */err = bootstrap_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton ); goto cleanup; ring_buffer__newstruct ring_buffer *rb = NULL;rb = ring_buffer__new(bpf_map__fd(skel-maps.rb), handle_event, NULL, NULL);if (!rb) err = -1; fprintf(stderr, Failed to create ring buffer ); goto cleanup; 环形缓冲区（ring buffer） 指的是一种循环缓冲区，其中 eBPF 程序作为生产者，用户空间（userspace）作为消费者。尽管返回值的数据类型是 struct ring_buffer *，但它实际上是用于管理多个环形缓冲区的管理器。 ring_buffer__poll/* Process events */while (!exiting) err = ring_buffer__poll(rb, 100 /* timeout, ms */); /* Ctrl-C will cause -EINTR */ if (err == -EINTR) err = 0; break; if (err 0) printf(Error polling perf buffer: %d , err); break; 轮询属于环形缓冲区管理器（ring buffer manager）的任一环形缓冲区（ring buffer）上的可用数据。 若存在可用数据，已注册的回调函数（callback functions）将被调用； 若不存在可用数据，该函数会等待 timeout_ms（毫秒）以等待数据到达，并在此期间处于阻塞（block）状态。 clean_upcleanup: /* Clean up */ ring_buffer__free(rb); bootstrap_bpf__destroy(skel); todousing argp API (part of libc) for command-line argument parsing"},{"title":"bootstrap_legacy","path":"/wiki/ebpf/libbpf-bootstrap-05.html","content":"描述:BPF_MAP_TYPE_PERF_EVENT_ARRAY 的使用方式。 bootstrap_legacy 会将环形缓冲区映射（ring buffer maps）替换为性能事件数组（perf event array，对应 BPF 映射类型 BPF_MAP_TYPE_PERF_EVENT_ARRAY），以实现与旧版内核的兼容性。 运行$ ./bootstrap_legacyTIME EVENT COMM PID PPID FILENAME/EXIT CODE17:26:53 EXEC sh 24694 22237 /bin/sh17:26:53 EXEC grep 24696 24694 /usr/bin/grep17:26:53 EXEC ls 24695 24694 /usr/bin/ls17:26:53 EXIT ls 24695 24694 [2] (5ms)17:26:53 EXIT grep 24696 24694 [0] (6ms)17:26:53 EXIT sh 24694 22237 [0] (8ms) The BPF sideBPF mapsBPF_MAP_TYPE_PERF_EVENT_ARRAYstruct __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\t__uint(key_size, sizeof(u32));\t__uint(value_size, sizeof(u32)); perf_buffer SEC(.maps); SEC(“tpschedsched_process_exec”)SEC(tp/sched/sched_process_exec)int handle_exec(struct trace_event_raw_sched_process_exec *ctx) SEC(“tpschedsched_process_exit”)SEC(tp/sched/sched_process_exit)int handle_exit(struct trace_event_raw_sched_process_template *ctx) bpf_perf_event_output/* use perf event output to send data to user-space for post-processing */bpf_perf_event_output(ctx, perf_buffer, BPF_F_CURRENT_CPU, e, sizeof(e)); eBPF map 的数据存入索引，有两种索引指定方式： 手动指定索引并经掩码处理：BPF_F_INDEX_MASK 是 “索引掩码”，用于过滤 修正传入的映射索引值 自动使用当前 CPU 核心索引：BPF_F_CURRENT_CPU 表示 “当前 CPU”，是便捷定位当前运行 CPU 核心索引的预设标志 每个性能事件（perf event）都创建于特定的 CPU 之上。此辅助函数（helper）仅能写入与 eBPF 程序运行在同一 CPU 上的性能事件；若手动指定的索引对应的性能事件位于其他 CPU，运行时会返回 -EOPNOTSUPP 错误。 因此，除非有充分的合理理由，否则建议使用 BPF_F_CURRENT_CPU 标志，并以 “CPU 索引与映射（map）索引保持一致” 的方式填充 BPF_MAP_TYPE_PERF_EVENT_ARRAY 类型的映射。 The user-space sideperf_buffer__new/* Set up perf buffer polling */perf_buffer = perf_buffer__new(bpf_map__fd(skel-maps.perf_buffer), 8, handle_event, NULL, NULL, NULL);if (!perf_buffer) err = -1; fprintf(stderr, Failed to create perf event buffer ); goto cleanup; 8 表示的是 number of memory pages，每个 page 是 4KB，因此总大小： 8 pages x 4096 bytepage 32KB。即设置 per-CPU buffer 为 32KB。 perf_buffer__pollwhile (!exiting) err = perf_buffer__poll(perf_buffer, 100 /* timeout, ms */); /* Ctrl-C will cause -EINTR */ if (err == -EINTR) err = 0; break; if (err 0) printf(Error polling perf buffer: %d , err); break; clean_upcleanup:\t/* Clean up */\tperf_buffer__free(perf_buffer);\tbootstrap_legacy_bpf__destroy(skel);"},{"title":"uprobe","path":"/wiki/ebpf/libbpf-bootstrap-06.html","content":"uprobe 是处理用户态入口探测与退出探测的示例，对应的两种探测类型分别是 uprobe（用户态入口探测）和 uretprobe（用户态返回探测）。 它会将 uprobe 和 uretprobe 类型的 BPF 程序，分别挂载到自身的函数（uprobed_add() 和 uprobed_sub()）上，并通过 bpf_printk() 宏，分别记录这些函数的输入参数与返回结果。用户态函数每秒会触发一次。 运行./uprobelibbpf: loading object uprobe_bpf from buffer... $ cat /sys/kernel/debug/tracing/trace_pipe uprobe-16616 [001] ...11 349920.493709: bpf_trace_printk: uprobed_add ENTRY: a = 22, b = 23 uprobe-16616 [001] ...11 349920.493797: bpf_trace_printk: uprobed_add EXIT: return = 45 uprobe-16616 [001] ...11 349920.493818: bpf_trace_printk: uprobed_sub ENTRY: a = 484, b = 22 uprobe-16616 [001] ...11 349920.493824: bpf_trace_printk: uprobed_sub EXIT: return = 462 addNOTE:仅声明探针类型，需要在加载时绑定目标 The BPF side 探针本身不绑定任何目标程序函数，灵活性高（可复用探针跟踪不同程序）。 SEC(“uprobe”)SEC(uprobe)int BPF_KPROBE(uprobe_add, int a, int b)\tbpf_printk(uprobed_add ENTRY: a = %d, b = %d, a, b);\treturn 0; BPF_KPROBE 是一个宏。在编写挂载在函数起始处的 kprobe（内核探针）程序时使用。 uprobe_add 是函数名，int a, int b 为函数的参数。 SEC(“uretprobe”)SEC(uretprobe)int BPF_KRETPROBE(uretprobe_add, int ret)\tbpf_printk(uprobed_add EXIT: return = %d, ret);\treturn 0; BPF_KRETPROBE 是一个宏。在编写挂载在函数返回的 kprobe（内核探针）程序时使用。 The user-space sideuprobed_add__attribute__((noinline)) 和 asm volatile (); 都是为了防止编译器将函数内联(inline)。 __attribute__((noinline)) int uprobed_add(int a, int b)\tasm volatile ();\treturn a + b; LIBBPF_OPTSLIBBPF_OPTS(bpf_uprobe_opts, uprobe_opts); 使用 LIBBPF_OPTS 声明一个类型是 bpf_uprobe_opts，变量名为 uprobe_opts 的结构体。 struct bpf_uprobe_opts /* size of this struct, for forward/backward compatibility */ size_t sz; size_t ref_ctr_offset; __u64 bpf_cookie; bool retprobe; const char *func_name; enum probe_attach_mode attach_mode; size_t :0;; bpf_program__attach_uprobe_opts/* Attach tracepoint handler */uprobe_opts.func_name = uprobed_add;uprobe_opts.retprobe = false;/* uprobe/uretprobe expects relative offset of the function to attach* to. libbpf will automatically find the offset for us if we provide the* function name. If the function name is not specified, libbpf will try* to use the function offset instead.*/skel-links.uprobe_add = bpf_program__attach_uprobe_opts(skel-progs.uprobe_add, 0 /* self pid */, /proc/self/exe, 0 /* offset for function */, uprobe_opts /* opts */);if (!skel-links.uprobe_add) err = -errno; fprintf(stderr, Failed to attach uprobe: %d , err); goto cleanup; skel-progs.uprobe_add：要附加的 BPF 程序。此处为 uprobe.bpf.c 中定义的 uprobe_add 函数。 0 /* self pid */：附加 uprobe 的进程 ID。 0 表示当前进程，-1 表示所有进程。 /proc/self/exe：包含函数符号的二进制文件的路径。 0 /* offset for function */：函数符号在二进制文件中的 offset。 uprobe_opts /* opts */：options。 subNOTE:显式绑定目标程序和函数 The BPF sideSEC(“uprobeprocselfexe:uprobed_sub”)SEC(uprobe//proc/self/exe:uprobed_sub)int BPF_KPROBE(uprobe_sub, int a, int b)\tbpf_printk(uprobed_sub ENTRY: a = %d, b = %d, a, b);\treturn 0; uprobe/ 后紧跟着目标程序绝对路径，/proc/self/exe 表示绑定当前进程。再用 : 后加函数名 uprobed_sub。 无需加载时指定额外目标，探针直接绑定到指定程序的指定函数。 支持跟踪系统库函数，自定义程序函数 SEC(“uretprobeprocselfexe:uprobed_sub”)SEC(uretprobe//proc/self/exe:uprobed_sub)int BPF_KRETPROBE(uretprobe_sub, int ret)\tbpf_printk(uprobed_sub EXIT: return = %d, ret);\treturn 0; The user-space sideuprobed_sub__attribute__((noinline)) int uprobed_sub(int a, int b)\tasm volatile ();\treturn a - b; uprobe_bpf__attach由于已经在 SEC 中提供了目标程序的绝对路径和函数名，uprobe_sub/uretprobe_sub 只需 attach 即可。 /* Let libbpf perform auto-attach for uprobe_sub/uretprobe_sub * NOTICE: we provide path and symbol info in SEC for BPF programs */err = uprobe_bpf__attach(skel);if (err) fprintf(stderr, Failed to auto-attach BPF skeleton: %d , err); goto cleanup; call funcfor (i = 0;; i++) /* trigger our BPF programs */ fprintf(stderr, .); uprobed_add(i, i + 1); uprobed_sub(i * i, i); sleep(1); cleanupcleanup:\tuprobe_bpf__destroy(skel);"},{"title":"fentry","path":"/wiki/ebpf/libbpf-bootstrap-08.html","content":"fentry 示例使用 fentry 和 fexit 类型的 BPF 程序进行跟踪。它会将 fentry 和 fexit 跟踪器附加到 do_unlinkat() 函数上，此函数会在文件被删除时被调用，并且会将函数的返回值、进程标识符（PID）以及文件名记录到跟踪管道（trace pipe）中。 与 kprobes 相比，增强了性能和可用性 能够像 c 语言一样直接解引用指针 fexit 不仅可以访问入参，还可以访问返回值；而 kretprobe 只能访问返回值 NOTE:内核版本 5.5 开始支持 fentry 和 fexit 运行$ ./fentry libbpf: loading object fentry_bpf from buffer... $ cat /sys/kernel/debug/tracing/trace_pipe ...-45337 [004] ...11 107881.547637: bpf_trace_printk: fentry: pid = 45337, filename = test_file ...-45337 [004] ...11 107881.547704: bpf_trace_printk: fexit: pid = 45337, filename = test_file, ret = 0 $ cd ~$ touch test_file$ rm -rf test_file The BPF sideSEC(“fentrydo_unlinkat”)SEC(fentry/do_unlinkat)int BPF_PROG(do_unlinkat, int dfd, struct filename *name)\tpid_t pid;\tpid = bpf_get_current_pid_tgid() 32;\tbpf_printk(fentry: pid = %d, filename = %s , pid, name-name);\treturn 0; BPF_PROG(do_unlinkat, int dfd, struct filename *name)BPF 程序的函数签名为 do_unlinkat，输入参数为 dfd 和 name。 args函数的入参 int dfd, struct filename *name 是如何确定的? do_unlinkat 是内核函数，查询Linux 源码可获知该函数具有 dfd 与 name 两个输入参数、返回值为一个 int 类型的值。 SEC(“fexitdo_unlinkat”)SEC(fexit/do_unlinkat)int BPF_PROG(do_unlinkat_exit, int dfd, struct filename *name, long ret)\tpid_t pid;\tpid = bpf_get_current_pid_tgid() 32;\tbpf_printk(fexit: pid = %d, filename = %s, ret = %ld , pid, name-name, ret);\treturn 0; The user-space sideopen_and_load/* Open load and verify BPF application */skel = fentry_bpf__open_and_load();if (!skel) fprintf(stderr, Failed to open BPF skeleton ); return 1; attach/* Attach tracepoint handler */err = fentry_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton ); goto cleanup; whilewhile (!stop) fprintf(stderr, .); sleep(1); cleanupcleanup:\tfentry_bpf__destroy(skel);"},{"title":"usdt","path":"/wiki/ebpf/libbpf-bootstrap-07.html","content":"usdt 是使用 USDT 探针的一个示例。它会将 USDT 类型的 BPF 程序挂载到 libc:setjmp 探针上，该探针会在用户态程序调用 setjmp 函数时被触发（每秒触发一次），并通过 bpf_printk() 宏记录 USDT 探针的参数。 USDT (user statically defined tracepoint，用户态静态定义跟踪点) 用于挂载应用程序代码或用户态库中指定的跟踪点。 setjmp() 是 C 标准库 setjmp.h 中的一个宏，用于保存当前的程序执行状态，以便在稍后的某个时候通过 longjmp() 来返回到该状态。 运行$ ./usdtlibbpf: loading object usdt_bpf from buffer... $ cat /sys/kernel/debug/tracing/trace_pipeusdt-25683 [006] ...11 2624.434591: bpf_trace_printk: USDT manual attach to libc:setjmp: arg1 = 55d480464080, arg2 = 0, arg3 = 55d48041549dusdt-25683 [006] ...11 2625.434730: bpf_trace_printk: USDT manual attach to libc:setjmp: arg1 = 55d480464080, arg2 = 0, arg3 = 55d48041549d autoThe BPF sideusdt.bpf.h#include vmlinux.h#include bpf/bpf_helpers.h#include bpf/bpf_tracing.h#include bpf/usdt.bpf.h usdt.bpf.h 定义了一组用于处理用户空间静态跟踪点（USDT）的宏和函数。 SEC(“usdtlibc.so.6:libc:setjmp”)SEC(usdt/libc.so.6:libc:setjmp)int BPF_USDT(usdt_auto_attach, void *arg1, int arg2, void *arg3)\tpid_t pid = bpf_get_current_pid_tgid() 32;\tif (pid != my_pid) return 0;\tbpf_printk(USDT auto attach to libc:setjmp: arg1 = %lx, arg2 = %d, arg3 = %lx, arg1, arg2, arg3);\treturn 0; BPF_USDTBPF_USDT 与 BPF_PROG 类似，但是专用于 USDT 探针。 USDT 程序本质上是一种用户态入口探测（uprobe），其设计用途是挂载到 USDT 跟踪点上。这类跟踪点能够传递参数，但与遵循 ABI（应用程序二进制接口）的函数参数不同，跟踪点的参数可存在于进程内的任意位置。跟踪点会使用 GAS（GNU 汇编器）操作数来描述这些参数，而该宏则允许你将程序中的这些参数定义为 “如同普通参数一样实际传递给程序” 的形式。 args如何确认函数参数的数量和类型？比如此处的 void *arg1, int arg2, void *arg3。 要跟踪的 setjmp 是 libc 里的函数，因此在指定的 libc.so.6 里列出所有 USDT探针，确认是否存在 setjump 相关的探针。 $ bpftrace -l usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:* | grep setjmpusdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:setjmp 读取 libc.so.6 文件中的 NOTE 段内容，NOTE 段通常包含调试信息、静态探针描述等元数据。 $ readelf --notes /usr/lib/x86_64-linux-gnu/libc.so.6 | grep -A10 setjmp Name: setjmp Location: 0x0000000000044f15, Base: 0x00000000001d6720, Semaphore: 0x0000000000000000 Arguments: 8@%rdi -4@%esi 8@%rax stapsdt 0x0000003b NT_STAPSDT (SystemTap probe descriptors) Provider: libc Name: longjmp Location: 0x00000000000450f3, Base: 0x00000000001d6720, Semaphore: 0x0000000000000000 Arguments: 8@%rdi -4@%esi 8@%rdx stapsdt 0x00000042 NT_STAPSDT (SystemTap probe descriptors) Provider: libc Name: longjmp_target 其中： Provider 标识程序名 Name 标识探测点的名称 Location 记录了探测点的位置（在程序中的地址偏移） Arguments 为探针的参数列表（格式为大小@寄存器或内存位置）。 参数列表中： 8@%rdi：第一个参数占 8 字节，位于 %rdi 寄存器； 指向 jmp_buf 上下文缓冲区的指针 -4@%esi：第二个参数占 4 字节，位于 %esi 寄存器； -4 表示 “取 % esi 寄存器的低 4 字节”； libc 的 setjmp 本质是 sigsetjmp(env, 0) 的封装（默认不保存信号掩码），% esi 是第二个参数 savesigs，表示是否保存信号掩码（0 不保存，非 0 保存） 8@%rax：第三个参数占 8 字节，位于 %rax 寄存器。 libc 内部的 jmp_buf 扩展数据指针（指向 jmp_buf 关联的辅助信息）。 The user-space sideusdt_bpf__openstruct usdt_bpf *skel;skel = usdt_bpf__open();if (!skel) fprintf(stderr, Failed to open BPF skeleton ); return 1; usdt_bpf__loadskel-bss-my_pid = getpid();err = usdt_bpf__load(skel);if (!skel) fprintf(stderr, Failed to load BPF skeleton ); return 1; usdt_bpf__attacherr = usdt_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton ); goto cleanup; tiggerstatic jmp_buf env;static void usdt_trigger()\tsetjmp(env); while (!exiting) /* trigger our BPF programs */ usdt_trigger(); fprintf(stderr, .); sleep(1); cleanupcleanup:\tusdt_bpf__destroy(skel); manualThe BPF sideSEC(“usdt”)SEC(usdt)int BPF_USDT(usdt_manual_attach, void *arg1, int arg2, void *arg3)\tbpf_printk(USDT manual attach to libc:setjmp: arg1 = %lx, arg2 = %d, arg3 = %lx, arg1, arg2, arg3);\treturn 0; The user-space sidebpf_program__attach_usdt与 bpf_program__attach_uprobe_opts 的作用类似，用于 USDT（用户态静态定义跟踪点）的挂载，而非挂载到用户态函数的入口或出口。 /** Manually attach to libc.so we find.* We specify pid here, so we dont have to do pid filtering in BPF program.*/skel-links.usdt_manual_attach = bpf_program__attach_usdt( skel-progs.usdt_manual_attach, getpid(), libc.so.6, libc, setjmp, NULL);if (!skel-links.usdt_manual_attach) err = errno; fprintf(stderr, Failed to attach BPF program `usdt_manual_attach` ); goto cleanup; skel-progs.usdt_manual_attach：要附加的 BPF 程序。此处为 usdt.bpf.c 中定义的 usdt_manual_attach 函数。 getpid()：附加 uprobe 的进程 ID。 0 表示当前进程，-1 表示所有进程。 libc.so.6：包含指定 USDT 探针（用户态静态定义跟踪点探针）的二进制文件路径。 libc：USDT 探针的提供者名称。 setjmp：USDT 探针的名称。 NULL: 修改程序挂载的可选配置。"},{"title":"kprobe","path":"/wiki/ebpf/libbpf-bootstrap-09.html","content":"kprobe 是一个处理内核空间入口探针（kprobe）和出口（返回）探针（kretprobe）的示例。它会将 kprobe 和 kretprobe 类型的 BPF 程序分别附加到 do_unlinkat() 函数上，并使用 bpf_printk() 记录进程标识符（PID）、文件名以及返回结果。 运行$ ./kprobe libbpf: loading object kprobe_bpf from buffer... $ cat /sys/kernel/debug/tracing/trace_pipe ...-47878 [001] ...21 108736.735085: bpf_trace_printk: KPROBE ENTRY pid = 47878, filename = test_file ...-47878 [001] ...21 108736.735174: bpf_trace_printk: KPROBE EXIT: pid = 47878, ret = 0 $ cd ~$ touch test_file$ rm -rf test_file The BPF sideSEC(“kprobedo_unlinkat”)SEC(kprobe/do_unlinkat)int BPF_KPROBE(do_unlinkat, int dfd, struct filename *name)\tpid_t pid;\tconst char *filename;\tpid = bpf_get_current_pid_tgid() 32;\tfilename = BPF_CORE_READ(name, name);\tbpf_printk(KPROBE ENTRY pid = %d, filename = %s , pid, filename);\treturn 0; 可以看到，与 fentry 相比，此处需要使用 BPF_CORE_READ(name, name) 获取 filename。 传统的五子棋传统的 kprobe/kretprobe 方式，是通过动态符号表（kallsyms）找到函数地址，在入口或返回处插入探针，但只能通过 pt_regs 提供的寄存器信息来获取参数，需要程序员手动解析，并且难以保证类型安全。因此在代码中只能用函数 bpf_probe_read_kernel() 对参数进行安全读取，代码中使用的 BPF_CORE_READ() 宏即是对该函数的封装。 技能五子棋fentry 和 fexit，它们可以在函数的入口和出口处精准 attach，并且不需要手动解析寄存器或做复杂的偏移计算，内核在运行时会直接把真实的参数和返回值传递给 eBPF 程序。 SEC(“kretprobedo_unlinkat”)SEC(kretprobe/do_unlinkat)int BPF_KRETPROBE(do_unlinkat_exit, long ret)\tpid_t pid;\tpid = bpf_get_current_pid_tgid() 32;\tbpf_printk(KPROBE EXIT: pid = %d, ret = %ld , pid, ret);\treturn 0; 可以看到，与fexit 相比，kretprobe 只能访问返回值。 The user-space side用户态程序与 fentry 几乎相同。 open_and_load/* Open load and verify BPF application */skel = kprobe_bpf__open_and_load();if (!skel) fprintf(stderr, Failed to open BPF skeleton ); return 1; attach/* Attach tracepoint handler */err = kprobe_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton ); goto cleanup; whilewhile (!stop) fprintf(stderr, .); sleep(1); cleanupcleanup:\tkprobe_bpf__destroy(skel);"},{"title":"tc","path":"/wiki/ebpf/libbpf-bootstrap-11.html","content":"tc（Traffic Control，流量控制）是一个处理入站网络流量的示例。它会在 lo 接口（回环接口）上创建一个队列规则（qdisc），并将 tc_ingress 类型的 BPF 程序附加到该规则上，最终上报进入 lo 接口的 IP 数据包的元数据。 前置知识8.4 Traic Control (TC)https://gaoyangu.github.io/wiki/ebpf/learning-ebpf-08/#8-4-Traic-Control-TC 运行$ ./tclibbpf: loading object tc_bpf from buffer... $ cat /sys/kernel/debug/tracing/trace_pipe node-31445 [006] ..s2. 264002.057570: bpf_trace_printk: Got IP packet: tot_len: 461, ttl: 64 node-31425 [002] ..s2. 264002.059394: bpf_trace_printk: Got IP packet: tot_len: 143, ttl: 64 node-31425 [002] ..s2. 264002.059497: bpf_trace_printk: Got IP packet: tot_len: 52, ttl: 64 The BPF sideSEC(“tc”)#include vmlinux.h#include bpf/bpf_endian.h#include bpf/bpf_helpers.h#include bpf/bpf_tracing.h#define TC_ACT_OK 0#define ETH_P_IP 0x0800 /* Internet Protocol packet\t*/SEC(tc)int tc_ingress(struct __sk_buff *ctx)\tvoid *data_end = (void *)(__u64)ctx-data_end;\tvoid *data = (void *)(__u64)ctx-data;\tstruct ethhdr *l2;\tstruct iphdr *l3;\tif (ctx-protocol != bpf_htons(ETH_P_IP)) return TC_ACT_OK;\tl2 = data;\tif ((void *)(l2 + 1) data_end) return TC_ACT_OK;\tl3 = (struct iphdr *)(l2 + 1);\tif ((void *)(l3 + 1) data_end) return TC_ACT_OK;\tbpf_printk(Got IP packet: tot_len: %d, ttl: %d, bpf_ntohs(l3-tot_len), l3-ttl);\treturn TC_ACT_OK;char __license[] SEC(license) = GPL; l2 + 1l2 是 struct ethhdr * 类型的指针（指向以太网头起始地址），在 C 语言中：结构体指针 +1，偏移的字节数 该结构体的总大小（而非 1 个字节）。 l2 + 1 等价于 data + sizeof(struct ethhdr)，即指向以太网头末尾的下一个字节（也就是 IP 头的起始位置）。l2 + 1 更直观、无需手动计算 sizeof，不易出错。 The user-space sideLO_IFINDEX 环回设备的接口索引，可通过 ip link show 命令查看 #define LO_IFINDEX 1 bpf_tc_hook 定义类型为 bpf_tc_hook ，变量名为 tc_hook 的结构体变量。 struct bpf_tc_hook size_t sz; int ifindex; enum bpf_tc_attach_point attach_point; __u32 parent; size_t :0;;enum bpf_tc_attach_point BPF_TC_INGRESS = 1 0, BPF_TC_EGRESS = 1 1, BPF_TC_CUSTOM = 1 2,; DECLARE_LIBBPF_OPTS(bpf_tc_hook, tc_hook, .ifindex = LO_IFINDEX, .attach_point = BPF_TC_INGRESS); bpf_tc_opts 定义类型为 bpf_tc_opts ，变量名为 tc_opts 的结构体变量。 struct bpf_tc_opts size_t sz; int prog_fd; __u32 flags; __u32 prog_id; __u32 handle; __u32 priority; size_t :0;; DECLARE_LIBBPF_OPTS(bpf_tc_opts, tc_opts, .handle = 1, .priority = 1); prog_fd: 要附加的 BPF 程序的文件描述符。 handle: TC 分类器的句柄。 priority: TC 分类器的优先级。取值范围 [0 - 65535]。 open_and_loadbool hook_created = false;struct tc_bpf *skel;int err;skel = tc_bpf__open_and_load();if (!skel) fprintf(stderr, Failed to open BPF skeleton ); return 1; bpf_tc_hook_create 📌 创建TC钩子，即创建 qdisc /* The hook (i.e. qdisc) may already exists because: * 1. it is created by other processes or users * 2. or since we are attaching to the TC ingress ONLY, * bpf_tc_hook_destroy does NOT really remove the qdisc, * there may be an egress filter on the qdisc */err = bpf_tc_hook_create(tc_hook);if (!err) hook_created = true;if (err err != -EEXIST) fprintf(stderr, Failed to create TC hook: %d , err); goto cleanup; bpf_program__fdtc_opts.prog_fd = bpf_program__fd(skel-progs.tc_ingress); bpf_tc_attach 📌err = bpf_tc_attach(tc_hook, tc_opts);if (err) fprintf(stderr, Failed to attach TC: %d , err); goto cleanup; whilewhile (!exiting) fprintf(stderr, .); sleep(1); bpf_tc_detach 📌 将 eBPF 程序从 TC 钩子上卸载 tc_opts.flags = tc_opts.prog_fd = tc_opts.prog_id = 0;err = bpf_tc_detach(tc_hook, tc_opts);if (err) fprintf(stderr, Failed to detach TC: %d , err); goto cleanup; cleanup 清除之前创建的 TC 钩子 cleanup:\tif (hook_created) bpf_tc_hook_destroy(tc_hook);\ttc_bpf__destroy(skel);"},{"title":"xdp","path":"/wiki/ebpf/libbpf-bootstrap-10.html","content":"xdp 是一个用 Rust 语言（基于 libbpf-rs 库）编写的示例。它会附加到网络设备的入站路径上，记录每个数据包的大小，并返回 XDP_PASS 以允许数据包向上传递到内核的网络协议栈。 前置知识08. eBPF for Networkinghttps://gaoyangu.github.io/wiki/ebpf/learning-ebpf-08/ 运行本文将该代码移植为 C 语言版本。 在 example/c 文件夹下，新建 eBPF 程序 xdppass.bpf.c，用户态程序 xdppass.c。同时需要在 Makefile 文件中添加该 XDP 程序 xdppass。 $ ip link show1: lo: LOOPBACK,UP,LOWER_UP mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: eth0: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether 00:01:02:03:04:05 brd ff:ff:ff:ff:ff:ff NOTE:Linux 不允许同一网卡同时附着多个 XDP 程序，会返回 -EBUSY 忙错误。可使用 bpftool net detach xdp dev eth0 命令将附着在 eth0 的程序 detach。 ./xdppass 1 $ cat /sys/kernel/debug/tracing/trace_pipe\tnode-50447 [003] ..s21 188234.264490: bpf_trace_printk: packet size: 81\tnode-50447 [003] ..s21 188234.264556: bpf_trace_printk: packet size: 66\tnode-50153 [007] ..s21 188236.582558: bpf_trace_printk: packet size: 85 The BPF sidexdppass.bpf.c#include vmlinux.h#include bpf/bpf_helpers.hSEC(xdp)int xdp_pass(struct xdp_md *ctx)\tvoid *data = (void *)(long)ctx-data;\tvoid *data_end = (void *)(long)ctx-data_end;\tint pkt_sz = data_end - data;\tbpf_printk(packet size: %d, pkt_sz);\treturn XDP_PASS;char __license[] SEC(license) = GPL; The user-space sidexdppass.c用户态程序参考之前的示例代码和 xdppass.c 实现。 #include stdio.h#include unistd.h#include errno.h#include signal.h#include sys/resource.h#include bpf/libbpf.h#include xdppass.skel.hstatic int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)\treturn vfprintf(stderr, format, args);static volatile sig_atomic_t stop;static void sig_int(int signo)\tstop = 1;int main(int argc, char ** argv) struct xdppass_bpf *skel = NULL; int err; int ifindex = 0; /* Set up libbpf errors and debug info callback */\tlibbpf_set_print(libbpf_print_fn); if(argc 1) ifindex = atoi(argv[1]); /* Open load and verify BPF application */ skel = xdppass_bpf__open_and_load(); if (!skel) fprintf(stderr, Failed to open BPF skeleton ); return 1; skel-links.xdp_pass = bpf_program__attach_xdp(skel-progs.xdp_pass, ifindex); if (!skel-links.xdp_pass) err = -errno; fprintf(stderr, Failed to attach XDP program to ifindex %d , ifindex); goto cleanup; err = xdppass_bpf__attach(skel);\tif (err) fprintf(stderr, Failed to auto-attach BPF skeleton: %d , err); goto cleanup; if (signal(SIGINT, sig_int) == SIG_ERR) fprintf(stderr, cant set signal handler: %s , strerror(errno)); goto cleanup; printf(Successfully started! Please run `sudo cat /sys/kernel/debug/tracing/trace_pipe` to see output of the BPF programs. ); while (!stop) fprintf(stderr, .); sleep(1);\tcleanup: xdppass_bpf__destroy(skel); return -err; other觅梦随笔: eBPF例程——XDP 这篇博文中还实现了几个进阶示例： 数据包解析以太网头 数据包重定向至其他端口 数据包重定向至用户态"},{"title":"profile (todo)","path":"/wiki/ebpf/libbpf-bootstrap-12.html","content":"profile is an example written in Rust and C using the blazesym symbolization library. It attaches to perf events, sampling on every processor periodically. It shows addresses, symbols, file names, and line numbers of stacktraces (if available)."},{"title":"sockfilter","path":"/wiki/ebpf/libbpf-bootstrap-13.html","content":"sockfilter 是一个用于监控数据包并处理 __sk_buff 结构体的示例。 它会将套接字类型的 BPF 程序附加到 sock_queue_rcv_skb() 函数上，从 BPF_MAP_TYPE_RINGBUF 类型的映射中获取信息，然后在标准输出中打印协议类型、源 IP 地址、源端口、目的 IP 地址和目的端口。 目前，该示例已涵盖了 uapi/linux/in.h 头文件中定义的大部分 IPv4 协议，若需查看支持的协议列表，可参考示例代码 examples/c/sockfilter.c 中的 ipproto_mapping 映射表。 前置知识 socket ringbuf 运行$ ./sockfilterinterface: lo protocol: TCP 127.0.0.1:60196(src) - 127.0.0.1:40705(dst)interface: lo protocol: TCP 127.0.0.1:40705(src) - 127.0.0.1:60196(dst) 或者： $ ./sockfilter -i lointerface: lo protocol: TCP 127.0.0.1:60196(src) - 127.0.0.1:40705(dst)interface: lo protocol: TCP 127.0.0.1:40705(src) - 127.0.0.1:60196(dst) struct so_event该结构体在 BPF 程序和用户态程序中都可以使用。 struct so_event __be32 src_addr;\t__be32 dst_addr;\tunion __be32 ports; __be16 port16[2];\t;\t__u32 ip_proto;\t__u32 pkt_type;\t__u32 ifindex;; __be32 be： 大端序 32：32位 相对应的，__le32 表示小端序 32 位整数。 The BPF side头文件#include sockfilter.h#define IP_MF 0x2000#define IP_OFFSET 0x1FFF BPF_MAP_TYPE_RINGBUF定义 BPF_MAP_TYPE_RINGBUF 类型的 BPF map，用于将内核收集到的事件信息传送给用户态程序 struct __uint(type, BPF_MAP_TYPE_RINGBUF);\t__uint(max_entries, 256 * 1024); rb SEC(.maps); ip_is_fragment inline 判断是否为 IP 分片包 static inline int ip_is_fragment(struct __sk_buff *skb, __u32 nhoff)\t__u16 frag_off;\tbpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, frag_off), frag_off, 2);\tfrag_off = __bpf_ntohs(frag_off);\treturn frag_off (IP_MF | IP_OFFSET); bpf_skb_load_bytes Helper function bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, frag_off), frag_off, 2); 该辅助函数提供了一种简便的方式从数据报中加载数据。它可用于从 skb 关联的数据包中，将偏移量 nhoff + offsetof(struct iphdr, frag_off) 处开始的 2 字节数据，加载到 frag_off 所指向的缓冲区中。 自 Linux 4.7 版本开始，该辅助函数的使用场景已基本被 direct packet access 替代，通过 skb-data 和 skb-data_end 即可操作数据包数据。不过，若需要一次性从数据包中读取大量数据到 eBPF 栈中，该辅助函数仍有实用价值。 __bpf_ntohs结合查到的资料，__bpf_ntohs 仅出现在 Linux 内核源码中 BPF 子系统的实现里，是 BPF 字节序转换的底层内部实现。bpf_ntohs 是封装后的公开稳定 API，更推荐使用这个。 SEC(“socket”) 附加该 eBPF 程序到 socket 收到数据包之前 SEC(socket)int socket_handler(struct __sk_buff *skb) struct so_event *e; __u8 verlen; __u16 proto; __u32 nhoff = ETH_HLEN; bpf_skb_load_bytes(skb, 12, proto, 2); proto = bpf_ntohs(proto); if (proto != ETH_P_IP) return 0; if (ip_is_fragment(skb, nhoff)) return 0; bpf_ringbuf_reserve/* reserve sample from BPF ringbuf */e = bpf_ringbuf_reserve(rb, sizeof(*e), 0);if (!e) return 0; bpf_ringbuf_submitbpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, protocol), e-ip_proto, 1);if (e-ip_proto != IPPROTO_GRE) bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, saddr), (e-src_addr), 4); bpf_skb_load_bytes(skb, nhoff + offsetof(struct iphdr, daddr), (e-dst_addr), 4);bpf_skb_load_bytes(skb, nhoff + 0, verlen, 1);bpf_skb_load_bytes(skb, nhoff + ((verlen 0xF) 2), (e-ports), 4);e-pkt_type = skb-pkt_type;e-ifindex = skb-ifindex;bpf_ringbuf_submit(e, 0); return 允许该数据包继续传递到socket， 返回值的意义是截取数据包的前多少字节传递到socket return skb-len; The user-space sideenv 要监听的端口 static struct env const char *interface; env; ipproto_mapping 协议格式与协议名的映射表， 来源可参考 static const char *ipproto_mapping[IPPROTO_MAX] = [IPPROTO_IP] = IP, [IPPROTO_ICMP] = ICMP, [IPPROTO_IGMP] = IGMP,\t[IPPROTO_IPIP] = IPIP, [IPPROTO_TCP] = TCP, [IPPROTO_EGP] = EGP,\t[IPPROTO_PUP] = PUP, [IPPROTO_UDP] = UDP, [IPPROTO_IDP] = IDP,\t[IPPROTO_TP] = TP, [IPPROTO_DCCP] = DCCP, [IPPROTO_IPV6] = IPV6,\t[IPPROTO_RSVP] = RSVP, [IPPROTO_GRE] = GRE, [IPPROTO_ESP] = ESP,\t[IPPROTO_AH] = AH, [IPPROTO_MTP] = MTP, [IPPROTO_BEETPH] = BEETPH,\t[IPPROTO_ENCAP] = ENCAP, [IPPROTO_PIM] = PIM, [IPPROTO_COMP] = COMP,\t[IPPROTO_SCTP] = SCTP, [IPPROTO_UDPLITE] = UDPLITE, [IPPROTO_MPLS] = MPLS,\t[IPPROTO_RAW] = RAW; open_raw_sockstatic int open_raw_sock(const char *name)\tstruct sockaddr_ll sll;\tint sock;\tsock = socket(PF_PACKET, SOCK_RAW | SOCK_NONBLOCK | SOCK_CLOEXEC, htons(ETH_P_ALL));\tif (sock 0) fprintf(stderr, Failed to create raw socket ); return -1; memset(sll, 0, sizeof(sll));\tsll.sll_family = AF_PACKET;\tsll.sll_ifindex = if_nametoindex(name);\tsll.sll_protocol = htons(ETH_P_ALL);\tif (bind(sock, (struct sockaddr *)sll, sizeof(sll)) 0) fprintf(stderr, Failed to bind to %s: %s , name, strerror(errno)); close(sock); return -1; return sock; sockaddr_llsockaddr_ll 是 Linux 系统特有的套接字地址结构体，隶属于 AF_PACKET 地址族，专门用于描述数据链路层（二层） 的地址和帧属性，是用户空间程序直接操作链路层数据包（如以太网帧）的核心接口。 handle_eventstatic inline void ltoa(uint32_t addr, char *dst)\tsnprintf(dst, 16, %u.%u.%u.%u, (addr 24) 0xFF, (addr 16) 0xFF, (addr 8) 0xFF, (addr 0xFF));static int handle_event(void *ctx, void *data, size_t data_sz)\tconst struct so_event *e = data;\tchar ifname[IF_NAMESIZE];\tchar sstr[16] = , dstr[16] = ;\tif (e-pkt_type != PACKET_HOST) return 0;\tif (e-ip_proto 0 || e-ip_proto = IPPROTO_MAX) return 0;\tif (!if_indextoname(e-ifindex, ifname)) return 0;\tltoa(ntohl(e-src_addr), sstr);\tltoa(ntohl(e-dst_addr), dstr);\tprintf(interface: %s\\tprotocol: %s\\t%s:%d(src) - %s:%d(dst) , ifname, ipproto_mapping[e-ip_proto], sstr, ntohs(e-port16[0]), dstr, ntohs(e-port16[1]));\treturn 0; open_and_loadstruct ring_buffer *rb = NULL;struct sockfilter_bpf *skel;int err, prog_fd, sock;env.interface = lo;/* Cleaner handling of Ctrl-C */signal(SIGINT, sig_handler);signal(SIGTERM, sig_handler);/* Load and verify BPF programs*/skel = sockfilter_bpf__open_and_load();if (!skel) fprintf(stderr, Failed to open and load BPF skeleton ); return 1; ring_buffer__new/* Set up ring buffer polling */rb = ring_buffer__new(bpf_map__fd(skel-maps.rb), handle_event, NULL, NULL);if (!rb) err = -1; fprintf(stderr, Failed to create ring buffer ); goto cleanup; SO_ATTACH_BPF 📌/* Create raw socket for localhost interface */sock = open_raw_sock(env.interface);if (sock 0) err = -2; fprintf(stderr, Failed to open raw socket ); goto cleanup;/* Attach BPF program to raw socket */prog_fd = bpf_program__fd(skel-progs.socket_handler);if (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, prog_fd, sizeof(prog_fd))) err = -3; fprintf(stderr, Failed to attach to raw socket ); goto cleanup; ring_buffer__poll/* Process events */while (!exiting) err = ring_buffer__poll(rb, 100 /* timeout, ms */); /* Ctrl-C will cause -EINTR */ if (err == -EINTR) err = 0; break; if (err 0) fprintf(stderr, Error polling perf buffer: %d , err); break; sleep(1); cleanupcleanup:\tring_buffer__free(rb);\tsockfilter_bpf__destroy(skel);"},{"title":"task_iter","path":"/wiki/ebpf/libbpf-bootstrap-14.html","content":"task_iter 是一个使用 BPF 迭代器（BPF Iterators）的示例程序。该示例会遍历主机上的所有任务（task），并获取这些任务的进程标识符（pid）、进程名称、内核栈（kernel stack）以及任务状态（state）。 用户可将某个进程标识符作为可执行文件的第一个参数传入，此举会过滤掉所有不属于该指定进程的任务。注：你可以使用 BlazeSym 工具对内核栈追踪信息（kernel stacktraces）进行符号化解析（类似 profile 示例中的做法），但为简化代码，相关实现代码已被省略。 前置知识 BPF 迭代器 seq_file NOTE:《Learning eBPF》 中并没有关于 BPF 迭代器的内容。 运行$ ./task_iterTask Info. Pid: 290. Process Name: systemd. Kernel Stack Len: 5. State: INTERRUPTIBLETask Info. Pid: 291. Process Name: init-systemd(Ub. Kernel Stack Len: 5. State: INTERRUPTIBLETask Info. Pid: 361. Process Name: init. Kernel Stack Len: 8. State: unknownTask Info. Pid: 361. Process Name: init. Kernel Stack Len: 6. State: INTERRUPTIBLE struct task_info#define TASK_COMM_LEN 16#define MAX_STACK_LEN 127struct task_info pid_t pid;\tpid_t tid;\t__u32 state;\tchar comm[TASK_COMM_LEN];\tint kstack_len;\t__u64 kstack[MAX_STACK_LEN];; The BPF sideBPF_MAP_TYPE_PERCPU_ARRAY 📌这是 BPF_MAP_TYPE_ARRAY 映射类型的 per-CPU variant。 这种 per-CPU 版本的 map 会为为每个逻辑 CPU 分配独立的数组。当通过大部分辅助函数(helper function)访问该映射时，会隐式访问当前 eBPF 程序所在 CPU 对应的那个数组。 由于程序执行期间会禁用抢占机制，因此不会有其他程序能并发访问同一块内存。这一特性确保了永远不会出现任何竞态条件，同时也因无需阻塞和同步逻辑而提升了性能，但其代价是会产生较大的内存占用。 struct __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\t__uint(max_entries, 1);\t__type(key, __u32);\t__type(value, struct task_info); task_info_buf SEC(.maps); value 的类型基本不做限制，但 key 必须为 32 位无符号整数。 task_info_buf 仅 1 个元素：用于临时存储单条任务信息（因为 iter 程序遍历每个 task 时，每次只处理一条）。 get_task_state跨 Linux 内核版本（5.14 前后）安全获取 task_struct 的进程状态字段（5.14 内核将 state 重命名为 __state） Linux 5.13: task_struct Linux 5.14: task_struct struct task_struct___post514 unsigned int __state; __attribute__((preserve_access_index));struct task_struct___pre514 long state; __attribute__((preserve_access_index));static __u32 get_task_state(void *arg)\tif (bpf_core_field_exists(struct task_struct___pre514, state)) struct task_struct___pre514 *task = arg; return task-state; else struct task_struct___post514 *task = arg; return task-__state; preserve_access_index__attribute__((preserve_access_index)) 是 BPF CO-RE（Compile Once – Run Everywhere）的必需属性： 告诉 Clang 编译器为结构体字段生成「访问索引」（access index），BPF 加载器会利用这个索引结合内核 BTF 信息，自动适配不同内核版本的内存布局； 若缺少该属性，自定义结构体无法和内核真实 task_struct 做字段映射，会导致 BPF_VERIFIER 校验失败。 相关阅读： 5.7 BPF Relocationshttps://gaoyangu.github.io/wiki/ebpf/learning-ebpf-05/#5-7-BPF-Relocations bpf_core_field_exists 📌用于查询待加载程序的目标内核中是否存在某个结构体字段。 SEC(“itertask”)遍历内核中的任务。 SEC(iter/task)int get_tasks(struct bpf_iter__task *ctx) 可以在 vmlinux.h 中找到 bpf_iter__task 结构体的定义： struct bpf_iter__task union struct bpf_iter_meta *meta;\t;\tunion struct task_struct *task;\t;; seq_file 为上层开发者提供的类似【迭代器】的简易文件读取接口 struct seq_file *seq = ctx-meta-seq;struct task_struct *task = ctx-task;struct task_info *t;long res;if (!task) return 0; bpf_map_lookup_elemt = bpf_map_lookup_elem(task_info_buf, zero);if (!t) return 0;t-pid = task-tgid;t-tid = task-pid;t-state = get_task_state(task); bpf_probe_read_kernel_str 📌bpf_probe_read_kernel_str(t-comm, TASK_COMM_LEN, task-comm); 将以空字符（NUL）结尾的字符串从内核不安全地址 unsafe_ptr复制到目标缓冲区 dst。 bpf_get_task_stack 📌res = bpf_get_task_stack(task, t-kstack, sizeof(__u64) * MAX_STACK_LEN, 0);t-kstack_len = res = 0 ? res : res / sizeof(t-kstack[0]); 在 BPF 程序提供的缓冲区中返回用户栈或内核栈。注：仅当目标任务为当前任务时，才会填充用户栈；其他所有任务都会返回 -EOPNOTSUPP 错误码。 要实现此功能，该辅助函数需要传入 task 参数 —— 这是一个指向 struct task_struct 结构体的有效指针。为存储栈追踪信息，BPF 程序需提供一个大小非负的缓冲区 buf。最后一个参数 flags 用于存放需要跳过的栈帧数量（取值范围为 0 至 255）。 bpf_seq_write 📌bpf_seq_write(seq, t, sizeof(struct task_info)); 将 t 写入 seq 中。 The user-space sideget_task_statestatic const char *get_task_state(__u32 state)\t/* Taken from: * https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L85 * There are a lot more states not covered here but these are common ones. */\tswitch (state) case 0x0000: return RUNNING;\tcase 0x0001: return INTERRUPTIBLE;\tcase 0x0002: return UNINTERRUPTIBLE;\tcase 0x0200: return WAKING;\tcase 0x0400: return NOLOAD;\tcase 0x0402: return IDLE;\tcase 0x0800: return NEW;\tdefault: return unknown; open_and_load/* Open, load, and verify BPF application */skel = task_iter_bpf__open_and_load();if (!skel) fprintf(stderr, Failed to open and load BPF skeleton ); goto cleanup; bpf_iter_attach_opts 📌LIBBPF_OPTS(bpf_iter_attach_opts, opts);union bpf_iter_link_info linfo;pid_t pid_filter = 0;/* Attach BPF iterator program */memset(linfo, 0, sizeof(linfo));linfo.task.pid = pid_filter; /* If the pid is set to zero, no filtering logic is applied */opts.link_info = linfo;opts.link_info_len = sizeof(linfo); bpf_program__attach_iterskel-links.get_tasks = bpf_program__attach_iter(skel-progs.get_tasks, opts);if (!skel-links.get_tasks) err = -errno; fprintf(stderr, Failed to attach BPF skeleton ); goto cleanup;/* Alternatively, if the user doesnt want to provide any option, the following simplified * version can be used: * err = task_iter_bpf__attach(skel); * if (err) *\tfprintf(stderr, Failed to attach BPF skeleton ); *\tgoto cleanup; * */ bpf_iter_createiter_fd = bpf_iter_create(bpf_link__fd(skel-links.get_tasks));if (iter_fd 0) err = -1; fprintf(stderr, Failed to create iter ); goto cleanup; whilewhile (true) ret = read(iter_fd, buf, sizeof(struct task_info)); if (ret 0) if (errno == EAGAIN) continue; err = -errno; break; if (ret == 0) break; if (buf.kstack_len = 0) printf(Error getting kernel stack for task. Task Info. Pid: %d. Process Name: %s. Kernel Stack Error: %d. State: %s , buf.pid, buf.comm, buf.kstack_len, get_task_state(buf.state)); else printf(Task Info. Pid: %d. Process Name: %s. Kernel Stack Len: %d. State: %s , buf.pid, buf.comm, buf.kstack_len, get_task_state(buf.state)); cleanupcleanup:\t/* Clean up */\tclose(iter_fd);\ttask_iter_bpf__destroy(skel);"},{"title":"lsm (todo)","path":"/wiki/ebpf/libbpf-bootstrap-15.html","content":"lsm 是一个演示如何使用 LSM BPF 的示例程序。在该示例中，bpf() 系统调用会被有效拦截。当 lsm 程序成功运行后，你可以通过 bpftool prog list 命令来验证其是否已正常生效。 前置知识9.3 BPF LSMhttps://gaoyangu.github.io/wiki/ebpf/learning-ebpf-09/#9-3-BPF-LSM 运行运行之前，需要先检查当前运行的内核是否编译支持 BPF LSM： 检查是否支持 BPF LSMhttps://www.meemx.com/p/ebpf-libbpf-lsm/#运行ebpf程序 The BPF sideThe user-space side"},{"title":"some file about ebpf","path":"/wiki/ebpf/linux-ebpf-file.html","content":"eBPF 指令编码https://github.com/iovisor/bpf-docs/blob/master/eBPF.md bpf_helpers.hhttps://elixir.bootlin.com/linux/v5.19.17/source/tools/lib/bpf/bpf_helpers.h 查看 bpf_prink 的输出信息cat /sys/kernel/debug/tracing/trace_pipe 查看内核的所有符号信息（包含函数名）cat /proc/kallsyms 查看内核上可用的跟踪子系统集cat /sys/kernel/tracing/available_events 查看跟踪点描述从中跟踪的字段cat /sys/kernel/tracing/events/syscalls/sys_enter_execve/format"},{"title":"c语言内存分区","path":"/wiki/ebpf/sections.html","content":"内存分区(高地址)栈区堆区未初始化(或初始值为0)的全局变量和静态变量 (.bss)初始化的全局变量和静态变量 (.data)常量区 (.rodata)代码区(低地址) bss: block started by symbol rodata: read-only data 代码sum.c$ cat sum.c int sum(int a, int b) static int val_1; static int val_2 = 0; static int val_3 = 1; static int val_4 = 0; static int val_5 = 2; const static int val_6 = 0; return a + b; 生成可重定位目标文件 sum.o$ g++ -c sum.cpp -o sum.o 查看 sum.o 的段头表$ readelf -S sum.o There are 13 section headers, starting at offset 0x2a0:Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000018 0000000000000000 AX 0 0 1 [ 2] .data PROGBITS 0000000000000000 00000058 0000000000000008 0000000000000000 WA 0 0 4 [ 3] .bss NOBITS 0000000000000000 00000060 000000000000000c 0000000000000000 WA 0 0 4 [ 4] .rodata PROGBITS 0000000000000000 00000060 0000000000000004 0000000000000000 A 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000064 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 00000090 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.pr[...] NOTE 0000000000000000 00000090 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000b0 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000218 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 000000e8 00000000000000f0 0000000000000018 11 9 8 [11] .strtab STRTAB 0000000000000000 000001d8 000000000000003b 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 00000230 000000000000006f 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) .data 大小为 8 字节 在目标文件中占用 8 字节 (00000058 - 00000060) val_3, val_5 .bss 大小为 12 字节 在目标文件中占用 0 字节 (00000060 - 00000060) val_1, val_2, val_4 .rodata 大小为 4 字节 在目标文件中占用 4 字节 (00000060 - 00000064) val_6"},{"title":"内蒙古","path":"/wiki/gallery/gallery.html","content":""},{"title":"gdb","path":"/wiki/linux_tool/gdb.html","content":"启动调试正在运行的进程$ gdb attach 进程ID SIGPIPE 调试过程可能会因为 SIGPIPE 停止，可使用如下命令解决： (gdb) handle SIGPIPE nostop noprint pass 结束调试 且不对当前进程有任何影响 (gdb) detach(gdb) quit 流程控制break 在函数的开头设置断点 (gdb) break func_name 在文件 main.c 的第 10 行设置断点 (gdb) break main.c:10 当变量 counter 的值为 100 时设置断点 (gdb) break main.c:10 if counter == 100 tbreak 设置临时断点（该断点触发一次后，就会自动被删除） (gdb) tbreak func_name run 如果是通过 gdb 可执行文件 的方式，可使用如下命令让程序运行起来： (gdb) run 或者: (gdb) r continue 运行到下一个断点 (gdb) continue 或者： (gdb) c step 执行当前行，并进入函数调用 (gdb) step 或者： (gdb) s next 执行当前行，不进入函数调用 (gdb) next 或者： (gdb) n until 👍 让程序运行到 2774 行 (gdb) until 2774 finish 👍 直接执行完当前函数，并回到上一层的调用处 (gdb) finish 查看print查看变量 i 是变量名 (gdb) print i 修改长度限制 👍字符串变量的长度可能会超过默认长度，如何查看完整的字符串？ 查看长度限制 (gdb) show print elementsLimit on string chars or array elements to print is 200. 将长度限制改为 1000 (gdb) set print elements 1000 或者改为无限制 (gdb) set print elements 0 info查看当前函数的参数(gdb) info args 查看寄存器(gdb) info registers 查看所有线程(gdb) info threads 修改修改变量的值 将 flag 的值修改为 1 (gdb) set variable flag = 1 多线程获取所有线程的堆栈信息(gdb) thread apply all bt"},{"title":"git","path":"/wiki/linux_tool/git.html","content":"123"},{"title":"linux","path":"/wiki/linux_tool/linux.html","content":"查看用户 ID$ iduid=0(root) gid=0(root) groups=0(root) $ echo $UID"},{"title":"sqlite","path":"/wiki/linux_tool/sqlite.html","content":"进入交互模式sqlite3 event.db 查看所有表.tables select name from sqlite_master where type=table; 查看表结构.schema event_statistic 查看表数据select * from event_statistic limit 10; 退出交互模式.exit"},{"title":"strace","path":"/wiki/linux_tool/strace.html","content":"123"},{"title":"光猫","path":"/wiki/wlan/cmcc.html","content":"如何获取联通光猫管理员密码 在地址栏 192.168.1.1 后面加上 /backupsettings.conf 把这个文件用记事本打开，找到 Adminpassword 一行后面的就是了"},{"title":"介绍","path":"/wiki/wlan/index.html","content":"131fd7c5506bb654a6cea69bbe40f3df7da318ecb0403b621d8f115b1f8d302bf6a9a4d5270b84db0e87e59dfe247981efcd8281284099f469b4b4e8f634e868e4671607d4a31592aeff9d649d1e0407bd7e1bc1cbf54d87af3576a02bf8498f2fdbb69f3bef66d718f02ef934c3851bd23c8b140d894efd71c93d3642f3d411603562ce7eae6717ce330a06cf6eef7c9fa36333050b55caf8efd91b39b2131d1ca0948aed75e43787b7163c54d62c027a420ed131665238b87de39ae2d8e7ea6de41a1dce92224b92bf589d1873a158e5371aa4880c0094095609838fe2e76e080c6da16ab74a1c3fb0a14928da5d400cae7a12bcbac5d2c250f791b0d46a905a1381a271cb7eadb98ee1a4ba97835872b4e4626f7f80e727fb3d49ac05760febd85438206bdaa6a09be2f192edce456b782bf63d57da24f8155c5a791e52bd98185580ce691b8734808d92a88dbe0fbd732db0e73c764cae2beb80797ca8b8549a8c76a648b2b16c6aa5137e5ffedbff4ee147d5370a5810ccadb61942ad69cdb241911353fd464bdeda402d9e2404ea735852a7ab9e75f56ba829952669402b15f9ec52fd0bdf7d7f3d42d9bb0534a4f92300fa7ee6df8ec6d9ce9824609e3ff230f3c258ff46f17db7c311c9c10da218083eb5c2e403ca9f838a3f6f12f33df838fe76844e1779e468c512c7ce776b1aa612d330eb79054415608982b02000de020ab1ea2c02648772eb593f4624491a5b891cd162e4d443b97876b9546a7d021109b2f3cfcdd5630fd22a942f99cbd3157ab67a087702322dbead0a1a138b435b2f9d042589146bc194902d9c3537ae34d1e31833f91942f651422588db2159b26ab4d559d936f5f1721af6734d4af09768a65b16c6dbde939c2ad0a1e11c468544ca73bf243cecefb148dbe95b67b1468d80cb31b761291734bc708a3ac7ae9753f5a43d91766afbb254e7a389db40c0a71d272b1471ecf95ab18a890f2ca583102cd106b2a05b54a35b70e1934423975409558894b6a5ddf15164d9ad5c2d67134f1020617df33294d76d15bac449b71ed633afbf4f593655f4df7c913309c76c2cad2aee207071e1f0aecb1cbdb712ff5e87049ffbe1027f1af47000a65a71ab1522e2b93164e02d7a774d54294b9d018945bb633bf0114e375758dd0ec034faa896a8b3a715dbec5c5c8168daff0fefc37a516803e2c1354d26123d0fcb94d23a4cb2dd459d1532d89216f9fe744434257971cd4be4dc3013e22b0cafee42b89aa3a52af0c8518701048962258e1375d2e40e07c75b3d7a21f2c51bee8749659ebdc0b694c5fccd75cf860964b83be091c5e020e6a2ce3f5605890c84a5d717d22ce483b18fe614cc2933b455d495c62843ef750b96c066456d8dcd421a90ee61e3994d32df1c8cd2774877dea24302089cf59f1e0987f4c7e76d116e0b5897c6086c71bbc87020f5c7efeec606db70012ac0b2362d8c32223eb8257e03abe7948e9e5ef3cb1969ba05dcd5d20af794bee131bfd0a41228fe3e6e5559d3b6e82a5d9a220910f7a8cab8089739e36933e285fa9c11c288a19a2dae2b8e51e9416c273d23d8761e2a8c9b21d945db73b8b7d483056f8ffe19cfb02becb4ed3d02da0edf91f74aed61fedb53c884924d501e17f0850b314ac207a148de8786d9909e069ecf0ef493af008ad9f44bf52356e838d561e3f6800a55484ac8d75ea84320f27d05e85a31c910f46e78e2f8ff099dbc93fb11808bc40b60e5cce87f1c51d9c404f79b33df7ddc4102a5b2365ba7b63f7a8d7f906b1a3040baddb5e858d3a9516737a32fedb89a38a7f55c9aebf6b1d975f063f4f9a0abf6014bd7741ed25df7724b6c8443c0d8f078b9959f94679c597cb1f32b1f26d7b8a1b728d614b89fabec5d47d400e2c098bb4904449e69261a62660d365ff35e49c7051a9cd85dc4022ad9eb44a3a795a2d007462b1d0f4e022691bd962106536039145c7d8826acfd432d057e99269f31ae805103d24c25cb6e244b151d070ecb5bcc75130ef7513bcb1d3eccfdcfc7720641120dbb3d2d9e30bb3cd2cc34e1d69dd0e5197c02774eb887dce80799de00465f0c230b9901908f20d399adc2ef6387f72d55a2f26f3f17add585d64da9967ce58a2ee6b8f6c39e7737686e7de74c4747daea0576d18d34feb2b423700764ec2dc56a8b1d3dc26dbd10ca477257077bedbd5f4c01a507c1ce7fa3c08efbfec1a7dd56794cfbad6457dcc7e3507238920beb3856e6916f2a52f525b0a277cfcbb24dc77827c35be75bbd87e6047d563d6eac2f271b6329783a024d1a7efd49580ff58df3531df32b6e66d4caa20bbba3fdd489f9df7b8ad76df863e510e293b0b92dfdfd637eb82b287114935630f018d11dedd806d0d3a88cfbbf112cfe4f64fe58d02fd38a14893bcbf57c57648c67d21167c1f5cfefaedf6e19a059340b53e966cd58fdf1ebd06d05998fa64f05d3410de89f4d6a137cded66dbc5cbb176958a7005141efa5ba41194a6ff74244d12e6c1d6f07008c08bb44f04db7cabc9ad811758f40a319205a90eba1f9991f0a12d5e1c37fdfc3a7742a97fa2266c1e5c569c451c05b3fed136e0fdbbfeea9bcb5e7a7aefdea7abe179f6f0069646f9893e7bd1f814a1d01f185a58257171fdd44 Hey, password is required here."},{"title":"路由器","path":"/wiki/wlan/router.html","content":"123"}]