[{"title":"VLAN","path":"/2025/11/19/0017-vlan/","content":"VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的 LAN 在逻辑上划分成多个广播域的通信技术。 VLAN 技术可以把一个物理局域网划分成多个逻辑局域网，即多个 VLAN。每个 VLAN 是一个广播域，使得 VLAN 内的主机可以互通，而 VLAN 间不能直接互通。这样，广播报文被限制在一个 VLAN 内，同时提高了网络安全性。 VLAN 标签当一个局域网被划分为多个 VLAN 时，每个 VLAN 都用一个唯一的 VLAN 标签来标识。VLAN 标签也称为 VLAN Tag 或 802.1Q Tag。 IEEE 802.1Q 标准对传统 Ethernet 帧格式进行了修改，在源MAC地址字段和协议类型字段之间加入 4 字节的 802.1Q Tag，形成了 VLAN 的帧格式。 TPID：Tag Protocol Identifier，用来判断本 VLAN 帧是否带有 802.1Q Tag，缺省取值为 0x8100，表示 802.1Q Tag 帧。 PRI：Priority，表示帧的优先级，取值范围为0-7，值越大优先级越高。用于当设备阻塞时，优先发送优先级高的数据帧。 CFI：Canonical Format Indicator，表示MAC地址是否是标准格式，取值范围为0或1，缺省取值为0。取值为0表示MAC地址以标准格式封装，取值为1表示MAC地址以非标准格式封装。 VID：VLAN ID，表示该帧所属的VLAN，取值范围为 0-4095。由于 0 和 4095 为协议保留取值，所以VLAN ID的有效取值范围为 1-4094。 数据帧分类数据帧根据是否携带 VLAN Tag，分为以下两种形式： Tagged 帧 有标记帧 加入了 4 字节 802.1Q Tag 的帧 Untagged 帧 无标记帧 原始的、未加入 4 字节 802.1Q Tag 的帧 链路类型VLAN 组网中的链路包括： Access Link 接入链路 连接不能或不需要识别 VLAN Tag 的终端设备 Trunk Link 干道链路 其上通过的数据帧都必须打上 VLAN Tag 接口类型根据对 VLAN 帧的识别情况，将接口分为以下几类： Access 接口 用来连接终端设备的接口，这些终端设备不能或者不需要识别 VLAN Tag 如果该接口收到 Untagged 帧，设备将强制加上该接口的 PVID（缺省VLAN） 如果该接口收到 Tagged 帧，只允许 VLAN ID 与接口的 PVID（缺省VLAN）相同的 VLAN 帧通过 Access 接口发送的数据帧永远是 Untagged 帧 Trunk 接口 允许多个 VLAN 的 Tagged 帧通过 该接口发送的帧，VLAN ID PVID 的是 Untagged 帧，其它 VLAN 的帧都必须是 Tagged 帧 Hybrid 接口 允许多个VLAN 的 Tagged 帧通过 在出接口方向可根据需要设置某些 VLAN 内的帧带 Tag，某些 VLAN 内的帧不带 Tag QinQ 接口 给数据帧加上双重 VLAN Tag 缺省 VLANPVID (Port Default VLAN ID) Access接口只属于1个VLAN，它的缺省VLAN就是它所在的VLAN。 Hybrid 接口和 Trunk 接口属于多个 VLAN，但是缺省VLAN只有1个，所以需要设置缺省VLAN。 同一 VLAN 内的互通同设备 VLAN 内互通用户主机 Host1 和 Host2 连接在同台设备上，属于同一VLAN2，且位于相同网段，连接接口均设置为Access接口。 跨设备 VLAN 内互通用户主机Host1和Host2连接在不同的设备上，属于同一个VLAN2，且位于相同网段。为了识别和发送跨越设备的数据帧，设备与设备间通过 Trunk link 连接，且允许携带 VLAN2 的报文通过。 不同 VLAN 间的互通同设备VLAN间互通（VLANIF接口）用户主机Host1和Host2连接在同台设备上，分别属于VLAN2和VLAN3，并位于不同的网段。在DeviceA上分别创建VLANIF2和VLANIF3并配置其IP地址，然后将用户主机的缺省网关设置为所属VLAN对应VLANIF接口的IP地址。 跨设备VLAN间互通（VLANIF接口）由于VLANIF接口的IP地址只能在设备上生成直连路由，当不同VLAN的用户跨多台设备互访时，除配置VLANIF接口的IP地址外，还需要配置静态路由或运行动态路由协议。 用户主机Host1和Host2连接在不同的设备上，分别属于VLAN2和VLAN3，并位于不同的网段。 主机与设备之间使用Access接口，设备之间使用Trunk接口。 在DeviceA上分别创建VLANIF2和VLANIF4，配置其IP地址为10.1.1.1和10.1.4.1；在DeviceB上分别创建VLANIF3和VLANIF4，配置其IP地址为10.1.2.1和10.1.4.2 在DeviceA和DeviceB上分别配置静态路由。DeviceA上静态路由的目的网段是10.1.2.024，下一跳是10.1.4.2；DeviceB上静态路由的目的网段是10.1.1.024，下一跳是10.1.4.1。 同设备VLAN间互通（三层子接口）用户主机属于不同的VLAN，并位于不同的网段。 其中，Host1和Host2属于VLAN2，Host3和Host4属于VLAN3，DeviceA通过以太网接口interface1与DeviceB相连。 在DeviceA的interface1上创建2个子接口interface1.1和interface1.2，并配置802.1Q封装与VLAN2和VLAN3分别对应。 配置子接口的IP地址，保证两个子接口对应的IP地址路由可达，并将用户设备的缺省网关设置为所属VLAN对应子接口的IP地址。","tags":["计算机网络"],"categories":["Linux"]},{"title":"时间轮","path":"/2025/11/13/0016-time-wheel/","content":"为什么使用时间轮基于链表排序的定时器使用唯一的一条链表来管理所有定时器，插入操作的效率随着定时器数目的增多而降低。 时间轮使用哈希表的思想，将定时器散列到不同的链表上，这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响。 时间轮的原理时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot 槽位。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用链表结构保存该时间段到期的所有任务。时间指针随着时间增加逐个slot 转动，并执行 slot 中的所有到期任务。 任务如何加入根据任务的到期时间进行取模，将任务分布到不同的 slot 中。如图所示，时间轮被划分为 8 个 slot，每个 slot 代表 1s，当前时针指向 2。 假如现在需要调度一个 3s 后执行的任务，应该加入 2+35 的 slot 中；如果需要调度一个 12s 以后的任务，需要等待时针完整走完一圈 round 后再走 4 个 slot，需要放入第 (2+12)%86 个 slot。 当时针走到第 6 个 slot 时，怎么区分每个任务是立即执行，还是需要等待下一圈，甚至更久时间之后执行呢？因此需要把 round 信息保存在任务中。 例如图中第 6 个 slot 的链表中包含 3 个任务，第一个任务 round0，需要立即执行；第二个任务 round1，需要等待 1*8=8s 后执行；第三个任务 round2，需要等待 2*8=8s 后执行。所以当时针转动到对应 slot 时，只执行 round0 的任务，slot 中其余任务的 round 应当减 1，等待下一个圈之后执行。 定时器类class tw_timer public: tw_timer(int rot, int ts) : rotation(rot), time_slot(ts), next(nullptr), prev(nullptr) private: int rotation; /* 记录定时器在时间轮转多少 round 后生效 */ int time_slot; /* 记录定时器属于时间轮上哪个 slot*/ void* user_data = nullptr; /* 客户数据 */ void (*cb_func)(void* ); /* 定时器回调函数 */ tw_timer* next; /* 指向下一个定时器 */ tw_timer* prev; /* 指向前一个定时器 */; 多级时间轮todo","tags":["时间"],"categories":["编程"]},{"title":"iptables 和 netfilter","path":"/2025/11/11/0015-netfilter/","content":"iptables 和 netfilter 是一套 Linux 防火墙组合工具，共同合作完成系统的防护工作。 iptables 是客户端工具，netfilter 是服务端程序， iptables 工作在用户态，netfilter 工作在内核态， 用户可以通过 iptables 命令作用到服务端的 netfilter，netfilter 触发相应的回调函数（hook 机制）执行相应的防护动作。 五链netfilter 是 Linux 内核中内置的网络数据包处理框架，提供了 5 个 hook 点，当网络包在协议栈中流转到这些 hook 点时，就会依次执行在这些hook 点上注册的各种规则，进而实现对网络包的各种处理。 PRE_ROUTING 通过数据链路层解包，进入网络层的数据包通过该 hook 点 所有接收数据包到达的第一个 hook 点 此处可以进行数据包目的地址转换（DNAT） LOCAL_IN 经过路由查找后，目的地址是本机的数据包，会到达该 hook 点 IP_FORWARD 进过路由查找后，目的地址不是本机地址的数据包（即转发的数据包），会到达该 hook 点 LOCAL_OUT 所有本地生成的发往其它机器的数据包，在进入网络栈后首先到达该 hook 点 POST_ROUTING 本机产生准备发出的数据包或转发的数据包，在经过路由判断后，会到达该 hook 点 四表每个 hook 点可以注册各种规则，这些规则根据用途的不同，可以分为 4 个表，分别是 raw 表，mangle 表，nat 表和 filter 表。 每个链中的表，按照下面的优先顺序进行查找匹配： raw mangle nat filter raw 表 用于决定数据包是否被连接跟踪机制处理 mangle 表 用于数据包的拆解、修改、再封装 修改包的 IP 头 nat 表 数据包的网络地址转换 filter 表 用于数据包过滤，判断是否允许一个包通过","tags":["计算机网络"],"categories":["Linux"]},{"title":"每天最重要的2小时 - 05","path":"/2025/11/05/0009-two-awesome-hours-05/","content":"对工作环境做出理性的选择，选择那些能够让我们更加专注、更加深入思考的环境。 声音对工作效果的影响一些基本的建议，能够让你在关键时刻保持专注： 一个独立的、远离噪声干扰的环境能够大大提高工作成效 如果无法离开办公环境，那就戴上降噪耳塞吧 不要听音乐或脱口秀节目 如果在家办公，就把电视关上 如果要完成的这项任务需要发挥创造力，那就不要抗拒背景噪声，可以考虑去一家忙碌的餐厅或者咖啡馆，要么放点音乐也不错 早早起床，先在家工作一两个小时，然后下午早点下班，来弥补早上在家的工作时间。 光线对工作效果的影响蓝色光和明亮的白光似乎都能增强大脑的一些功能，并帮助我们更有效地工作。 在需要有良好表现的时候，可以做一下这些事： 多开灯。 在天气晴朗时找一处有充足自然光的地方，然后在那里工作。 把灯泡换成偏蓝光的。 如果需要完成一项需要创造力的工作，把灯调暗一点，或者找个比较昏暗的角落。 可以通过以下方法对自己的办公空间做出改变： 清理杂乱无章的东西。在心理能量不足以做某些难度较高的工作时，就可以清理它们，比如下午或傍晚。 把电话、水杯或其他工作相关的物品放到桌子的四个角上。 不要在桌子边坐太久。 摆放点植物或者水景画。 想象自己正坐在桌子前一张舒服的椅子上，有足够的空间能让你把椅子往后推，把脚跷起来。做这种扩张性、开放性的姿势，并且保持两分钟，就能够提高睾丸酮水平，并较低皮质醇激素水平，这会让人们更乐意冒险。 把物品放在伸手才能够得着的地方。 在跑步机上走路或出门散个步，能够提高人们的创造力。 结论：与你周围的环境协同工作反思考研期间一直不习惯晚上熬夜，听到某个考研老师说可以不熬夜，然后早上四五点钟起床。不过现在对我来说早起似乎也有些困难。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"每天最重要的2小时 - 04","path":"/2025/11/04/0009-two-awesome-hours-04/","content":"当希望在提前安排的任务中或者某些特殊时刻达到自己最好的精神状态，利用身体活动和食物的即时反应来增强你的心理功能。 我们的身体状况可以影响到精神状况，改变你身体的感受，就有可能改变你的心理状态。 运动对精神状态的影响身体上的运动也会在短期内对你的心理表现产生作用。 运动半小时左右可以即刻且连续地提升执行功能。能够让你地注意力更加敏锐，让你更专注，让你的血糖值稳定下来，降低焦虑水平，增强积极的情绪和感受。 不论现在有没有坚持有规律地锻炼，都可以在需要的时候利用运动来提升自己的思考能力和心理能量。 一些非常有用的运动： 如果没法集中精神，就走出办公室，快速行走 30~40 分钟，上下楼梯 20~30 分钟。 把有挑战性或者会让你焦虑的会面安排到一段适中的锻炼之后。 当日程表上有项极具挑战性或者令人疲累的工作时，要么在那之前进行一场早锻炼，要么就在完成任务后立刻运动一下。 需要制造“高效两小时”的时候，就在之前的一两个小时内运动 20~40 分钟. 饮食对精神状态的影响升糖指数低的早餐更能帮助孩子们提升执行功能，而提升效果最明显的时段出现在早餐后的两个小时内。 即使是那些健康的年轻人，只要体内2%的水分流失，就会对注意力和短期记忆力造成损伤。 小贴士： 只吃半份早餐或午餐，把剩下的一半留到两个小时之后再吃。 一份富含碳水化合物的零食也许能帮助你在15分钟内集中注意力，并且让你感觉良好。 吃一些含有蛋白质、含糖指数低的碳水化合物和健康脂肪的饭菜、零食。 当你非常忙的时候，坚果是零食的最佳选择。 不要傻乎乎地大吃一顿全是由碳水化合物组成的饭。 如果在过去一两个小时内没有喝水，或者刚刚做过运动，那就赶紧喝水。 如果很疲惫或者睡眠不足，那就喝点含咖啡因的饮料，但不要喝太多。 结论：主宰自己的感受我们可以根据自己希望大脑在饮食或运动后如何运转，来决定自己要吃什么或何时运动。 反思最近总是在晚上运动完之后，就立即开始整理读书笔记。 运动后及时补水。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"每天最重要的2小时 - 03","path":"/2025/11/03/0009-two-awesome-hours-03/","content":"我们需要让自己的思绪乱飞。 大脑天生无法长时间保持专注从进化的角度来讲，如果不做到这样，我们人类就很难生存下来。 把那些没必要存在的和会让你分心的东西都拿开。 拿开办公地点的干扰物如果想要最大限度地专注于某件事， 尽量降低噪声，尽可能地关掉各种设备。 把你的设备都收起来，或者至少放在隔着几米远的地方。 没必要当个从人群中消失的隐士，只要找个办法，也许只要能让这些设备在20分钟内不会令你分心就可以。 冥想练习能够让大脑更有效地保持注意力。 走神的重要性走神对于认知性任务（创造性地解决问题和做出长远计划）有很重要的作用。 如果想要解决一些特别难的问题，不妨让你的思绪飘飞一会儿，琢磨一些难度不高又不相干的简单工作，这能帮助你找到更具有创造性的解决之道。 在专注于某个问题一段时间之后，转换到另一个从认知角度上讲难度适中的任务 – 但不能选择某个需要利用到工作记忆的任务 – 然后再转回到最初想要解决的任务。 比如： 欣赏墙上的画、房间里的植物、窗外的风景，或是你桌上的照片，注意各种颜色的深浅 整理桌面和书架，把桌子擦干净 听音乐，注意聆听这首曲子里用到了那些乐器 玩个小游戏，比如只要看到有人一边走一边发短信，就在纸上画一笔 不建议在走神时做以下事项： 整理文件 看新闻或博客 查阅和回复邮箱 排练你要演示的PPT，或者为某个会议做准备 研究一个高难度问题，比如填字游戏或者数学难题 “觉察注意力”，放任自己走神，在觉察到我们的思绪飘走了之后，再温和地把它们带回我们再眼下所进行的事情上来。 不要理会那些不能帮助你继续完成任务地想法，就像冲浪者们放弃不够合适的海浪一样。 大脑会产生各种想法，你并不需要对每个想法都做出反应。 结论：给自己一个喘气的机会反思工作时把手机放在视线外的地方。 尝试冥想练习。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"Linux 系统中常用的时间操作函数","path":"/2025/11/03/0014-time/","content":"ef77cdfd35a516030a30622d6798f966922f09fa54d377420ff3f0fc2944db5b883f34d1acc43189aad7e189bb52aa7f01f63e95133dfdb4a8517b8c8eed389ecbcc216614bf14afa2364a29099391971d3f3332d2eafe6cf0680bd7b20512ca17993dc180ec3ab0a4016db97acc4938d032726d128e25795ec607fec28a3354e1151f9a576d06bb1bea4e18df27253b711d47ea1c5e56894d52f6e9e23e417e3c7726d6bd9b3e1bef4084155c84006b5e1fbdd15584af5f991c58786d9893cd42ffe10bab0d350c6da9e8f095901620bc5b3bc65c0c35ba05eec27cfbb250ef274e716646021aedf44af33ca4561da947e6b730e3644c0f0629da552c4b460de3c28edbd6c62a6d280d413cdae9aaecdac783a65797b4c04582f4d8c96294965ebc8e42363854d4a4529037d9bafdcf5e1bcc06d404dd7c15b4474580af3f70e87ac1c593b5c08adb657f8989487e28ecda0331a402d166814102fe4c117d8cc12b2bd8769917db9916e52372eac3b49f33e086cf9abf1e1dde5c535425268a39b748cfe175fce6723cc692b830c43da307482b0ca202eb12f99193e1d1e4778232567260b72dabbce06a62c3c8f3eb266e1a41b25634d1c4e2e7e463d0398dea5fa12234c67f8ed8044616ad54fd923fb26467eeb8993de927e736e664639b82f9c836945c6ebfd0c5c1846ba36d57ddfe079d876ea6fd58799e8be728f966bb5dda97090a36b3a46ee43be1d09bac6bcb934118204142e0023492af15dfc12ca0abfd95d1318214cef542106175645eb63c0ab6e439569e58bfa5936dc5577b8fa052474331a212b8d4405a0665f8ac65894dbdd0e6400f7945a5d41383fa58d5cbd04ce173ee080d5b05542e8d4dd84cccaaa3e790c07534fc5fee5be5f480ac4f7ef2a11976ab6ef3d192f9f23078bf78038867b90b4417f3741ca0e7b74648df5030210293f4fd2f190bd85e9b521ad88db01c4ef4d2c92c2d46465678b3ddb207571da7fa51d7426ae96f800fa2cd3afaaca0e2e1d356b2245d91e2770e1c1dd88f856c41496f5a2100c5651e4efd52ce3b2a82f41eeba106ec52a917e1c0ade33a53109e3c253d56a034f3d85117482773dec2ea33bd002005d8d2e5484f6af95dec4fa7e26437ae0b61622dfd528ce3e2d1cce170db30ef1eb821438d481d7cbb55eab4a3bd98d007f986ff7a7de304b72853a7184f232abdebbf1d2e3e40bc1073f79a512442e7281f4a55c634f45d65b6a00579029459794318ed536c1ddc461d0ed85f096bc45dde5ee290f0b7cf733340b6f11143472a8eb4b883badd64363fef69e8d6d48d893de27e9bfca981036d07429d152deb3cefacf5a74a16a36a3bfed860583146168c2e4abfdf7944b82898f3ea5b5517687c812b89a481808f92f05697ce3b06b9780758b7d195ee7cc54a0edeec6024ebdd6b805ce38b340d6267aab3a63e82f996ccb943030dc822a8437c38e834f51950d74625265d1d69e60af423762e9d9adbd8d764b149da9890d61be7d39843d6339622e455c17fc88ee1844e586883d99c4775806b277f4b04f824301898f6cb2228025f7d55efbae07a4665f0f9d4033d38c28cb8e3e365cb1bffe92563049fc79eeb913b7ceb481689e664bdcc5de26c18704ee342c31d60b4c58f824d585e2a26f7bad7ff5fc76732e90a0862688130c26c58a4724cb65790142cc1b5392f5d3f63938c179565797fae36e8651660b1c38e007414735b3d509c9f8ae1ca069b4d199c2e66586283aa8bc2a375309a5fed67d17691c0e4f76997b3d2919129b546a188de468c7186f2132f458b19d4b9ad97a2844f33a7de147e33aa6cbf678f7610107fa2d5dcbc16516da19a9dd42132842895ab67c6628f8ec72064e3c34a88b4f5efaad327c5657ad2f42e5f0f106dd5728d9542b6be992c59628c08b75f16e33bdebd7160bcd9d47a1bbebe2684fa71d94b578bd9bfbee68639180fe0fdb682b68442470d6e978d43a09ab025f3d620dfc3c461559fdb21366a6d48302bc09b32779823cf5cde9edfcb2a2ce2d04217d83559dcbe226e0e1ecfc5e5d98bcc0de4c8c57d08e1aa161a0c968bf32f9b12bcc4d44ae4f2fdf27ef17519522bb81bd1e84cce07fd35d5ab5555bcdf5db8bb0d12430e091bab1e082f31cb091728aa556d59758b222a1d7293a27c6b8a8f0826d85460eef4e72a56480759a1d7e71ae5c5e073df8c64ef2d15a0f0954e6bf503c6ec47aa345e076ff1d8a7b5e8c9b536e79040eb83affc27fb80ce3e72184477a01ec42ed7bbf6b86dd23f4ad5946a62a39a62dbe78226487fbfd8faf5976f43abc013dc356ae724a9b1887f0295ff3e2b4ef491ef912776e0857ee73fbb8436e856c49fba59bfd2470032ca08001ec6a4fa9b6f8adfee825537cd51b3be57e26f7b45debdfcd89ffb7f7c294e6c326242b29102cbf65914da19a653847e3474689d21150a09043e61cc9ff1b849559b5ec51f0d4c53705a0ec49724dde5c7485f969327fb4593a31b5f1f39fc20ece38b3f393cae1acc87a29ddff8c8ce0f14fd943a9cf4e727bfc5cfdfe3196ebce955db091bf1f61748c20dd07372c90d768764af25fc4dcd341dfb520564b46d38566b92c5e991303397493ca1304d55acd7945334155398e0142d74d3e89d02e1420db9cd3bdb46303d298221cc758d408afb1ae8ff78f10e7dccac72de7a8366f2a30dbbadbc01163b35aa0f1725b0ec5724ef2d3940af5cf092eab0f47bf71cb9b0f81d93a66186f04078f5d1e0149ab9dee1904fe7b14d5b521ee9a27ebd8752888fe967cad8123d82fc44e7c1626542bfee351eb89c717784e71ef0322255be2a8de4307af0a299cb7d0ec7d5e09b9afb948e2f5b95402a3faa821fb79fdf89662a7e1201cfa3c3c26399878eda6132e765990cae9fa9a5d019135d678a549bc3be3a8fb217cd92d32f517767bbe976cfd5abbbca560ef77c7deba57d357ca291f8400dd2f056f59ca6c27ca655b654d133bcb3324551594feac06663e7e6226d2cecb9309fb241df2763622a9399a00d8ab334d83dc8b175b6627ad5919c30841881d8bfd97737b3348fdfe9257e4d056eba1334f5ef94b97f94c04f553819837b7e5ca5fb37690c45851685c6a93153fb50b20c37addbe0678d777c242af49e1e27ec931e957f8f4917f966c992212b08ad9845e50f38e80b7b2e807d07192f89a941b15ae96a40b1744a7c2e41bde9c48fcbbd4e1426ed07b7de90ff042e5a69e4f67ae34a38c50745ee2c0aed61372ea6edf355fdc40d8a3b188839fdcd0233fc788b18c737225ced709defa6793c8b26631e1a8232b1459681c8dc1cb7c66500151a6675a4fbeabcc410a4cb198f93341047100b36d090abd4eb04139a0b0ccc441569430a62a194869905cd55dabe5f9e7cac96c4d8842a2d09f230222efdf46d9d987dbc55fd43fd4ffaaba0460b78c407282917c38fdb73022e7a99adebe091da8b11fc527926180bb81baa2a00abbb651cb2a7507e1533d082f1f509ef93c86b196756b8862a99c10924df720983fe4ffe5b2674c053d6a3e4d834c9c5530431d08f20c85df2b05d21907629d0a5c051d6289988d0383b91969ff2ab17120fe25f3703df54cf2cd580aa00fb0461f6131bbedd1dc1952ba9e7739a993a82769c097e837ba68ce5e00818a7a8913211c105e757beefd58ee1bfb6e8599c57ab9817e38f8eb72ae82d811a4813693d8bf6168530ddebd8c2c6771a4d862fd86f7764f8081709f74ab76ff91e0ec66b96b7d0916bdc825e577a8c1ffc19db0d24c5e07c6a9971d2137bed9b2fd2ff3ef460fe3d7d787d21b804ee42112e4b0e3c62e89ff7ff67e831ed6d59b1fc17546c68f807c765fb30ba2dae41d7f7e7e464851524a7753d67617ffeb229cbde5da2f607581c607970850ec56726eedde02782b8583bb2f7a0631066389330fa09d8965778b09194d3bdf91ec27490ad567fdd4487a277d71a5776f807823856fde4ac641333e239951598751bb63c0ee93693ad4a34bf1b90d18226da35dfc50f01d5c5efddac0224fefe3053ff1a0d8a5bcc455bb34a8d47fe80a9de70163d7d78316e53899461f8aa6d981526acaed97e8482cc865136586e07f0a713c1d8d6733b90ab0ba19bf0cedfb07334889ce14ea9ad68d16c5ca8ab193caa33c9a8c752d6ea89d763bc652b5c896ed6bcd7e5d56ce070d9f8a49a6a38db53b762eba15fd69bc812d7bc0f1246dfa2d9300b26b3b70dd5adcacfc1a00dff01b4b973ef3c4a5d373b18b78a3badaf6e51c565f1150142cb9f49401c5906953e082bad3789a21a943c7eb0b50350c405849bb3a2e289f95fa9af0d6e5b021397b015d19f64bcaf38ac969e1cfc997410e15e1a6b19f5dd98f176ac601ae24f28ac8481afce5414977163ffeb755f254be235f2c126b5b6a2b4ce5cd46562d4a91147249ea00f636c7d31ad075766799f7a9e1170fd721d7735a76ffc7fc95323dad15aa147b2a83e01a4e6d5f3e01e18e07540bf0b05d302fc5aaf5be1311b99a4cc105d62312af31cf31b1fec608209450853abc6ed12efbea72b39bd028e07b77fce1ce40754e2d111e003f0aed56f8138d59e8889df03573dae3d162462b05bdb2b2afbaa701ef1f2efd6e7dfb58b60c9de4d72c9029c548958d2ea902d03148a9e374cd2bfeb0b82409ceea0b44e2398dd20647eaf3d42e2fd328b4b8a786ab1a7bf24ac7272325772318307432d7483a7dd95e27f7f97bf2330201f004bb3cb8d1210abfceea0162c8104e1b62a1459e05a738364144009faf62d533e8a8fdc3e8e7e25a42b7b30949c283c796bbff9c3eaa6c287c493a60c7c8a6151e885591c7dc97df259966711c1383203f0f8b81d05c16051c38d0a310e953611b76f3c8646b1eeccc851812a53351dbec29f7d95b6bc03c29ecfae502f40c2d2d3a2e500438407defb3281bdf73e202e08a44456530eb4d9f5c60f42a63e145bb228e34a2d4c5f7cd19c117cd1285f917d6542a29e823d5dee29d696a052d2d93d33a677789afd4b51c454b48f88aff5ed09f1ddb9a57610bfb53f08abe945ce5b470d258e28da5a07d76fa3e642094e93f1388861aaacd62bdee35db1e87421ea0d14ac3ead59cbc9bbe3d6c090547d5fd66c3e126a304ec0d3b722731db0027fd33ab4f39f78e00ff5cfe589507f5e6df4f0931dc3c6fc8722273fe426e63ce88c925cbe8d9a334ab773e55470065ce5b792bc0fff223671a9108e65c7f95fe57b54e292be34b84ae6be9aff4180dbd7dc1483a765ddd8524c54901beb1ef5585986abfcf6b18716aec221bd7f816d83f871e022ef6c69b5ac66867b3e19f6986f2ddabe4d130aaf92eb3e26b87de1f3fd196356a6c4c43b251546c78f5197a102ec7ae580ffe2ffe4d5b0493b8c8d96b02c98c88d8dd116497eb93e651a219d4790949f73fce87521fe9a07450e545ac68ef91c13ffaca61584b069fbc2a87849d1d81693e6f851f149206378190a2b262b071428555cc7b74f1ac4c982c1f1c08baa896309d10661fbb9db3ff14e3d2ad4e550844681c42235bea9c11c65727bda8df30fcf1ef82ff0e03298c9dcbf0be871ee09459d6ae9f604c4a2f7525a77786b27a99617f22942d88353d2a62130ce34add89451d72d958994176431472461233783af09d09bd969d904605dbaa525060ee2a5796b63495e0e126cf80cc47865d8d675e06a46e57ae40abdd381ad827f31f25811040a99a55702dedd80f734e2eaab1e040653b3d927d23c89cfe4489c17d372f5f2faf24ba009b042f8ead11585c6131f3a3db184d81ae70b56d9782c81e6203dab61b6b92b825856b1ad4ede8ad13c7144fe5f180caeae4cbfd10d2d128d220fecc2541db8895e7793f81009450c91a601bf995d45c715e94aae492e43d5c4bf74310f681d962992a5fe482d922ddbe0c59a3f7856d43bd106f36c24306f209a93028f8201b829c7e277881e8dd7af2c72c972d4a58f5b35ec83ceab2ca05f4a9fb1b0f4cc71a2f7caf8b09e509c7bf093118edbb20c66e094aa96e69aa5b0f444582075a930a79c8ffd8de832496b422d54927d2cea80ae391c07e33a95d4143c76ea30418e774ee6507907afa6cc9c84a5f35921739ff4f4d3fce6ccefed8aa33ecb5dc28a4ae3f6e795b93198a3768cbf6a5ea6b0bc4c57567bc767403c46714e882fe85c9d9e3bb106b68f506836ca7fe7c876e13f3696b49a29d6df736fb3162b157390554331015d449a587f37e9d3a976824e32c43b0b79c3de6a26a47744733e516747e7bf8804b1f79ceacef47bd3adcc99a4b07d36a1db03129bf21c9ff06616aa5e20fcd08e551c26b3583a786e6c2b274c630996f225aa79ab572018737d68dd2495a95a8f1bed48846bf3a6f9cb1086aa4ddbb1d20d5fad1394a8ba37f227901596b5b6e19155bd6771664ff9f52a2c5def8470f9e92516867d45d03a58c613c43564ce4b6e9bc18c1588ef6478c4e81078c5915f10b610e9dac36ef36b9403575429584d7c878af726e55683108f4a6de6a8e804f77e696c3c0e5c9299fccd1a16c729f3476c8a56528286b8cf5152e21dee637fc5f0151f82de2a1e02ee463dcd269328c297614e6f99539d1d5ace7ef4b5650d0764a451f79a8a8081009e1fba7cafbf40b58caf20198b3569c327904332230f9cc381b37374aaa628c69d4ec8342bf7e4b802fcb97a6cc81b98e624ffd4ac880ba1695debf4439bad2849d711f30fac699270db36aef7ddd12d7befa2a9033b4e66e8bf1bdd502105c04de27224ad1df6c0cf959bf79894048647dc5d363aed55aa4b937a2b7319b90af28518d72cf4e233355011eb8f4a05d88cfb1700a8369c271f3d8059790c004edb258edecd8a8fe8c7fff746803d92dff8e71126ea8fe8379617fc03190b4722d90c176b3ebc618db0f6943c67c9014013fff4ae18dfcdd99a53a7699dd7a38b3bc51256307dc299e95fad7c7809371e3100d698629f312bf359f9e4070f8140aa054fe2125c13962026474db4740cd29ab087786e3438409fc0ce1cf896b3736c860bd42d8326bc93b18641267273785697040233da51501d3417614520c45ec01621013dadb0ecd52e117b0e95303e25aa59d1db0ecc8b3e71f1323f2b0b265ae62fdf3a47b1f46dd6b7f4696daef79a2b28ef3a146e5a15b96af23f0524248172444dd0c92025e6727004ba77b6db0f8e3541ae81478dcdf938cef2fbea7a1be16b0de1040878280bcae443e769740b41de9815ceec4648485d493a7a903787dab64fcc89c96ce42d1f35c74b2c42a973f52b3cfe0379ad55f9cca2da5020ce94073bb219342f46aa798844c5d819534ad132dc103b0f462ca1a51411ccf5ef5ab2f7390228704d78a9160e23f1c3143b25683cf5a3f5687465d31ecb14012ab23769611fdda665e1310c871dee13e14f59631a9696f214697cf14360eff23343cef8114ed896e749482dceb8f204b0fafbf25fb7c36821f70f26c07d9648ae1634caf64dd8d4f1e3e48633ff6423b22eb599edba6b694c787f098b1a93e86ecd5ca92775eeff8224dbde636501841df7df601e8700e1e3278479c4c09ae96a988e66890a3574816b6b6b30bbd8c72ad3bebca6d2a6509ea1a5eb65fb4f5a27df567df30e71fdfda49de6bf44bf27aa053582da4110a2fae9525b2cc1c22fdae300fcef604f764b4a7f54075e8ffa2375f94fb70865fea42686640f8e23aa8eaca00f812132816f35e0d89457f8d20e1f6b546d59027a6b4c4a6a0d7f1037e451808a812e75b65064cfbd54696c9d221ced911621419173192a524075547538b223343f75980d9f651ce6e8f198c28803271259d3366789e3f5f233ee506345faa9a51ce525b77d0679bd505ce6a479a44438532941cf80aa78fb73c1df7f2b0fd05b4e31c5e6f6cbd516e9bc8aff03e294bfbdd364b8b18c916eed8790adfc2c94eba90ae67eae9c649a398f65f21d288a18b870dcae6a81171265d41945b908877eeff5e18a5d7619ca2c2d31805ed7270eb9e9aacd65e020e4d92650a23456278095123654eade37b6e534a9d3970c98cdc4b2d22e690a69f1f0ec4fb1fc5d00a05331528a001f324bd10ba705f6ccff7d02410cfea60c8a81267142fc881bbfd1b3d1fd7376fee01da21f339ee2c875876f04f95ce75f4a6e034d0fd5c2c5d42b36cdea6a4409c9fc0371da232c5317fe54f2d0d8a2b6775fd6fcf407b9709442077c1c0cbba8a2173bab915accdd5a4657702e0658dedb01d1f90de5bb5ba1fd42b5fa24c0f41f8aba7afe839441de8a7bfce16875b923450b61722dee442ba762efde94e9a83b23d92ff0ae851253b7089110a0d5cd85162cd3b6270aa05bad7e63afd1b395adfa29052c8bf85b6d5cca153e1fdbcdbf4f0b8b265ec944e106ee60875a744b2f0e599709d60b172b284808ee3782cf54876d9a50867f2a997cc0e26b0d678e34ed41227911b1560d0299620394e3ea337b6156f347ad824b446248b9be0fe68413ffbb5c25d932dd4010cc598470ad059d1426d1744f823eeb4ed04635ad02b958a4e2562a3b014027065ac01f88b89ae11e890c533de0e7cd032b1712e3c75dba7df485c7a2cad65dd9ee5f05b2c4ad33d3d1b0f5aaea4652718d78ddc93b294551bc26aeb46378705736cb9f1bc7d2244b671cfbd544d5df37ad2f0af46f04fef05731da93eb86539901f5160d2f93eb87f6233da53a0dd3900476e23d11a874cf9af3a136c0801e287898f98032b996fc03285ff94c540f4b95d88faf9f3d60d2b265c574791cc99f7dad9b69500b08ef8160c6297a34957a4cc43e9d05ac29e4249053c0dc271f4d3e07b2851804c1d8cbe798e6b3e8cbef7ca7aa4878b5bdccadc59881c70499b01bd08b2c20bea4f2dec5522ce4ee4d14183cb5d08657efcd3103924b1907d67014211d204914fc93314d6a2660800c3b1ee010cc901a9b7a0bfa2b6392e3172f582b7e6b79c1282bef68ef03209b1c2467be80aa5e434469de9dfc2d9e3b46f960709d54e94befdf8ceb1a4462740a98915528a11b38545da8ea24b3677ba04a593091449dfc99146cf13e17b5fd04a74a67daebb3d0927cf6240210971a1b8fb42c6c7005825e4eccb7bf72388be5a511c62bd06a987e50af6c02a6a10e4e6065fa7708482d0864d0de13c4c0c314a799ff44a0db502a1f93bb4c142d6d Hey, password is required here.","tags":["时间"],"categories":["Linux"]},{"title":"NTP 相关内容备忘","path":"/2025/10/31/0013-ntp/","content":"注意事项 NTP 使用 UDP 123 端口。 ntpd 既可以作为服务端程序，也可以作为客户端程序。所以当设备仅使用 NTP 客户端功能时，要在 etcntp.conf 中增加以下内容： restrict default kod nomodify notrap nopeer noqueryrestrict -6 default kod nomodify notrap nopeer noquery #针对ipv6设置# 允许本地所有操作restrict 127.0.0.1restrict ::1 配置文件etcntp.conf NTP 服务（如 ntpd）的主配置文件，核心作用是定义 NTP 服务器的运行规则，包括时间同步的来源、客户端的访问权限、安全认证方式等，直接决定 NTP 服务如何工作 etcntpkeys NTP 服务用于身份认证的密钥文件 文件中每行定义一个密钥，格式为：[密钥ID] [密钥类型] [密钥内容] $ cat /etc/ntp/keys10 M 123 密钥 ID：1-65535 之间的整数，用于在 NTP 配置中引用该密钥（如 trustedkey 1 表示信任 ID 为 1 的密钥）。 密钥类型：通常为 M（MD5 加密，最常用），也支持 S（SHA-1）等，指定密钥的加密算法。 密钥内容：由字母、数字或特殊字符组成的字符串（建议长度 8-32 位，复杂度越高越安全）。 常用命令网络抓包tcpdump udp port 123 -w ntp.pcap ntpdate 使用的是系统随机分配的空闲端口。 ntpqntpq -np ntpq -crv 查看认证状态 ntpq -c as ntpdate# x.x.x.x是 NTP 服务器的 IP 地址ntpdate -u x.x.x.x 认证相关 ntpdate -a 10 -k /etc/ntp/keys x.x.x.x 在对时间有严格要求的生产环境下，使用 ntpdate 可能会产生严重的后果。 ntpd 是步进式的逐渐调整时间，而 ntpdate 是断点更新，比如现在服务器时间是9.18分，而标准时间是9.28分，ntpd 会在一段时间内逐渐的把时间校准到与标准时间相同，而 ntpdate 会立刻把时间调整到 9.28分。","tags":["NTP"],"categories":["编程"]},{"title":"keepalived - VRRP 协议","path":"/2025/10/30/0010-keepalived-00/","content":"虚拟路由冗余协议 VRRP (Virtual Router Redundancy Protocol) 主机设备通过网关与外部网络联系，当网关出现故障时，主机设备将与外界失去联系。 VRRP 将多台设备组成一个虚拟设备，通过将虚拟设备的IP地址配置为网关，当网关设备发生故障时，VRRP 机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。 概念 VRRP 路由器(VRRP Router)：运行 VRRP 协议的设备，它可能属于一个或多个虚拟路由器。 虚拟路由器(Virtual Router): 又称 VRRP 备份组，由一个 Master 路由器和多个 Backup 路由器组成，被当做一个共享局域网内主机的缺省网关。 Master 路由器：承担转发报文任务的 VRRP 设备。 Backup 路由器：一组没有承担转发任务的 VRRP 设备，当 Master 路由器出现故障时，它们将通过竞选成为新的 Master 路由器。 VRID：虚拟路由器标识，在同一个 VRRP 组内的路由器必须有相同的 VRID。 虚拟 IP 地址(Virtual IP Address)：虚拟路由器的 IP 地址，一个虚拟路由器可以有一个或多个 IP 地址。 IP 地址拥有者(IP Address Owner)：如果一个 VRRP 设备将虚拟路由器 IP 地址作为真实的接口地址，则该设备被称为 IP 地址拥有者。如果 IP 地址拥有者是可用的，通常它将成为 Master 路由器。 虚拟 MAC 地址(Virtual MAC Address)：格式：00-00-5E-00-01-{VRID} (VRRP for IPv4); 00-00-5E-00-02-{VRID} (VRRP for IPv6)，其中 00-00-5E 是 IANA 组织分配的，00-01 是为 VRRP 协议指定的，VRID 是虚拟路由器标识，取值范围为[1-255]。当虚拟路由器回应 ARP 请求时，使用虚拟 MAC 地址，而不是接口的真实 MAC 地址。 非抢占方式：如果 Backup 路由器工作在非抢占方式下，只要 Master 路由器没有故障，Backup 路由器即使被配置了更高的优先级，也不会成为 Master 路由器。 抢占方式：如果 Backup 路由器工作在抢占方式下，当它收到 VRRP 报文后，会将自己的优先级与通告报文中的优先级进行比较。如果自己的优先级更高，就会主动抢占成为 Master 路由器。 VRRP 路由器的优先级0优先级为 0 用于指示当前虚拟路由器的 Master 路由器停止参与 VRRP 组。主要用于触发 Backup 路由器快速地迁移到 Master 路由器，而不用等待当前 Master 路由器超时。 255如果 VRRP 路由器是虚拟路由器地址的IP地址拥有者，那么其优先级必须为255。 1-254Backup 路由器的优先级必须在1–254之间。缺省的 VRRP 路由器优先级为100。 典型组网案例主备备份业务仅由 Master 路由器承担，当 Master 路由器出现故障时，才会由选举出来的 Backup 路由器接替它工作。 负载分担在路由器的一个接口上可以创建多个虚拟路由器，使得该路由器可以在一个虚拟路由器中作为 Master 路由器，同时在其它的虚拟路由器中作为 Backup 路由器。 为了实现业务流量在 Device A、Device B 和 Device C 之间进行负载分担，需要将局域网内的主机的默认网关分别设置为虚拟路由器1、2和3。 在配置优先级时，需要确保三个虚拟路由器中各路由器的 VRRP 优先级之间形成一定的交叉，使得一台路由器尽可能不同时充当 2 个 Master 路由器。 keepalived 阅读材料 HUAWEI: VRRP配置","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"每天最重要的2小时 - 02","path":"/2025/10/29/0009-two-awesome-hours-02/","content":"我们的大脑能量是驱动我们行为的燃油，如果没有了它，我们就寸步难行。 什么会让你心理疲惫“执行功能”指的是大脑所拥有的各种控制和决定方向的功能。大脑的执行功能包括做出决定、做计划，必要的时候，还要短暂地记住一些想法。 进行自我控制往往会削弱我们的自控力。当进行自控行为之后，我们的这部分大脑功能往往会显得疲惫。 即使是做一些典型的、日常的、不重要的决定，也会让人在接下来的自控性任务中缺乏动力。 情绪决定你的表现情绪能够帮助我们解决和应对眼前的情况。 愤怒或不快能够让我们积极应对某些特定的想法和行动。下一次，如果你明知冒这个险才是正确的，却又不敢冒险，不妨让自己愤怒起来。 当我们感到悲伤时，往往会在做决定时尽量少带成见。 焦虑是一种能让我们高度警觉、对任何突发状况做好准备的情绪。 如果想让自己在那些不太重要的事情上放开手，如果要发挥自己的创造力，如果需要做出迅速的决定，试试带着积极的情绪去面对。 如何管理心理能量首先要分辨出那些工作最容易极大地消耗你的心理能量。在进行需要自己百分百投入的工作之前，一定要尽可能地避免做那些消耗心理能量的事情。 如果你在做完某项任务之后觉得很累，很有可能就是它让你消耗大量的自控力。 试着做一做下面这四件事： 早上第一件事（真正的第一件事，在看任何社交媒体之前）就是完成你最重要的工作。想想你自己手头上最具创造性、最有意思的工作，或者长远来看最有益的工作是什么，然后在早晨花一两个小时去做。 考虑一下今天所有的待办事项，把他们分类为重要的、创造性的、其他。在一天中较晚的时候完成其他分类里的工作。 试试在下午花上一个小时阅读并回复你的电子邮件。 在第二天有重要活动时，头天晚上就提前做一些决定，比如穿什么，早餐午餐吃什么，也可以是重要的决定。 迅速补充心理能量的三种方法： 缓慢地深呼吸一会儿。 尽情地大笑一场，积极的情绪可以为我们“充电”。 短暂地打个盹儿。10分钟的短暂睡眠能够帮助缓解疲劳，还能够提升警觉度以及许多不同的认知功能。 有时候果断地放弃一些事，以保证自己在最重要的时刻拥有良好的状态，对我们而言或许更有帮助。 为了真正利用好你的心理能量，你需要做的是出色地完成事关紧要的工作，而不是平庸地完成所有的工作。 结论：让你的效率达到最大化下一次，如果你发现自己正处于抉择点，能够开始一项新任务时，请务必回顾一下：刚刚完成了那些任务？大脑是否已经因为做出了太多决定而疲惫不堪？目前的情绪如何？它们有没有影响到你的下一项任务？ 反思Dan Koe 的视频中确实也有提到愤怒的情绪的作用。 某天，我发现折腾博客的个性化配置会让我很累。 时间管理不是把日程塞满。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"keepalived - VRRP 同步","path":"/2025/10/28/0010-keepalived-03/","content":"Keepalived 的 VRRP 同步功能（即同步组，sync groups）解决了复杂网络环境中的一个关键问题：在此类环境中，多个 VRRP 实例可能需要维持状态一致性。若缺乏同步机制，各个 VRRP 实例会各自进行独立的状态转换，这可能导致 “脑裂”（split-brain）场景或路由路径不一致的问题。 keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"Source Insight 配置记录","path":"/2025/10/28/0012-source-insight/","content":"快捷键 F5: 跳转到指定行 F8: 高亮选中 Ctrl + /: 全局搜索 Source Insight 的两种高亮方式1. 自动高亮（鼠标点击高亮） 打开选项设置：在菜单栏中选择 Options File Type Options…。 勾选高亮选项：在弹出的窗口中，找到并勾选 Highlight references to selected symbol 选项。 效果如图 2. 快捷键手动高亮 选中要高亮的部分，点击 F8 效果如图","tags":["SourceInsight"],"categories":["编程"]},{"title":"keepalived - VRRP 调度器","path":"/2025/10/28/0010-keepalived-02/","content":"代码版本： https://github.com/acassen/keepalived/releases/tag/v1.1.12 通告处理VRRP 调度器处理传入的 VRRP 通告，并根据实例的当前状态对其进行处理： 代码流程vrrp_read_dispatcher_thread vrrp_dispatcher_read /* read affect received buffer */ read(fd, vrrp_buffer, VRRP_PACKET_TEMP_LEN); /* Searching for matching instance */ vrrp = vrrp_index_lookup(hd-vrid, fd); /* Run the FSM handler */ prev_state = vrrp-state; VRRP_FSM_READ(vrrp, vrrp_buffer, len); /* MASTER */ vrrp_leave_master vrrp_state_master_rx /* Process the incoming packet */ ret = vrrp_check_packet(vrrp, buf, buflen); if (Lower priority) vrrp_send_adv(vrrp, vrrp-priority); vrrp_send_gratuitous_arp(vrrp); return 0; else vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); vrrp-wantstate = VRRP_STATE_BACK; vrrp-state = VRRP_STATE_BACK; return 1; /* BACKUP */ vrrp_backup vrrp_state_backup if(Higher priority) vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); else vrrp-wantstate = VRRP_STATE_GOTO_MASTER; vrrp_send_adv(vrrp, vrrp-priority); vrrp_send_adv VRRP 协议报文封装在 IP 报文中，发送到分配给 VRRP 的 IP 组播地址 在IP 报文头中 源地址为发送报文接口的主 IP 地址 目的地址为 224.0.0.18 TTL 必须是 255。（VRRP 路由器会丢弃 TTL 不等于 255 的 VRRP 协议报文） 协议号是 112 /* send VRRP advertissement */vrrp_send_adv /* build VRRP packet */ vrrp_build_pkt(vrrp, prio) /* build IP header */ vrrp_build_ip ip-ttl = VRRP_IP_TTL; ip-protocol = (vrrp-auth_type == VRRP_AUTH_AH) ? IPPROTO_IPSEC_AH : IPPROTO_VRRP; ip-saddr = VRRP_PKT_SADDR(vrrp); ip-daddr = htonl(INADDR_VRRP_GROUP); /* checksum must be done last */ ip-check = in_csum((u_short *) ip, ip-ihl * 4, 0); /* build the vrrp header */ vrrp_build_vrrp(vrrp, prio, vrrp-send_buffer, vrrp-send_buffer_size) keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"Linux 进程间通信：共享内存","path":"/2025/10/27/0011-ipc-shm/","content":"头文件 sys/shm.h shmget 创建共享内存 第一次创建完共享内存时，它还不能被任何进程访问 int shmget(key_t key, size_t size, int shmflg); shmat — at：attach 启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间 void *shmat(int shm_id, const void *shm_addr, int shmflg); shmdt — dt：detach 将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用 int shmdt(const void *shmaddr); shmctl — ctl：control 控制共享内存 int shmctl(int shm_id, int command, struct shmid_ds *buf);","tags":["进程间通信"],"categories":["Linux"]},{"title":"keepalived - VRRP 状态机","path":"/2025/10/27/0010-keepalived-01/","content":"代码版本： https://github.com/acassen/keepalived/releases/tag/v1.1.12 VRRP 状态机VRRP_FSM Read_to: read timeout struct void (*read) (vrrp_rt *, char *, int);\tvoid (*read_to) (vrrp_rt *); VRRP_FSM[VRRP_MAX_FSM_STATE + 1] =/* Stream Read Handlers | Stream Read_to handlers * *------------------------------+------------------------------*/\tNULL, NULL,\tvrrp_backup, vrrp_goto_master,\t/* BACKUP */\tvrrp_leave_master, vrrp_master, /* MASTER */\tvrrp_leave_fault, vrrp_fault, /* FAULT */\tvrrp_become_master, vrrp_goto_master\t/* GOTO_MASTER */; VRRP FSM Macro/* VRRP FSM Macro */#define VRRP_FSM_READ_TO(V) \\do \\ if ((*(VRRP_FSM[(V)-state].read_to)))\t\\ (*(VRRP_FSM[(V)-state].read_to)) (V);\t\\ while (0)#define VRRP_FSM_READ(V, B, L) \\do \\ if ((*(VRRP_FSM[(V)-state].read))) \\ (*(VRRP_FSM[(V)-state].read)) (V, B, L);\t\\ while (0) VRRP_TSM当某个 VRRP 实例发生状态变更，且需要与其同步组（sync group）内的其他实例进行协调时，将使用 VRRP_TSM 。 使用方式可以理解为：VRRP_TSM[from_state][to_state] struct void (*handler) (vrrp_rt *); VRRP_TSM[VRRP_MAX_TSM_STATE + 1][VRRP_MAX_TSM_STATE + 1] =/* From: To: BACKUP MASTER FAULT *//* v */ NULL, NULL, NULL, NULL ,/* BACKUP */ NULL, vrrp_sync_master_election, vrrp_sync_master, vrrp_sync_fault ,/* MASTER */ NULL, vrrp_sync_backup, vrrp_sync_master, vrrp_sync_fault ,/* FAULT */ NULL, vrrp_sync_backup, vrrp_sync_master, vrrp_sync_fault ; VRRP TSM Macro#define VRRP_TSM_HANDLE(S,V) \\do \\ if ((V)-sync \\ S != VRRP_STATE_GOTO_MASTER) \\ if ((*(VRRP_TSM[S][(V)-state].handler)))\t\\ (*(VRRP_TSM[S][(V)-state].handler)) (V);\t\\ while (0) 状态图 初始化期间，从 INIT（初始化）状态开始 若所有检查均通过，则转换至 BACKUP（备份）状态 若未从优先级更高的主用（MASTER）设备接收到通告消息，则转换至 MASTER（主用）状态 若接收到优先级更高的通告消息，则转换至 BACKUP（备份）状态 若任何被跟踪的资源发生故障，则转换至 FAULT（故障）状态 当故障条件清除后，返回至 BACKUP（备份）状态 INIT 状态/* Initialize state handling */static voidvrrp_init_state(list l) for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) vrrp = ELEMENT_DATA(e); if (vrrp-priority == VRRP_PRIO_OWNER || vrrp-wantstate == VRRP_STATE_MAST) vrrp-state = VRRP_STATE_GOTO_MASTER; else vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); vrrp-state = VRRP_STATE_BACK; BACKUP 状态 当处于 BACKUP（备份）状态时，该实例会设置一个 master_down_timer（主用设备下线计时器）。 每当从优先级更高的主用（MASTER）设备接收到有效的通告消息（advertisement）时，此计时器就会重置。 若计时器超时（即在超时周期内未接收到任何通告消息），该实例将转换至 MASTER（主用）状态。 /* Handle dispatcher read timeout */static intvrrp_dispatcher_read_to(int fd) /* Run the FSM handler */ prev_state = vrrp-state; VRRP_FSM_READ_TO(vrrp); // vrrp_goto_master /* handle instance synchronization */ VRRP_TSM_HANDLE(prev_state, vrrp); MASTER 状态 拥有并维护虚拟 IP 地址（VIPs）。 按照配置的时间间隔发送定期的 VRRP 通告消息。 处理接收的 VRRP 通告消息，若接收到优先级更高的通告消息，该实例将转换至 BACKUP 状态。 static voidvrrp_master(vrrp_rt * vrrp) if (vrrp-state == VRRP_STATE_MAST) vrrp_state_master_tx(vrrp, 0); FAULT 状态由于出现错误条件，该 VRRP 实例无法以 MASTER（主用）或 BACKUP（备份）状态正常运行。 keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"每天最重要的2小时 - 01","path":"/2025/10/21/0009-two-awesome-hours-01/","content":"意识到每天的关键时刻–抉择点我们一旦开始了一项神经性常规活动，就会像电脑程序一样一直运行下去，直到完成任务，或是被打断。 实际上，每一天都是由一系列习惯性的神经常规程序组成：早上起床、穿好衣服去上班、打开电脑、回复电子邮件等。问题在于，我们经常会从一个任务跳到另一个任务，却不仔细想想下一步最好该做什么。 学会意识到一天的当中的几个特殊时刻，在这种时刻，你有机会也有能力决定自己将如何度过接下来的时间。 做出最恰当的选择当常规程序结束的时候，自我意识就会浮现出来。意识最重要的功能就是在我们的自动式神经常规活动遇到困难的时候做出决定。 抉择点通常是作为冲突–无意识的自动行为之间的冲突、行为和目标之间相冲突–的结果而出现的。正因为这些抉择点会令人不舒服，我们往往才选择尽快跳过它们。 忽略抉择点的坏处匆忙跳过抉择点，很可能接下来进行的任务并没有那么重要，或是不适合在这段时间完成，损失也许会更大。 充分利于抉择点的三个诀窍在这一刻，对我们而言究竟什么最为重要。 珍惜每一个抉择点 意识到抉择点的出现，并尽力抓住它；要承认它的存在，而不是无视它，一头扎进无意识思维指引你去做的下一个任务里。 抉择点能够让你与眼下最关注的事保持一定的“距离”。 提前为抉择点做好相应计划 “计划不去做某件事”常常会失败，关键的一点是，你做的计划要让自己在这一刻进行一项新的活动–一项你乐意做的事。 当我们在脑海中设想某一个行动时，所利用的神经回路其实和真正去做这件事时的神经回路相同。 不要随便开始一项新任务，除非已经有意识地决定了它确实值得做。 一旦你完成一项任务，不要去想接下来自己可以是轻松地做些什么，而是把这一刻标记为抉择点。 怎么决定什么事最值得花时间？判断依据之一就是自己当天最重要的任务。 结论：聪明地安排你的时间用途在完成不同任务的间隙之间，我们终于从忘我工作的状态中脱身而出，这些时刻实在是不可多得的礼物，而我们完全应该审慎地利用这些时刻。 反思 早上睡醒之后，会无意识的在社交软件，购物软件之间来回跳转。（睡前将手机放在客厅。） 下班前会突然冒出不想运动的想法。（想象下班后运动的过程。） 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"孕期检查备忘录","path":"/2025/10/20/0008-pregnancy-checklist/","content":"名词解释13+6医生关于孕期的常用描述，13 是指第13周，+6 则指的是第6天，比如 NT 检查需要在 11 到 13+6 这段时间进行，意思就是需要在第11周到第13周的第6天之间的这段时间进行。 重要时间节点NT 检查 时间：孕11周到孕13+6周 通过B超检查胎儿颈项透明层的厚度。 建档（母子健康手册） 时间：孕12周 一本粉红色的小册子，需要保留到孩子上学。 建档需要进行抽血检查，所以当天早上记得不要吃早饭。建档之后，需要按照时间要求，定期到医院进行孕期检查。 准生证（生育登记证明） 时间：怀孕3个月后 准生证应该是计划生育时期的叫法，现在应该都是通过各地的相关公众号进行的。 唐氏筛查 时间：孕15周到孕20周（以医生建议为准） 用于评估胎儿患有唐氏综合征的风险。 四维彩超 时间：孕22周到孕26周（以医生建议为准） 实时三维超声，是在二维超声的基础上，通过技术处理而形成的形象直观的动态立体图像。 糖耐葡萄糖耐量试验（OGTT），简称糖耐。检查时会让准妈妈喝葡萄糖水来模拟一顿饭摄入的糖量，从而检测胰岛功能，排查妊娠期糖尿病。","categories":["生活记录"]},{"title":"顺风车车主初体验","path":"/2025/10/19/0007-hitch/","content":"更新记录：2025-10-28：偶然看到保险会以非运营车辆进行营运拒赔的说法，所以最终还是把所有平台注册的顺风车给注销了，避免不必要的麻烦吧。 在国庆节的末尾进行了爱车的第4次保养，我已有两年的驾龄，由于最近经常需要在周末开车往返于两地，所以下定决心跑一下顺风车平摊路费。 在没有注册成为顺风车车主之前的想法是顺路了就接一单，实在没有就算了，也不指望创收；但在成为车主之后，我的行为竟然瞬间出现了变化，我发现自己早早的发布了几天之后的出行信息，开始频繁的查看三个平台寻找合适的乘客，在乘客莫名其妙的取消订单之后觉得失落，在没有订单的情况下觉得要不再等等看有没有合适的。 在体验了一次顺风车车主的行程之后，我发现与我希望的方式（不接不送，顺路上下）不同，无论是高德、哈啰，还是滴滴，都需要车主按照乘客指定的起点和目的地进行接送。 因此我决定记录并提醒一下自己跑顺风车的最初想法和要求： 不需要跑顺风车创收，有合适的就跑，没有也无所谓 三环以内的订单不接（感受过市区下班高峰期之后的第一个决定） 距离我的起点和终点超过10公里的订单不接 每周五查看平台信息即可 接单后，及时与乘客电话沟通确认 除了上述提到的三个平台之外，在我的城市还有一个公众号平台，早期我也确实作为乘客体验过三四次，这个公众号上车主发布自己的具体行程，乘客依据自己的出行需求选择合适的订单，并主动与车主电话沟通。 哦，对了，那顺便说一下三个平台的逻辑， 高德：车主端可以看到乘客发布的行程；乘客也可以看到车主发布的行程；双方可以根据行程信息相互进行邀请 哈啰：暂时没有体验到 滴滴：乘客发布自己的行程，但看不到车主发布的行程，只能被动等待；需要车主依据自己的行程选择合适的订单 对比下来，我更喜欢高德的顺风车方式，不过感觉好像滴滴上的订单更多。","tags":["顺风车"],"categories":["生活记录"]},{"title":"结构体的内存对齐和变长数组","path":"/2025/10/15/0006-c99-vla/","content":"引入项目中业务模块产生的日志在通过本地 socket 发送给日志模块后，日志模块记录的内容总是会丢失前6个字节。经过排查，业务模块和日志模块使用的虽然都是 log_msg_t 结构体，但结构体中的变量类型定义却略有差异，如下所示： 业务模块的结构体定义 typedef struct\tunsigned char type;\tunsigned char level;\tunsigned short size;\tunsigned int pid;\tunsigned int cds;\tunsigned char imm;\tunsigned char u8wf;\tunsigned char data[]; log_msg_t; 日志模块的结构体定义 typedef struct\tunsigned char type;\tunsigned char level;\tunsigned short size;\tunsigned int pid;\tunsigned int cds;\tunsigned char imm;\tunsigned int u8wf;\tunsigned char data[]; log_msg_t; 显然，由于结构体中 u8wf 变量类型的不同，导致出现了内容丢失。但 unsigned char 的大小为1个字节，unsigned int 的大小为4个字节，怎么会出现丢失6个字节的内容呢，这与结构体的内存对齐有关。 内存对齐为什么需要对齐在 C 语言中，结构体的内存对齐是编译器为了提高 CPU 访问内存效率而采取的一种内存布局优化策略，是一种拿空间换时间的做法。 CPU 访问内存时并非逐个字节读取，而是按固定大小的 “块”（如 4 字节、8 字节）读取。如果数据的起始地址是块大小的整数倍（即 “对齐”），CPU 可以一次完成读取；否则可能需要多次读取，影响效率。 内存对齐规则 第一个成员在与结构体变量偏移量为 0 的地址处。 其他成员变量的起始地址必须是 min(该成员自身大小, 编译器默认对齐数) 的整数倍。 结构体的总大小必须是所有成员中最大对齐值的整数倍，即 min(结构体中最宽成员类型的大小, 编译器默认对齐数) 的整数倍。若不足，编译器会在最后一个成员之后添加填充字节以满足此要求。 练习下面两个结构体的大小分别为多少？ typedef struct\tchar c1;\tint i;\tchar c2; S1;typedef struct\tchar c1;\tchar c2;\tint i; S2; S1 和 S2 的内存布局如下图所示: 相关函数sizeof 获取结构体的大小 printf(%ld , sizeof(S1));printf(%ld , sizeof(S2)); offset 宏 计算结构体中某变量相对于首地址的偏移 头文件: #includestddef.h printf(offsetof(S1, c1) = %ld , offsetof(S1, c1));printf(offsetof(S1, i) = %ld , offsetof(S1, i));printf(offsetof(S1, c2) = %ld , offsetof(S1, c2)); #pragma pack() 修改默认对齐数（谨慎操作） // 将默认对齐数修改为 8#pragma pack(8)typedef struct\tchar c1;\tint i;\tchar c2; S1;// 恢复默认对齐数#pragma pack() TIPS在设计结构体的时候要满足对齐规则，又要节省空间，如何做到呢？ 在定义结构体时，将大小相同或相近的成员声明在一起，并且按照从大到小（或从小到大）的顺序声明，可以最大限度地减少填充字节，节省内存。 可变长数组此外，可以看到 log_msg_t 的最后一个元素为 data[], 且如果使用 sizeof(log_msg_t)，可能会发现结果并不符合预期，这一切都与可变长数组的特点相关。 介绍变长数组是在 C 语言的 C99 标准中引入的新特性。结构体中的最后一个元素允许是大小未知的数组。 比如： struct S int n; int arr[]; // 部分编译器可能会报错，可以将 arr[] 改为 arr[0]; 特点 结构体中的可变长数组前面必须至少有一个其它类型的成员。 可变长数组必须是结构体的最后一个成员。 可变长数组不占用结构体的存储空间，使用 sizeof 计算结构体的大小不包含可变长数组成员。 结构体变量相邻的存储空间保存的是可变长数组的内容。 log_msg_t因此，两个模块使用的log_msg_t结构体的内存布局如图所示: 可以看到两个结构体的 data 成员相对于起始地址的偏移量相差 6 个字节，这也就是为什么日志模块记录的内容总是会丢失前6个字节。 优势使用指针struct S int n; int *arr;; 那么在使用时就需要两次 malloc 和两次 free， struct S *ps = NULL;// 动态分配结构体S的内存空间ps = (struct S*)malloc(sizeof(struct S));if (ps == NULL) return -1;ps-n = 10;// 为结构体中的数组成员分配内存ps-arr = (int*)malloc(ps-n * sizeof(int));if (ps-arr == NULL) free(ps);\tps = NULL;\treturn -1;// do something // 释放所有动态分配的内存free(ps-arr);ps-arr = NULL;free(ps);ps = NULL; 使用可变长数组struct S int n; int arr[0];; 使用时只需要一次 malloc 和 free， // 分配内存以容纳结构体S和10个整数的数组struct S *ps = (struct S *)malloc(sizeof(struct S) + sizeof(int) * 10);if (ps == NULL) return -1;ps-n = 10;// do something // 释放分配的内存并置空指针free(ps);ps = NULL; 总结使用指针： 为了防止内存泄漏，如果分两次分配结构体和缓冲区的内存，当第二次 malloc 失败时，必须回滚释放第一次分配的结构体内存。 进行了两次 malloc，需要对应两次 free，如果我们的代码是在一个给别人用的函数中，我们在函数里做了两次内存分配，并把整个结构体返回给用户；虽然用户调用 free 可以释放结构体，但用户并不知道结构体的成员也需要 free，造成内存泄露。 malloc 次数越多，产生的内存碎片就越多，内存的利用率就会降低。 使用变长数组： 连续内存有利于提高访问速度，同时减少内存碎片","tags":["C语言"],"categories":["编程"]},{"title":"我的影视资源解决方案","path":"/2025/10/15/0005-emby/","content":"影视资源站最初主要在一些影视资源站看视频，比如在在线之家看完了全季的《权力的游戏》。 以下是几个仍保留在收藏夹中的资源站： 低端影视 在线之家 NO视频 网盘网盘在很长时间里都是我获取影视资源的主要阵地，从百度网盘、谷歌云盘、阿里云盘，到现在主要使用的夸克网盘。在阿里云盘开始收费后，我发现88VIP会赠送1年的夸克网盘会员（此时，我已持有88VIP将近半年的时间）。 夸克网盘会员(88VIP版)有6TB的存储空间，且在电视上有对应的客户端，几乎满足了我所有的观看需求，但影视墙功能仍需付费开通SVIP才能使用。不过，最近在折腾飞牛OS里提供的飞牛影视可以挂载夸克网盘，并且能够进行直链播放，也是一种免费使用影视墙的解决方案。 PS: 88VIP还提供1年的优酷会员或芒果会员，应该已经能够满足大部分的观影需求。 以下是几个我目前常用的网盘资源搜索网站： 云盘盘 SeedHub 夸克盘 EmbyEmby 在我看来是强者的存在，几乎可以替代爱优腾和各种流媒体平台。互联网上有大量的公益服和付费服，我记得最早使用的是叫做普拉斯影业的公益服，不过目前好像已经不能使用了。 以下是一个关于 Emby 的介绍视频，部分信息已过期，不过有助于你简单了解 Emby。"},{"title":"家庭网络折腾备忘录","path":"/2025/10/14/0004-cucc-modem/","content":"002a748617e5cc304f438c1409bd96526eb4ad4593d4d71e04e8698e3520de0cf8e5545d3a653be200d7127a72677075b27591933b5624dc42316f783c49f5b39cbe5476d1a3a35076c86152eb558d28c39678e517a24164134ed90692d8bcc00395ead76bb9bf955b19704afa3fb2075cb8988f8d95f0d888ee1b9577408744a705fd6d0008bb468613f9e3165557b4881365223a42ae4d5cda13bc70d5f635bc2932f657c2a25e8aac2cf984edcdbd4f56c4da662c37bea241d1efb52c41221c8e663eac64dc536ef2ed9c1315f235e1631b7eb9ad79cf3f1eb466e1d4ea8dd90ccf78a7ff9632a3b584aede277aeec0cf8c338b321fbeaeb833eb5cd5ff1bf6572b52d008132cb3b4a66efdd439eb75e56f271a6d2ff57e84ab760f4d279279cd828a918447fbfceaafbdb556a2513d4629afbba1ffd5b520a690fff390570a8febcf3bdf62b223a4f032ac02c0d731011c6c1bf4cd79f1596d484a6e477183ef99d4f92e03028d4cc176033163aa1f1c5bb1922adcaeaaf03538658f4c223c21e0f7f985e9032730a942ff60c5619f4f344dac000b70427f472ed7b2225d4195a28db1ad60db56a6dcc178a3325542a44e652800c9212138c3c29916fc9ce344bb42d2e54c6f91a678bd9fd8844ab925b7210a19b05d6fd1d7a3f282927cb658efa98d9547e0ebc4a5da9de7ccf847aeca4c67a77e23bb5855dd8d3391a457c7d1918d32545e6a9ef5ea30c2b9758fbd83455d0ef7a69f489d8b95c29122a21bd94b572a99e28766ea16801946cc Hey, password is required here.","tags":["光猫","路由器"],"categories":["网络"]},{"title":"Hello Stellar","path":"/2025/09/30/0003-hello-stellar/","content":"安装主题在根目录执行如下命令： npm i hexo-theme-stellar 主导航栏根目录下的 _config.stellar.yml # 侧边栏主功能导航菜单menubar: columns: 4 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 # - id: post # 页面中高亮的 menu_id # theme: #1BCDFC # 高亮时的颜色，仅 svg 中 fill=currentColor 时有效 # icon: solar:documents-bold-duotone # 支持 svg/img 标签，可以定义在 icons.yml 文件中，也支持外部图片的 URL # title: 博客 # 标题 # url: / # 跳转链接，支持相对路径和绝对路径 # - id: wiki # theme: #3DC550 # icon: solar:notebook-bookmark-bold-duotone # title: 文档 # url: /wiki/ # - id: explore # theme: #FA6400 # icon: solar:planet-bold-duotone # title: 探索 # url: /explore/ # - id: social # theme: #F44336 # icon: solar:chat-square-like-bold-duotone # title: 社交 # url: /friends/ 文章模版根目录下 scaffolds 文件夹中编辑 post.md ---# 基本信息title: title date: date tags: []categories: []description: # excerpt 也可 # 封面cover: banner: poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选# 插件sticky: # 数字越大越靠前mermaid:katex: mathjax: # 可选topic: # 专栏 idauthor: references:comments: # 设置 false 禁止评论indexing: # 设置 false 避免被搜索breadcrumb: # 设置 false 隐藏面包屑导航leftbar: rightbar:h1: # 设置为 隐藏标题type: # tech/story--- 文档系统（wiki）source 目录结构如下： .+ ├── _data+ │ ├── wiki+ │ │ └── hexo-cpp.yml+ │ └── wiki.yml ├── _posts │ ├── hello-hexo.md │ ├── hello-stellar.md │ └── hello-world.md ├── about │ └── index.md+ └── wiki+ └── cpp+ ├── backup.md+ └── index.md hexo-cpp.yml name: C++title: 学习指南subtitle: 从入门到再次入门tags: 博客主题icon: https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/icon.svgcover: https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/icon.svgdescription: 这是一份从入门到再次入门的学习指南。search: filter: /wiki/cpp/ placeholder: 在 Stellar 中搜索...leftbar: - tree - timeline_cpp_releases - relatedbase_dir: /wiki/cpp/tree: 快速开始: - index 网站备份: - backup wiki.yml - hexo-cpp index.md ---wiki: hexo-cpp # 这是项目id，对应 /data/wiki/hexo-cpp.ymltitle: c++--- sites 网站卡片 source 目录的文件结构如下： . ├── _data+ │ ├── links+ │ | └── tool-life.yml tool-life.yml 的内容如下: - title: 中国科学技术大学测速网站 url: https://test.ustc.edu.cn/ cover: icon: description: 非 WIFI 环境下慎点 在需要的位置添加如下内容： % sites tool-life % timeline 时间线静态时间线 在需要的位置添加如下内容: % timeline %!-- node 2021 年 2 月 16 日 --主要部分功能已经开发的差不多了。% image https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/photos/hello@1x.png width:300px ratio:1179/390 %!-- node 2021 年 2 月 11 日 --今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。% endtimeline % 侧边栏组件 参考链接：https://xaoxuu.com/wiki/stellar/widgets/ 在 source/_data 目录下新建 widgets.yml 文件 about_sidebar: layout: linklist columns: 1 items: - icon: svg.../svg # 或者 icons.yml 中设置的 icon 名称 title: 关于 url: /about/ - icon: svg.../svg # 或者 icons.yml 中设置的 icon 名称 title: 说说 url: /memos/ 在使用的地方，如 about/index.md中添加如下内容： ---leftbar: [about_sidebar]--- hexo","tags":["hexo"],"categories":["博客"]},{"title":"Hello Hexo","path":"/2025/09/30/0002-hello-hexo/","content":"本文描述的过程主要为如何在本地部署Hexo。在了解和熟悉本地部署的流程之后，更推荐利用 GitHub Actions 实现自动化部署 Hexo 到 Github Pages。 前置条件安装下列软件： Node.js Git 安装安装 hexo: npm install -g hexo-cli 查看版本： hexo v 创建创建 blog 文件夹mkdir blogcd bloghexo init 部署 hexohexo g 本地化预览hexo s 写作创建草稿hexo new draft hello-hexo # hello-hexo 为文件名 发布hexo publish hello-hexo # hello-hexo 为文件名 图片全局资源文件夹如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。 然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 文章资源文件夹将 config.yml 文件中的 post_asset_folder 选项设为 true post_asset_folder: true 在通过 hexo new [layout] title 命令创建新文章时，会自动创建一个与文章同名的文件夹。将所有与该文章有关的资源放在这个关联文件夹中之后，可以通过相对路径来引用它们。 相对路径引用的标签插件当打开文章资源文件夹功能后，把一个 example.jpg 图片放在资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](example.jpg) ，它将不会出现在首页上。 正确的引用图片方式是使用下列的标签插件 ： % asset_img example.jpg This is an example image %% asset_img spaced asset.jpg spaced title % GitHub Actionsname: Deploy Hexo to GitHub Pageson: push: branches: - main # 或你使用的默认分支名称jobs: deploy: runs-on: ubuntu-22.04 steps: - name: Checkout blog source uses: actions/checkout@v4 with: path: blog - name: Set up Node.js uses: actions/setup-node@v4 with: node-version: 22 # 设置 Node.js 版本 - name: Cache dependencies uses: actions/cache@v4 with: path: node_modules key: $ runner.os -node-$ hashFiles(**/package-lock.json) restore-keys: | $ runner.os -node- - name: Install dependencies run: npm install working-directory: ./blog - name: Install Hexo CLI run: npm install -g hexo-cli working-directory: ./blog - name: Install Hexo Theme run: npm install hexo-theme-stellar working-directory: ./blog - name: Generate static pages run: hexo generate working-directory: ./blog - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v4 with: personal_token: $ secrets.PERSONAL_TOKEN publish_dir: ./blog/public external_repository: username/username.github.io # 更改为你的 GitHub Pages 仓库, username 是你的用户名 publish_branch: main # GitHub Pages 分支 hexo","tags":["hexo"],"categories":["博客"]},{"title":"Hello World","path":"/2025/09/30/0001-hello-world/","content":"10d79030e8222445804370796b90fca1cf7dd2ee01010d95413afa643c36d75c6da7dc8584583c53132d123565a83bc482d57efe09dbb13f6be1ebadf67b396c5e9af14ae37a94b87d779719bc8c1cd1a95420a6d53586101970b6bd1e11383c5fb9eb6a2afd2dfd764940c736e232c31819ba63da4a7c6eb6c1003cc6443dcf2082b9f749ca03a1484b87b08c908b3c310d7b631064a7fc3f9ca36177e4c3059978875c3caa78a7dceb6037a9522caf5c4adf858dd97440561f76a5ba5e4fd77e9898dfeb4cad54c4bb643f9c0ecbaef49a3431bdd2455830a88255232397afbbe9b23eb9395dfae6f0824e03416bc0b3804386abdc6c923976a913424fdbf1ba89bde972822239ac5e9109f398b65ae65ef00629508a203d30649f6408e1f61f5f6e73d99349907d745bd4c4ef0763621826913a2677273e3b66ae19439d1940d9ebcc45d324738506f0ac5dca5093adf45b82a24da2d49432e9f7cea3b56d73ea8b80628014008c75e6df0aa070ccdaa53907f1adc5e6234b2ab2f7f8485fb9383dc64927d631e20713c7d719815e20c9d6247aa120998e681a19e43d40ca49e20ce7419d535072ff85e74c96caabe848f11f049126a6f4cbbfc746a3cae3d4b6c98db711e8b3bdbd372def67e3d1bf776ee35037a2377d5898704789976ec22fc47c64eb83da5766f0408afee5b438701c6084a1025c673100e7ac0cf710407782790b56679a3fbb40313022e90f715c1a39914fe4b710beb621310bee163ece727a9d02da8b2ef0925acbeedbed1bdf2fb2a5a106956f607dcb5fcef0e36a97afa6fe5d415be51d647cc196fec6186575845eba2577edf79b237f40501d9e0516fe26fcc18e5bb029218ceea51ed6571ed6499c1b863fe5e4184373aee7af54e687aecc3ffa4986afe90e3a5fd67d73f47c0c882443054fed1625259e96370f07d55431f1a03130d5486c9ac1bc2c51d48a7b31ca8c81fdd6cc8795e3296ee5cc4dd66f3e582583d5516a299f41c5bc32710ee392ddb18d02b9fea50df38fbea6579d1f8a7a1ec2fdcff1a546b8a51d96657a2c6538c2dc93476d69467cb3671b880c09d3c422cfb3bb9199050f0c77a137b4b0dbdb4041a1be97361f0b783b6ab8bbbdcfdf1c9d545e17a129eca1e4cc3aabe88b7ab633ec35eacbb26e1b4b8c0876bd6ed5f351cc4d04c974e55a4f37f0580b599953ae28a9a6f6ea344c8bee255996315fa0673b087d06f292b6f9e84801a38c8ffea05fecb03b16577db7697bbac072e1d372bf5fb0dfd48bdb369ba8ac97c5f3f8b3173cbee017a98e2eea5f78edd3ad8ae87ff061a3e43ccbb435291c501139a80744cf59040e4b980306c75cfb527b82fe4c578a8973a6a75baeb2be249b344f14cd6153f99e07309fee10b0e8e4702ded0dbde9bcc5b0eb0d117b479db98f93d36f1c8721a712a9650023572dd95effb7718f45c2948d9192a1d27b38e652903d68992618f4c9feee5c5dfc2fcb15fbf1d3fd5896245a14bc1bdabb6dddb4db0ea3fc36165bbc4b56ffbbb0ed570e77f7d8820a5078d5fe499945473ff216f85fe92c706d7aa308198dfcd4d85abe4f1fcb8924d6b5c72b05a03333c163fedfef1f479daeff26a1d99802645980fefa0f8be445851c3f508e0b5ee79b06b504a054b4e7ad26f9d0344d2395322d452565b03020d13fe150bbc9ca3e433e04e3411da56239b42807d0090d11b5858ff8487212fb6771f4914fdcd8393d2cd2150eb82d8e82be0db2e71679f2f78d5b22b32a305993748f09821838303b75df669acf24e08c3eab2fe0433662a1056cc392ccecc20041dbf44a229ada35bed43255979bfd7e150b6e812c6c23466dd45e57c5b443d976b298b5f5e4d977130bcaf5ec26e2e2c727886f3f116fd1fbad331bbf9d1ca9efa141a0174450b00f818e2b59a784a40b77918ba82e75a31bd542e611a43010f08fc30369e93386f239e5fb9a515d6c2afc272997890c0ec4619f78f4b5fed881f0002b85e8165088649391e0249613310e523cdf5e2dfd5d4b4236bf38c02fb72341cfe539508f7af5c7db00d07b8425db13d92aa628930b5521eba6daf54fce1a8a6a36e1b095f67ebadd2fb0c096012eee795a471f33f501a0fef0a9075dfce83a3227087b12382ff22011db6d7fc3cc877c19d425b5b672b574f4df7643bee516ecdc66629c21963733bea688bc205c9add0c36479130ca3eee5dc72698d00713bf52775cba1634cf4cdb9d5856c60135524af408c949847e6cce9729997a3858154a3cf638ec1f1d326b3caa59b6a3555f947a761998b37a3890339d86cf8eaaf75260de0475d5ba017d78d7e2671849c4f8924658a4fa3a6bb478e5dde99ccb965fc5f099418feda6e45cb85e810e253d8da0ec932b4f426793cb86b882291a6d98f048b162b71dd6888262a0e3d96caa0538f96845e3bddee62faf30f9b8e3176953e68652ed0b429f284bbd828de3d2c4815b2b69cd2f5cd993b1bcf65d2c8b67f3a5cc99dab9d029d01f9730eccf97c48dcfefbd9c3589bee7e98ebc76468ce1e4d47c4a4c89e275bb743892c4b8558d8ea957afa93b5ce2bd02f94ee38eb9fdcddcb8231584cc840b914a3eefe46c659029555aa0c43e523b507722c6753aa625f67b07ade89ad34eabd449f4c1d2822e0a0f435ce2602c2f5427dabec0f8cee68c5d64d9685cfc8e367505320dff6026c07f62ddb32c3039fe867067bcac7347b455893575e795974c91cd2b13bfe2341efd7b5e24b81aac898e60bb569def27c91bd3554bcf25d039002a7541daf01684f1aa4e4eb493a7ef9d3ab8c8489f98da8bf72989e524f97268729a6f437727d3354db4d2e5890f9b70fe2daa36cfbba178ccb0ead684e862eacb694e5c22f388c7d8b1f360f0459117529cf67e806255f61f71f840674c20c1b6c9b0ba4072bb7b1e19abec986c902fa25e735c93371dfb51ec15e9a2440cf886f29bc4e911d7c8925922efbc893b336161da60f33600143637d99e132a76da2087f75934b4997351f5e29ce8da8b847b61959afe5e9c612a2cc64730cf8dcb02cd15002ed3ec0088023a12023dcab79efe9d7f1f1d222b1193c79f0bab1a8e6a2dff9665327e827e675d76d3555cdc880e Hey, password is required here."},{"title":"探索","path":"/explore/index.html","content":"工具纸由我 PaperMe在线自定义打印纸生成器PDF24PDF工具中国科学技术大学测速网站非 WIFI 环境下慎点 公开信息查询中国裁判文书网https://wenshu.court.gov.cn/专利查询世界知识产权组织的免费专利数据库wikiHow互联网上最值得信赖的指南网站 自用闪卡导入 CSV 创建卡片引导云盘盘https://www.yppan.com/"},{"title":"关于博客","path":"/about/blog/index.html","content":"2025 年 11 月 7 日增加评论功能。2025 年 9 月 30 日使用 hexo + stellar 重新部署博客。"},{"title":"说说","path":"/about/memos/index.html","content":"2025 年 11 月 21 日发现最近很少去电影院了，上一次是今年2月去看的《哪吒2之魔童闹海》，上上次是24年6月。现在即便有想看的电影，也干脆等到上线流媒体平台了再看。2025 年 11 月 17 日手机在使用了半年后，电池循环154次，最大容量99%。2025 年 11 月 11 日今年的双十一让人有点摸不清下单的合适时间点，优惠力度也从原来的85折变成了9折。2025 年 11 月 4 日在晚上运动后，立刻开始整理《每天最重要的2小时》的读书笔记，感觉确实不错。这也能够驱使我晚上坚持运动。2025 年 10 月 30 日如何做一个有质量的技术分享：问题 - 方案 - 总结2025 年 10 月 29 日昨晚无意间刷到一个外卖员练习英语的视频，想到自己也可以下载一个多邻国试试。"},{"title":"code","path":"/wiki/cpp/index.html","content":"工具DeepWikihttps://deepwiki.com/codewikihttps://codewiki.google/TemplateRepoCxxVS Code C++项目模板PlantUMLhttps://plantuml.com/zh/Linux Manpagesman 手册Linux工具快速教程https://github.com/me115/linuxtools_rst C++恋恋风辰的官方博客https://llfc.club/homeCppGuide社区https://cppguide.cn/c++自救指南https://www.blogchn.com/pages/3001d9/c++全栈知识体系https://stibel.icu/阿荣的个人网站https://www.arong-xu.com/ linux开发内功修炼https://kfngxl.cn/熊喵君的博客https://pandaychen.github.io/文先生的博客https://wenfh2020.com/ArthurChiao's Bloghttps://arthurchiao.art/articles-zh/ other技术文章摘抄https://learn.lianglianglee.com/深入高可用系统原理与设计https://github.com/isno/theByteBookTCP/IP详解 卷1：协议在线阅读版（全网唯一）无处不在的小土个人很喜欢的博客"},{"title":"interview","path":"/wiki/cpp/interview.html","content":"CVLapisCVhttps://github.com/BingyanStudio/LapisCV 八股阿秀的学习笔记https://interviewguide.cn/小林codinghttps://xiaolincoding.com/卡码笔记https://notes.kamacoder.com/ 刷题代码随想录https://github.com/youngyangyang04/leetcode-master"},{"title":"编译与运行","path":"/wiki/cpp/tws-build.html","content":"开发环境 WSL2 + Ubuntu-24.04 mysql-8.0.43 MySQL 安装与配置 mysql-server 安装 sudo apt-get updatesudo apt-get install mysql-server# 查看 mysql 的版本mysql --version 客户端库开发包安装，提供头文件和链接库 sudo apt-get install libmysqlclient-dev 数据库建立登录 MySQL 服务# 远程mysql -h localhost -P 3306 -u root -p# 本机mysql -u root -p 可能会遇到如下报错信息： ERROR 1698 (28000): Access denied for user root@localhost 这是因为MySQL默认使用了 UNIX auth_socket 插件进行认证。解决方案可参考：stackoverflow。 这里使用回答中推荐的第2种方案，即创建一个与系统用户一致的新的数据库用户： 注意：tws 可修改为自定义用户名 $ sudo mysql -u rootmysql USE mysql;mysql CREATE USER tws@localhost IDENTIFIED BY ;mysql GRANT ALL PRIVILEGES ON *.* TO tws@localhost;mysql FLUSH PRIVILEGES;mysql exit;$ sudo service mysql restart 之后登录 MySQL 服务就可以使用如下命令： $ mysql -u tws -p# 默认没有密码，回车即可登录 建立数据库$ mysql -u tws -p# 建立 twsdb 库mysql create database twsdb;# 创建 user 表mysql USE twsdb;mysql CREATE TABLE user( username char(50) NULL, passwd char(50) NULL)ENGINE=InnoDB;# 添加数据mysql INSERT INTO user(username, passwd) VALUES(admin, 123456); 编译代码修改 修改 main.cpp 中的如下内容: //需要修改的数据库信息,登录名,密码,库名string user = tws;string passwd = ;string databasename = twsdb; build$ chmod +x build.sh$ ./build.sh 运行run./server 服务访问 访问地址: http://127.0.0.1:9006/ 用户名: admin 密码：123456 其它MySQL 常用命令# 启动、关闭、重启 MySQL服务sudo service mysql startsudo service mysql stopsudo service mysql restart# 查看MySQL服务状态sudo service mysql status MySQL 用户认证方式查询$ sudo mysql -u rootmysql USE mysql;mysql SELECT User, Host, plugin FROM mysql.user;+------------------+-----------+-----------------------+| User | Host | plugin |+------------------+-----------+-----------------------+| debian-sys-maint | localhost | caching_sha2_password || mysql.infoschema | localhost | caching_sha2_password || mysql.session | localhost | caching_sha2_password || mysql.sys | localhost | caching_sha2_password || root | localhost | auth_socket || tws | localhost | auth_socket |+------------------+-----------+-----------------------+6 rows in set (0.00 sec) MySQL 删除用户mysql DROP USER tws@localhost;"},{"title":"功能梳理","path":"/wiki/cpp/tws-run.html","content":"00dd9c2c5c86dd0e1f8ce0e685de9f4ff0bd2a56b95edad86511c5d02f488f316760d7dce49fb836b51504758de8a211bcd2581eb7031339f7b407da5ff4892311b90f8085c0eb62976161580f45d9decaffdd630d0b7e470339139dd2bf6d39da932996dacfd2d0ac9ee14301c9aa0b551c4d96c7623025beaec65e203deb4cf73224719b44c3e4ea14b6bccb8ff50ffb7941f8393e53bdcbfdf526a403f8e5f8995133dfd83d3d6cb0b8a541804bceaa7f4c67d5db1dcb6f6a953b2c1ccaa42314d19667556223745996bc816d7e5698a572ded5593ef5e60eaebe1c202dafb1e6c7f41fac7c9fee6b8d711e30338dda764fc1239c4778854a251070b4834ca10cad61ae4a7d9976f56d0562a9548686a618c58319b5720b6004e6ce86de71e959ed53745df52a383d410ac18730d8b8ad1cec042e1e11b012cf8c631485a9dc49c6993bb17245ac555775f488fa21 Hey, password is required here."},{"title":"最近听的播客","path":"/about/podcast/index.html","content":"2025 年 11 月 21 日最近听到的比较惊喜，也比较喜欢的一期《正经叭叭: vol.224 第一届叭叭KTV》。顺便说一句，谐星聊天会 YYDS。"},{"title":"压测","path":"/wiki/cpp/tws-webbench.html","content":"保证 server 运行./server 压测$ cd test_pressure/webbench-1.5./webbench -c 500 -t 5 http://127.0.0.1:9006/Webbench - Simple Web Benchmark 1.5Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.Benchmarking: GET http://127.0.0.1:9006/1000 clients, running 5 sec.Speed=220188 pages/min, 411152 bytes/sec.Requests: 18349 susceed, 0 failed. QPS 是什么： QPS（Queries Per Second，每秒查询率）是衡量系统吞吐量的核心指标，代表服务器每秒能处理的有效请求数量。 QPS 如何计算： QPS = 总有效请求数 ÷ 总耗时（秒） 因此，上述压测的 QPS 18349 5 3669. webbench 原理 父进程 fork 若干个子进程，每个子进程在用户要求时间或默认的时间内，对目标 web 循环发出实际访问请求 父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息 子进程在时间到后结束；父进程在所有子进程退出后，统计并给用户显示最后的测试结果，然后退出"},{"title":"介绍","path":"/wiki/cpp/tws.html","content":"项目地址： https://github.com/qinguoyi/TinyWebServer 参考资料： https://deepwiki.com/qinguoyi/TinyWebServer 小白视角：一文读懂社长的TinyWebServer(Raw_Version) ZWiley的随记: WebServer项目"},{"title":"WSL 常用命令","path":"/wiki/cpp/wsl-cmd.html","content":"列出所有已安装的WSL发行版wsl --list --verbose 卸载某个WSL发行版wsl --unregister Ubuntu-18.04"},{"title":"WSL 开发环境配置","path":"/wiki/cpp/wsl-dev.html","content":"可根据需要选择安装 sudo apt install git cmake gdb build-essential clang clang-tidy \\ clang-format pkg-config tcpdump tshark"},{"title":"WSL 安装","path":"/wiki/cpp/wsl-install.html","content":"1. 以管理员身份打开 Windows PowerShell 启用 WSL 功能 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用虚拟机功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 2. 重启计算机3. 下载并安装 WSL 2 的 Linux 内核更新包 打开 PowerShell，运行以下命令 wsl --update 4. 设置 WSL 2 为默认版本 打开 PowerShell，运行以下命令 wsl --set-default-version 2 5. 通过 Microsoft Store 安装 Ubuntu 或其他 Linux 发行版 开始使用 WSL"},{"title":"bpftrace","path":"/wiki/ebpf/bpftrace.html","content":"列出可用的跟踪点和 kprobes bpftrace -l *execve* bpftrace -e kprobe:do_execve @[comm] = count();"},{"title":"bpftool","path":"/wiki/ebpf/bpftool.html","content":"FEATURE 获取可用当前内核版本中每种程序类型的辅助函数的列表 bpftool feature PROG将程序加载到内核中bpftool prog load hello.bpf.o /sys/fs/bpf/hello 查看发生的重定位bpftool -d prog load hello.bpf.o /sys/fs/bpf/hello 查看已加载的程序bpftool prog list BTF生成内核头文件bpftool btf dump file /sys/kernel/btf/vmlinux format c vmlinux.h 查看加载到内核中的所有 BTF 数据bpftool btf list 查看某个 BTF 数据的内容bpftool btf dump id id 查看特定 map 关联的 BTF 类型bpftool btf dump map name config 查看特定程序关联的 BTF 类型Usage: bpftool btf show | list [id BTF_ID] bpftool btf dump BTF_SRC [format FORMAT] [root_id ROOT_ID] bpftool btf help BTF_SRC := id BTF_ID | prog PROG | map MAP [key | value | kv | all] | file FILE FORMAT := raw | c [unsorted] MAP := id MAP_ID | pinned FILE | name MAP_NAME PROG := id PROG_ID | pinned FILE | tag PROG_TAG | name PROG_NAME OPTIONS := -j|--json [-p|--pretty] | -d|--debug | -B|--base-btf bpftool btf dump prog id 51bpftool btf dump prog name hello 查看目标文件中的 BTF 数据bpftool btf dump file hello-buffer-config.bpf.o"},{"title":"WSL2 安装 BPF 工具链","path":"/wiki/ebpf/ebpf-install.html","content":"https://cardioid-line.github.io/ubuntu-an-zhuang-bcc-zhi-nan/"},{"title":"index","path":"/wiki/ebpf/ebpf.html","content":"web eBPF.io github bcc btfhub bcc: libbpf-tools Tutorial libbpf-bootstrap eBPF Developer Tutorial blog 酷壳: eBPF 介绍 Learning eBPF the Hard Way: 从 nginx eBPF 的实现说起 BPF 学习路径总结 Linux超能力BPF技术介绍及学习分享 eBPF技术实践白皮书 bookLearning eBPF Learning eBPF Learning eBPF Chinese version (⭐26) online version Learning eBPF Chinese version (⭐2)"},{"title":"00. Running the example code","path":"/wiki/ebpf/learning-ebpf-00.html","content":"项目地址：https://github.com/lizrice/learning-ebpf env WSL2 Ubuntu 24.04 sudo apt-get install git cmake gdb build-essential sudo apt-get install clang clang-tidy clang-format pkg-configsudo apt-get install llvmsudo apt-get install libclang-devsudo apt-get install zlib1g-devsudo apt-get install libelf-dev Install this repogit clone --recurse-submodules https://github.com/lizrice/learning-ebpfcd learning-ebpf Building libbpf and installing header filescd libbpf/srcmake install cd ../.. Building bpftoolcd ..git clone --recurse-submodules https://github.com/libbpf/bpftool.gitcd bpftool/src make install"},{"title":"01. What Is eBPF, and Why Is It Important?","path":"/wiki/ebpf/learning-ebpf-01.html","content":"todo"},{"title":"02. eBPF’s “Hello World”","path":"/wiki/ebpf/learning-ebpf-02.html","content":"NOTE:Since eBPF is so powerful, it requires special privileges to use it. Privileges are automatically assigned to the root user, so the easiest way to run eBPF programs is as root, perhaps by using sudo. 2.1 BCC’s “Hello World”int hello(void *ctx) bpf_trace_printk(Hello World!); return 0; All the eBPF program does is use a helper function, bpf_trace_printk(), to write a message. the bpf_trace_printk() helper function in the kernel always sends output to the same predefined pseudofile location: /sys/kernel/debug/tracing/trace_pipe. 2.2 Running “Hello World”2.3 BPF Mapsa much better way to get information out of an eBPF program 2.3.1 Hash Table MapTypical uses include the following: User space writing configuration information to be retrieved by an eBPF program An eBPF program storing state, for later retrieval by another eBPF program (or a future run of the same program) An eBPF program writing results or metrics into a map, for retrieval by the user space app that will present results BPF_HASH(counter_table);int hello(void *ctx) u64 uid; u64 counter = 0; u64 *p; uid = bpf_get_current_uid_gid() 0xFFFFFFFF; p = counter_table.lookup(uid); if (p != 0) counter = *p; counter++; counter_table.update(uid, counter); return 0; 2.3.2 Perf and Ring Bufer MapsRing BuferBPF_PERF_OUTPUT(output); struct data_t int pid; int uid; char command[16]; char message[12];; int hello(void *ctx) struct data_t data = ; char message[12] = Hello World; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); bpf_probe_read_kernel(data.message, sizeof(data.message), message); output.perf_submit(ctx, data, sizeof(data)); return 0; 2.3.3 Function Callsinlined function 2.3.4 Tail Callstail calls can call and execute another eBPF program and replace the execution context, similar to how the execve() system call operates for regular processes. Tail calls allow for calling a series of functions without growing the stack. This is particularly useful in eBPF where the stack is limited to 512 bytes. Tail calls are made using the bpf_tail_call() helper function, which has the following signature: long bpf_tail_call(void *ctx, struct bpf_map *prog_array_map, u32 index) This helper is somewhat unusual in that if it succeeds, it never returns. The helper could fail, for example, if the indicated program doesn’t exist in the map, in which case the calling program carries on executing. BPF_PROG_ARRAY(syscall, 500);int hello(struct bpf_raw_tracepoint_args *ctx) int opcode = ctx-args[1]; syscall.call(ctx, opcode); bpf_trace_printk(Another syscall: %d, opcode); return 0;int hello_exec(void *ctx) bpf_trace_printk(Executing a program); return 0;int hello_timer(struct bpf_raw_tracepoint_args *ctx) int opcode = ctx-args[1]; switch (opcode) case 222: bpf_trace_printk(Creating a timer); break; case 226: bpf_trace_printk(Deleting a timer); break; default: bpf_trace_printk(Some other timer operation); break; return 0;int ignore_opcode(void *ctx) return 0; 2.4 Summarytodo 2.5 Exercisestodo"},{"title":"03. Anatomy of an eBPF Program","path":"/wiki/ebpf/learning-ebpf-03.html","content":"3.1 The eBPF Virtual MachineJIT (just-in-time) compilation 3.1.1 eBPF RegistersThe eBPF virtual machine uses 10 general-purpose registers, numbered 0 to 9. Register 10 is used as a stack frame pointer (and can only be read, but not written). include/uapi/linux/bpf.h /* Register numbers */enum BPF_REG_0 = 0, // The return value from the function\tBPF_REG_1, // The context argument to an eBPF program\tBPF_REG_2,\tBPF_REG_3,\tBPF_REG_4,\tBPF_REG_5,\tBPF_REG_6,\tBPF_REG_7,\tBPF_REG_8,\tBPF_REG_9,\tBPF_REG_10,\t__MAX_BPF_REG,; Before calling a function from eBPF code, the arguments to that function are placed in Register 1 through Register 5 (not all the registers are used if there are fewer than five arguments). 3.1.2 eBPF Instructions include/uapi/linux/bpf.h struct bpf_insn __u8\tcode; /* opcode */\t__u8\tdst_reg:4;\t/* dest register */\t__u8\tsrc_reg:4;\t/* source register */\t__s16\toff; /* signed offset */\t__s32\timm; /* signed immediate constant */; This bpf_insn structure is 64 bits (or 8 bytes) long. When loaded into the kernel, the bytecode of an eBPF program is represented by a series of these bpf_insn structures. 3.2 eBPF “Hello World” for a Network Interface#include linux/bpf.h#include bpf/bpf_helpers.hint counter = 0;SEC(xdp)int hello(struct xdp_md *ctx) bpf_printk(Hello World %d, counter); counter++; return XDP_PASS;char LICENSE[] SEC(license) = Dual BSD/GPL; XDP_PASS: This is the verdict indicating to the kernel that it should process this network packet as normal. 3.3 Compiling an eBPF Object File Makefile: %.bpf.o: %.bpf.c\tclang \\ -target bpf \\ -I/usr/include/$(shell uname -m)-linux-gnu \\ -g \\ -O2 -o $@ -c $ 3.4 Inspecting an eBPF Object File$ llvm-objdump -S hello.bpf.o 3.5 Loading the Program into the Kernel$ bpftool prog load hello.bpf.o /sys/fs/bpf/hello$ ls /sys/fs/bpfhello 3.6 Inspecting the Loaded Program$ bpftool prog list $ bpftool prog show id 540 --pretty id: 540, type: xdp, name: hello, tag: d35b94b4c0c10efb, gpl_compatible: true, loaded_at: 1659461987, uid: 0, bytes_xlated: 96, jited: true, bytes_jited: 148, bytes_memlock: 4096, map_ids: [165,166 ], btf_id: 254 3.6.1 The BPF Program TagThe ID can vary every time you load or unload the program, but the tag will remain the same. bpftool prog show id 540bpftool prog show name hellobpftool prog show tag d35b94b4c0c10efbbpftool prog show pinned /sys/fs/bpf/hello 3.6.2 The Translated Bytecode$ bpftool prog dump xlated name helloint hello(struct xdp_md * ctx):; bpf_printk(Hello World %d, counter); 0: (18) r6 = map[id:165][0]+0 2: (61) r3 = *(u32 *)(r6 +0) 3: (18) r1 = map[id:166][0]+0 5: (b7) r2 = 15 6: (85) call bpf_trace_printk#-78032; counter++; 7: (61) r1 = *(u32 *)(r6 +0) 8: (07) r1 += 1 9: (63) *(u32 *)(r6 +0) = r1; return XDP_PASS; 10: (b7) r0 = 2 11: (95) exit 3.6.3 The JIT-Compiled Machine Code$ bpftool prog dump jited name helloint hello(struct xdp_md * ctx):bpf_prog_d35b94b4c0c10efb_hello:; bpf_printk(Hello World %d, counter); 0: hint #34 4: stp x29, x30, [sp, #-16]! 8: mov x29, sp c: stp x19, x20, [sp, #-16]! 10: stp x21, x22, [sp, #-16]! 14: stp x25, x26, [sp, #-16]! 18: mov x25, sp 1c: mov x26, #0 20: hint #36 24: sub sp, sp, #0 28: mov x19, #-140733193388033 2c: movk x19, #2190, lsl #16 30: movk x19, #49152 34: mov x10, #0 38: ldr w2, [x19, x10] 3c: mov x0, #-205419695833089 40: movk x0, #709, lsl #16 44: movk x0, #5904 48: mov x1, #15 4c: mov x10, #-6992 50: movk x10, #29844, lsl #16 54: movk x10, #56832, lsl #32 58: blr x10 5c: add x7, x0, #0; counter++; 60: mov x10, #0 64: ldr w0, [x19, x10] 68: add x0, x0, #1 6c: mov x10, #0 70: str w0, [x19, x10]; return XDP_PASS; 74: mov x7, #2 78: mov sp, sp 7c: ldp x25, x26, [sp], #16 80: ldp x21, x22, [sp], #16 84: ldp x19, x20, [sp], #16 88: ldp x29, x30, [sp], #16 8c: add x0, x7, #0 90: ret 3.7 Attaching to an Event$ bpftool net attach xdp id 540 dev eth0 view all the network-attached eBPF programs: $ bpftool net listxdp:eth0(2) driver id 540tc:flow_dissector: $ ip link trace output: $ cat /sys/kernel/debug/tracing/trace_pipe or: $ bpftool prog tracelog 3.8 Global Variables$ bpftool map list165: array name hello.bss flags 0x400 key 4B value 4B max_entries 1 memlock 4096B btf_id 254166: array name hello.rodata flags 0x80 key 4B value 15B max_entries 1 memlock 4096B btf_id 254 frozen inspect its contents: $ bpftool map dump name hello.bss[ value: .bss: [ counter: 11127 ] ] bpftool is able to pretty-print the field names from a map (here, the variable name counter) only if BTF information is available, and that information is included only if you compile with the -g flag. $ bpftool map dump name hello.rodata[ value: .rodata: [ hello.____fmt: Hello World %d ] ] 3.9 Detaching the Program$ bpftool net detach xdp dev eth0 However, the program is still loaded into the kernel: $ bpftool prog show name hello395: xdp name hello tag 9d0e949f89f1a82c gpl loaded_at 2022-12-19T18:20:32+0000 uid 0 xlated 48B jited 108B memlock 4096B map_ids 4 3.10 Unloading the Program$ rm /sys/fs/bpf/hello$ bpftool prog show name hello 3.11 BPF to BPF Callsa very simple function that extracts the syscall opcode from the tracepoint arguments: static __attribute((noinline)) int get_opcode(struct bpf_raw_tracepoint_args *ctx) return ctx-args[1]; The eBPF function that calls this function looks like this: SEC(raw_tp)int hello(struct bpf_raw_tracepoint_args *ctx) int opcode = get_opcode(ctx); bpf_printk(Syscall: %d, opcode); return 0; $ bpftool prog load hello-func.bpf.o /sys/fs/bpf/hello$ bpftool prog list name hello893: raw_tracepoint name hello tag 3d9eb0c23d4ab186 gpl loaded_at 2023-01-05T18:57:31+0000 uid 0 xlated 80B jited 208B memlock 4096B map_ids 204 btf_id 302 The interesting part of this exercise is inspecting the eBPF bytecode to see the get_opcode() function $ bpftool prog dump xlated name helloint hello(struct bpf_raw_tracepoint_args * ctx):; int opcode = get_opcode(ctx); # 1 0: (85) call pc+7#bpf_prog_cbacc90865b1b9a5_get_opcode; bpf_printk(Syscall: %d, opcode); 1: (18) r1 = map[id:193][0]+0 3: (b7) r2 = 12 4: (bf) r3 = r0 5: (85) call bpf_trace_printk#-73584; return 0; 6: (b7) r0 = 0 7: (95) exitint get_opcode(struct bpf_raw_tracepoint_args * ctx): # 2; return ctx-args[1]; 8: (79) r0 = *(u64 *)(r1 +8); return ctx-args[1]; 9: (95) exit 3.12 Summarytodo 3.13 Exercisestodo"},{"title":"04. The bpf() System Call","path":"/wiki/ebpf/learning-ebpf-04.html","content":"the eBPF code running in the kernel does not use syscalls to access maps. eBPF programs use helper functions to read and write to maps bpf()’s signature: int bpf(int cmd, union bpf_attr *attr, unsigned int size); cmd, specifies which command to perform. attr, whatever data is needed to specify the parameters for the command size, how many bytes of data there are in attr struct user_msg_t // 1 char message[12];;BPF_HASH(config, u32, struct user_msg_t); // 2BPF_PERF_OUTPUT(output); // 3struct data_t // 4 int pid; int uid; char command[16]; char message[12];;int hello(void *ctx) // 5 struct data_t data = ; struct user_msg_t *p; char message[12] = Hello World; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); p = config.lookup(data.uid); // 6 if (p != 0) bpf_probe_read_kernel(data.message, sizeof(data.message), p-message); else bpf_probe_read_kernel(data.message, sizeof(data.message), message); output.perf_submit(ctx, data, sizeof(data)); return 0; the bpf() system calls that are used when it runs $ strace -e bpf ./hello-buffer-config.py 4.1 Loading BTF Data loading a blob of BTF data into the kernel the return code from the bpf() system call (3 in my example) is a file descriptor that refers to that data bpf(BPF_BTF_LOAD, btf=\\237\\353\\1\\0... , 40) = 3 BTF allows eBPF programs to be portable across different kernel versions so that you can compile a program on one machine and use it on another, which might be using a different kernel version and hence have different kernel data structures. 4.2 Creating Maps creates an eBPF map bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_PERF_EVENT_ARRAY, key_size=4, value_size=4, max_entries=22, ... map_name=output, ..., 80) = 4 bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_HASH, key_size=4, value_size=13, max_entries=10240, ... map_name=config, ... btf_fd=3, ..., 80) = 5 4.3 Loading a Programbpf(BPF_PROG_LOAD, prog_type=BPF_PROG_TYPE_KPROBE, insn_cnt=47, insns=0x7408c9814000, license=GPL, ... prog_name=hello, ... expected_attach_type=BPF_CGROUP_INET_INGRESS, prog_btf_fd=3, ..., 152) = 6 4.4 Modifying a Map from User Spaceb[config][ct.c_int(0)] = ct.create_string_buffer(bHey root!)b[config][ct.c_int(501)] = ct.create_string_buffer(bHi user 501!) You can see these entries being defined in the map through syscalls like this: bpf(BPF_MAP_UPDATE_ELEM, map_fd=5, key=0x7408c92a9020, value=0x7408c92a8520, flags=BPF_ANY, 32) = 0 use bpftool to view the map’s contents bpftool map dump name config [ key: 0, value: message: Hey root! , key: 501, value: message: Hi user 501! ] 4.5 BPF Program and Map References reference counts When there are no references left to a BPF program, the kernel removes the program. An additional reference is created when you pin a program to the filesystem. 4.5.1 Pinningbpftool prog load hello.bpf.o /sys/fs/bpf/hello These pinned objects aren’t real files persisted to disk. They are held in memory, which means they will not remain in place over a system reboot. Programs that are attached within the network stack or cgroups (short for “control groups”) aren’t associated with any user space process, so they stay in place even after the user space program that loads them exits. ip link set dev eth0 xdp obj hello.bpf.o sec xdp 4.5.2 BPF LinksAnother way to create a reference to a BPF program BPF links provide a layer of abstraction between an eBPF program and the event it’s attached to. 4.6 Additional Syscalls Involved in eBPF4.6.1 Initializing the Perf Buferbpf(BPF_MAP_UPDATE_ELEM, map_fd=4, key=0x770d75d708a0, value=0x770d75d70520, flags=BPF_ANY, 32) = 0 strace to show a few more syscalls when running this example, strace -e bpf,perf_event_open,ioctl,ppoll ./hello-buffer-config.py 4.6.2 Attaching to Kprobe Eventsa file descriptor representing that particular event perf_event_open(type=0x8 /* PERF_TYPE_??? */, ..., ...) = 7 the value 6 to indicate that it’s a kprobe type of perf event $ cat /sys/bus/event_source/devices/kprobe/type attaching a Berkeley Packet Filter (BPF) program to an existing kprobe tracepoint event: ioctl(7, PERF_EVENT_IOC_SET_BPF, 6) = 0 turns the kprobe event on: ioctl(7, PERF_EVENT_IOC_ENABLE, 0) = 0 4.6.3 Setting Up and Reading Perf EventsNOTE:与使用的处理器的核心数量有关 perf_event_open(type=PERF_TYPE_SOFTWARE, size=0 /* PERF_ATTR_SIZE_??? */, config=PERF_COUNT_SW_BPF_OUTPUT, ..., -1, X, -1, PERF_FLAG_FD_CLOEXEC) = 8ioctl(Y, PERF_EVENT_IOC_ENABLE, 0) = 0bpf(BPF_MAP_UPDATE_ELEM, map_fd=4, key=0x7644407f88a0, value=0x7644407f8520, flags=BPF_ANY, 32) = 0 User space code can then use ppoll() on all four of these output stream file descriptors so that it can get the data output ppoll([fd=8, events=POLLIN, fd=9, events=POLLIN, fd=10, events=POLLIN,fd=11, events=POLLIN], 4, NULL, NULL, 0) = 1 ([fd=8, revents=POLLIN]) You won’t see the return code written to the screen until something triggers execve(), which causes the eBPF program to write data that user space retrieves using this ppoll() call. 4.7 Ring Bufersring buffers are preferred over perf buffers partly for performance reasons The bpf() syscall that creates the output ring buffer map: bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_RINGBUF, key_size=0, value_size=0, max_entries=4096, ..., map_name=output, ..., 80) = 4 For a ring buffer, there’s just the one file descriptor shared across all CPU cores. 4.8 Reading Information from a Mapan extract of the bpf() syscalls that bpftool makes while reading the contents of the config map: strace -e bpf bpftool map dump name config 4.8.1 Finding a Mapbpftool walks through all the maps looking for any with the name config bpf(BPF_MAP_GET_NEXT_ID, start_id=0, ..., 12) = 0bpf(BPF_MAP_GET_FD_BY_ID, map_id=25, ..., 12) = 3bpf(BPF_OBJ_GET_INFO_BY_FD, info=bpf_fd=3, ..., 16) = 0bpf(BPF_MAP_GET_NEXT_ID, start_id=25, ..., 12) = 0bpf(BPF_MAP_GET_FD_BY_ID, map_id=26, ..., 12) = 3bpf(BPF_OBJ_GET_INFO_BY_FD, info=bpf_fd=3, ..., 16) = 0 4.8.2 Reading Map Elementsbpf(BPF_MAP_GET_NEXT_KEY, map_fd=3, key=NULL, next_key=0x5897d6dd81c0, 24) = 0bpf(BPF_MAP_LOOKUP_ELEM, map_fd=3, key=0x5897d6dd81c0, value=0x5897d6dd81e0, flags=BPF_ANY, 32) = 0 [ key: 0, value: message: Hey root! bpf(BPF_MAP_GET_NEXT_KEY, map_fd=3, key=0x5897d6dd81c0, next_key=0x5897d6dd81c0, 24) = -1 ENOENT (No such file or directory) ]+++ exited with 0 +++ 4.9 Summarytodo 4.10 Exercisestodo QA 我在运行 strace -e bpf,perf_event_open,ioctl,ppoll ./hello-buffer-config.py 时，并没有看到 ppoll 的相关调用 可能调用的是 poll poll([fd=8, events=POLLIN, fd=9, events=POLLIN, ...], 22, -1) = 1 ([fd=23, revents=POLLIN])"},{"title":"05. CO-RE, BTF, and Libbpf","path":"/wiki/ebpf/learning-ebpf-05.html","content":"compile once, run everywhere (CO-RE) It allows eBPF programs to include information about the data structure layouts they were compiled with, and it provides a mechanism for adjusting how fields are accessed if the data structure layout is different on the target machine where they run. 5.1 BCC’s Approach to PortabilityTo address portability across kernels, BCC took the approach of compiling eBPF code at runtime, in situ on the destination machine. 5.2 CO-RE Overview BTF BTF is a format for expressing the layout of data structures and function signatures. Linux kernels from 5.4 onward support BTF. Kernel headers you can use bpftool to generate a header file called vmlinux.h from a running system, containing all the data structure information about a kernel that a BPF program might need. Compiler support The Clang compiler with the -g flag The GCC compiler version 12 Library support for data structure relocations libbpf was the original C library that includes this relocation capability the Cilium eBPF library provides the same capability for Go programmers Aya does it for Rust Optionally, a BPF skeleton If you’re writing the user space code in C, you can generate the skeleton with bpftool gen skeleton. 5.3 BPF Type FormatBTF information describes how data structures and code are laid out in memory. 5.3.1 BTF Use Casesbpftool used BTF information to format the output of map dumps. BTF information also includes the line and function information that enables bpftool to interleave source code within the output from translated or JITed program dumps. ( Chapter 3) the source code information interleaved with the verifier log output. (Chapter 6) BTF information is also required for BPF spin locks. 5.3.2 Listing BTF Information with bpftoollists all the BTF data loaded into the kernel: bpftool btf list 1: name [vmlinux] size 6050732B2: name [tun] size 78483B3: name [ip_tables] size 54242B4: name [llc] size 37035B5: name [stp] size 36698B6: name [bridge] size 526851B7: name [br_netfilter] size 87947B8: name [autofs4] size 28681B9: name [configfs] size 49125B10: name [sch_fq_codel] size 56146B11: name [ac] size 556B12: name [battery] size 10709B13: name [crc32c_intel] size 505B14: name [irqbypass] size 943B15: name [kvm] size 210513B16: name [kvm_intel] size 66832B17: name [intel_rapl_common] size 12653B18: name [intel_rapl_msr] size 10427B28: name anon size 40669B pids bpftool(1749) The first entry in the list is vmlinux, and it corresponds to the vmlinux file I mentioned earlier that holds the BTF information about the currently running kernel. 5.3.3 BTF Types$ cd learning-ebpf/chapter4$ ./hello-buffer-config.py $ bpftool btf list51: name anon size 2292B prog_ids 50 map_ids 16 pids hello-buffer-co(3510) $ bpftool prog show name hello50: kprobe name hello tag ce68c6b13b45c753 gpl loaded_at 2025-11-11T11:01:07+0800 uid 0 xlated 392B jited 216B memlock 4096B map_ids 16,15 btf_id 51 pids hello-buffer-co(3510) Knowing the ID of the BTF information, you can inspect its contents with the command bpftool btf dump id . $ bpftool btf dump id 51 struct user_msg_t char message[13];;BPF_HASH(config, u32, struct user_msg_t); [1] TYPEDEF u32 type_id=2[2] TYPEDEF __u32 type_id=3[3] INT unsigned int size=4 bits_offset=0 nr_bits=32 encoding=(none) All three of these types are synonyms for a 32-bit unsigned integer type. [4] STRUCT user_msg_t size=13 vlen=1 message type_id=6 bits_offset=0[5] INT char size=1 bits_offset=0 nr_bits=8 encoding=SIGNED[6] ARRAY (anon) type_id=5 index_type_id=7 nr_elems=13[7] INT __ARRAY_SIZE_TYPE__ size=4 bits_offset=0 nr_bits=32 encoding=(none)[8] STRUCT ____btf_map_config size=20 vlen=2 key type_id=1 bits_offset=0 value type_id=4 bits_offset=32 5.3.4 Maps with BTF Informationmaps are created using the bpf(BPF_MAP_CREATE) syscall. The ____btf_map_config structure that you just saw defined isn’t used by the kernel for the map definition; it’s just used by BCC on the user space side. 5.3.5 BTF Data for Functions and Function Prototypesint hello(void *ctx) [11] FUNC_PROTO (anon) ret_type_id=12 vlen=1 ctx type_id=10[12] INT int size=4 bits_offset=0 nr_bits=32 encoding=SIGNED[13] FUNC hello type_id=11 linkage=static 5.3.6 Inspecting BTF Data for Maps and Programsinspect the BTF types associated with a particular map bpftool btf dump map name config inspect the BTF information related to a particular program bpftool btf dump prog id 51bpftool btf dump prog name hello 5.4 Generating a Kernel Header Fileas BTF-enabled tools can generate an appropriate header file from the BTF information included with the kernel. This header file is conventionally called vmlinux.h, and you can generate it with bpftool like this: bpftool btf dump file /sys/kernel/btf/vmlinux format c vmlinux.h This file defines all the kernel’s data types, so including this generated vmlinux.h file in your eBPF program source supplies the definitions of any Linux data structures you might need. BTF information in the form of the syskernelbtfvmlinux file has been included in the Linux kernel since version 5.4. 5.5 CO-RE eBPF ProgramsNOTE:在 learning-ebpfchapter5 目录下执行如下命令: bpftool btf dump file syskernelbtfvmlinux format c vmlinux.h hello-bufer-config.bpf.c, which implements the eBPF program that runs in the kernel hello-bufer-config.c that loads the program and displays output 5.5.1 Header FilesThe first few lines of hello-bufer-config.bpf.c specify the header files that it needs: #include vmlinux.h#include bpf/bpf_helpers.h#include bpf/bpf_tracing.h#include bpf/bpf_core_read.h#include hello-buffer-config.h Kernel header information: If you’re going to use any BPF helper functions from libbpf, you’ll need to include either vmlinux.h or linuxtypes.h to get the definitions for types like u32, u64, and so on, that the BPF helper source refers to. The vmlinux.h file is derived from the kernel source headers, but it doesn’t include #define’d values from them. if your eBPF program parses Ethernet packets, There is a series of constant values that you’ll need to duplicate in your own code, if you don’t include the if_ether.h file that defines these values for the kernel. Headers from libbpf: To use any BPF helper functions in your eBPF code, you’ll need to include the header files from libbpf that give you their definitions. At the time of this writing, it is common to see eBPF projects including libbpf as a submodule and buildinginstalling from source. If you include it as a submodule, you’ll simply need to run make install from the libbpfsrc directory. Application-speciic headers: It’s very common to have an application-specific header file that defines any structures that are used by both the user space and eBPF parts of your app. 5.5.2 Deining Mapsstruct __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY); __uint(key_size, sizeof(u32)); __uint(value_size, sizeof(u32)); output SEC(.maps);struct user_msg_t char message[12];;struct __uint(type, BPF_MAP_TYPE_HASH); __uint(max_entries, 10240); __type(key, u32); __type(value, struct user_msg_t); my_config SEC(.maps); 5.5.3 eBPF Program SectionsUse of libbpf requires each eBPF program to be marked with a SEC() macro that defines the program type: libbpf can make life even easier for you with the k(ret)syscall section name, which tells the loader to attach to the kprobe in the architecture-specific function automatically SEC(ksyscall/execve)int BPF_KPROBE_SYSCALL(hello, const char *pathname) struct data_t data = ; struct user_msg_t *p; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); bpf_probe_read_user_str(data.path, sizeof(data.path), pathname); p = bpf_map_lookup_elem(my_config, data.uid); if (p != 0) bpf_probe_read_kernel_str(data.message, sizeof(data.message), p-message); else bpf_probe_read_kernel_str(data.message, sizeof(data.message), message); bpf_perf_event_output(ctx, output, BPF_F_CURRENT_CPU, data, sizeof(data)); return 0; The ctx variable does exist, hidden within the BPF_KPROBE_SYSCALL macro definition inside bpfbpf_tracing.h, in libbpf, where you’ll also find some commentary about this. 5.5.4 Memory Access with CO-REeBPF programs for tracing have restricted access to memory, via a BPF helper function from the bpf_probe_read_*() family. the eBPF verifier generally won’t let you simply read memory through a pointer as you usually can in C (e.g., x p-y) if you wanted to do something like d a-b-c-d, you could write the following code: struct b_t *b;struct c_t *c;bpf_core_read(b, 8, a-b);bpf_core_read(c, 8, b-c);bpf_core_read(d, 8, c-d); But it’s much more compact to use: d = BPF_CORE_READ(a, b, c, d); 5.5.5 License Deinitionchar LICENSE[] SEC(license) = Dual BSD/GPL; 5.6 Compiling eBPF Programs for CO-RE5.6.1 Debug InformationYou have to pass the -g flag to Clang so that it includes debug information, which is necessary for BTF the -g flag also adds DWARF debugging information to the output object file, you can reduce the size of the object by running the following command to strip it out llvm-strip -g object file 5.6.2 OptimizationThe -O2 optimization flag (level 2 or higher) is required for Clang to produce BPF bytecode that will pass the verifier. by default, Clang will output callx to call helper functions, but eBPF doesn’t support calling addresses from registers. 5.6.3 Target ArchitectureThe libbpf header file bpfbpf_tracing.h defines several macros that are platform specific, such as BPF_KPROBE and BPF_KPROBE_SYSCALL. you’ll need to also tell the compiler what the target architecture is. You can do this by setting -D __TARGET_ARCH_($ARCH) where $ARCH is an architecture name like arm64, amd64, and so on. 5.6.4 MakeileThe following is an example Makefile instruction for compiling CO-RE objects: hello-buffer-config.bpf.o: %.o: %.c clang \\ -target bpf \\ -D __TARGET_ARCH_$(ARCH) \\ -I/usr/include/$(shell uname -m)-linux-gnu \\ -Wall \\ -O2 -g \\ -c $ -o $@ llvm-strip -g $@ 5.6.5 BTF Information in the Object File .BTF, which contains the data and string information .BTF.ext, which covers function and line information readelf -S hello-buffer-config.bpf.o | grep BTF [ 8] .BTF PROGBITS 0000000000000000 000003b0 [ 9] .rel.BTF REL 0000000000000000 000010a8 [10] .BTF.ext PROGBITS 0000000000000000 00000ca4 [11] .rel.BTF.ext REL 0000000000000000 000010f8 examine the BTF data from an object file: bpftool btf dump file hello-buffer-config.bpf.o 5.7 BPF Relocationslibbpf needs the BPF CO-RE relocation information generated by Clang as part of the compilation process. You can learn more about how the relocations work from the definition of struct bpf_core_relo in the linuxbpf.h header file: struct bpf_core_relo __u32 insn_off; __u32 type_id; __u32 access_str_off; enum bpf_core_relo_kind kind;; The bpf_core_relo structure for that instruction (identified by the insn_off field) encodes the BTF type of that structure (the type_id field) and also indicates how the field is accessed relative to that structure (access_str_off). the relocation data for the kernel data structures is generated automatically by Clang and encoded in the ELF object file. It’s the following line, which you’ll find near the start of the vmlinux.h file, that causes Clang to do this #pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record) You can see the relocations taking place when you load a BPF program, by using bpftool and turning on the debug information with the -d flag, like this: bpftool -d prog load hello.bpf.o /sys/fs/bpf/hello 5.8 CO-RE User Space Codeyou’ll want to build this functionality into a dedicated user space program that you supply as an executable. 5.9 The Libbpf Library for User SpaceThis library provides functions that wrap the bpf() and related syscalls that you met in Chapter 4 to perform operations like loading programs into the kernel and attaching them to events, or accessing map information from user space. The conventional and easiest way to use these abstractions is through auto-generated BPF skeleton code. 5.9.1 BPF SkeletonsYou can use bpftool to auto-generate this skeleton code from existing eBPF objects in ELF file format, like this: bpftool gen skeleton hello-buffer-config.bpf.o hello-buffer-config.skel.h Loading programs and maps into the kernel skel = hello_buffer_config_bpf__open_and_load(); These two phases can easily be handled separately, as the skeleton code provides separate name__open() and name__load() functions. This gives you the option to manipulate the eBPF information before loading it. skel = hello_buffer_config_bpf__open();if (!skel) // Error ...skel-data-c = 10;err = hello_buffer_config_bpf__load(skel); Accessing existing mapssometimes you might want to write an eBPF program that reuses an existing map Another common reason to use a map is to share information between two different eBPF programs struct bpf_map_info info = ; unsigned int len = sizeof(info); int findme = bpf_obj_get(/sys/fs/bpf/findme);if (findme = 0) printf(No FD ); else bpf_obj_get_info_by_fd(findme, info, len); printf(name %s , info.name); To try this out you can create a map using bpftool, like this: bpftool map create /sys/fs/bpf/findme type array key 4 value 32 entries 4 name findme Attaching to eventsattaches the program to the execve syscall function err = hello_buffer_config_bpf__attach(skel); If you didn’t define the attachment point fully, there are a whole series of libbpf functions, such as bpf_program__attach_kprobe, bpf_program__attach_xdp, and so on, for attaching different program types. Managing an event buferpb = perf_buffer__new(bpf_map__fd(skel-maps.output), 8, handle_event, lost_event, NULL, NULL); The handle_event argument is a callback function that gets called when new data arrives in the perf buffer lost_event gets called if there isn’t enough room in the perf buffer for the kernel to write a data entry Finally, the program has to poll the perf buffer repeatedly: while (true) err = perf_buffer__poll(pb, 100); ... The 100 is a timeout in milliseconds. to clean up I free the perf buffer and destroy the eBPF programs and maps in the kernel perf_buffer__free(pb);hello_buffer_config_bpf__destroy(skel); 5.9.2 Libbpf Code Examples The libbpf-bootstrap project is intended to help you get off the ground with a set of example programs. The BCC project has many of the original BCC-based tools migrated to a libbpf version. You’ll find them in the libbpf-tools directory. 5.10 SummaryIn this chapter you saw how CO-RE achieves this by encoding type information into the compiled object file and using relocations to rewrite instructions as they are loaded into the kernel. 5.11 Exercisestodo"},{"title":"06. The eBPF Veriier","path":"/wiki/ebpf/learning-ebpf-06.html","content":"the verifier works on eBPF bytecode, not directly on the source. That bytecode depends on the output from the compiler. 6.1 The Verification ProcessAs it goes along it keeps track of the state of each register in a structure called bpf_reg_state. This structure includes a field called bpf_reg_type, which describes what type of value is held in that register. NOT_INIT, indicating that the register has not yet been set to a value. SCALAR_VALUE, indicating that the register has been set to a value that doesn’t represent a pointer Several PTR_TO_* types, indicating that the register holds a pointer to something. PTR_TO_CTX: The register holds a pointer to the context passed as the argument to a BPF program. PTR_TO_PACKET: The register points to a network packet (held in the kernel as skb-data). PTR_TO_MAP_KEY or PTR_TO_MAP_VALUE There are several other PTR_TO_* types, and you can find the full set enumerated in the linuxbpf.h header file. 6.2 The Verifier LogWhen the verification of a program fails, the verifier generates a log showing how it reached the conclusion that the program is invalid. If you’re using bpftool prog load, the verifier log gets output to stderr. When you’re writing a program with libbpf, you can use the function libbpf_set_print() to set a handler that will display (or do something else useful with) any errors. When an eBPF program is called, Register 1 always holds the context argument passed to the program. Register 0 is used for the return value from a helper function and also for the return value from an eBPF program. Register 10 always holds a pointer to the eBPF stack frame (and the eBPF program can’t modify it). 6.3 Visualizing Control Flowbpftool prog dump xlated name kprobe_exec visual out.dotdot -Tpng out.dot out.png 6.4 Validating Helper FunctionsYou’re not allowed to call directly from eBPF programs to any kernel function, but eBPF provides a number of helper functions that enable programs to access information from the kernel. Different helper functions are valid for different BPF program types. 6.5 Helper Function Argumentsconst struct bpf_func_proto bpf_map_lookup_elem_proto = .func = bpf_map_lookup_elem,\t.gpl_only\t= false,\t.pkt_access\t= true,\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\t.arg1_type\t= ARG_CONST_MAP_PTR,\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,; This structure defines the constraints for arguments to and return values from the helper function. 6.6 Checking the LicenseThe verifier also checks that if you are using a BPF helper function that’s licensed under GPL, your program also has a GPL-compatible license. 6.7 Checking Memory Accessan XDP program is only permitted to access the memory locations that make up that network packet. SEC(xdp)int xdp_load_balancer(struct xdp_md *ctx) void *data = (void *)(long)ctx-data; void *data_end = (void *)(long)ctx-data_end;... 6.8 Checking Pointers Before Dereferencing ThemThe eBPF verifier requires all pointers to be checked before they are dereferenced so that this type of crash can’t happen. Some helper functions incorporate the pointer check for you. long bpf_probe_read_kernel(void *dst, u32 size, const void *unsafe_ptr) The third argument to this function is called unsafe_ptr. This is an example of a BPF helper function that helps programmers write safe code by handling checks for you. 6.9 Accessing ContextEvery eBPF program is passed some context information as an argument, but depending on the program and attachment type, it may be allowed to access only some of that context information. 6.10 Running to CompletionIf the verifier hasn’t reached the end of the BPF program before it has processed this many instructions, it rejects the program. 6.11 LoopsFrom version 5.3 onward the verifier follows branches backward as well as forward as part of its process of checking all the possible execution paths. This means it can accept some loops, provided the execution path remains within the limit of one million instructions. In version 5.17 a new helper function, bpf_loop(), was introduced that makes it much easier for the verifier not only to accept loops but also to do it in a much more efficient way. There’s also a helper function bpf_for_each_map_elem() that calls a provided callback function for each item in a map. 6.12 Checking the Return CodeThe return code from an eBPF program is stored in Register 0 (R0). Register 0 is also used to hold the return code from a helper function. After returning from a helper function in an eBPF program, Register 0 is no longer uninitialized. 6.13 Invalid InstructionsThe verifier checks that the instructions in a program are valid bytecode instructions—for example, using only known opcodes. 6.14 Unreachable InstructionsThe verifier also rejects programs that have unreachable instructions. Oftentimes, these will get optimized out by the compiler anyway. 6.15 SummaryThe verifier keeps track of the types and possible range of values for each register to ensure that eBPF programs are safe to run. 6.16 Exercisestodo"},{"title":"07. eBPF Program and Attachment Types","path":"/wiki/ebpf/learning-ebpf-07.html","content":"There are currently around 30 program types enumerated in uapilinuxbpf.h, and more than 40 attachment types. 7.1 Program Context ArgumentsAll eBPF programs take a context argument that is a pointer, but the structure it points to depends on the type of event that triggered it. Defining different types of programs allows the verifier to ensure that the contextual information is handled appropriately and to enforce rules about what helper functions are permissible. 7.2 Helper Functions and Return Codesthe verifier checks that all helper functions used by a program are compatible with its program type. The program type also determines the meaning of the return code from the program. Again using XDP as an example, the return code value tells the kernel what to do with the packet once the eBPF program has finished processing it—which could involve passing it to the network stack, dropping it, or redirecting it to a different interface. get a list of which helper functions are available for each program type in your version of the kernel: bpftool feature 7.3 Kfuncsbe able to access some internal functions from eBPF programs. This can be achieved using the mechanism called BPF kernel functions, or kfuncs Kfuncs allow internal kernel functions to be registered with the BPF subsystem so that the verifier will allow them to be called from eBPF programs. the type of an eBPF program determines what events it can be attached to, which in turn defines the type of context information it receives. The program type also defines the set of helper functions and kfuncs it can call. 7.4 TracingProgram types are broadly considered to fall into two categories: tracing (or perf) program types and networking-related program types. Programs that attach to kprobes, tracepoints, raw tracepoints, fentryfexit probes, and perf events were all designed to provide an efficient way for eBPF programs in the kernel to report tracing information about events into user space. view programs attached to perf-related events: bpftool perf showbpftool pert list 7.4.1 Kprobes and KretprobesYou can attach kprobe programs almost anywhere in the kernel. Commonly, they are attached using kprobes to the entry to a function and kretprobes to the exit of a function. Attaching kprobes to syscall entry pointsThe first example eBPF program for this chapter is called kprobe_sys_execve, and it is a kprobe attached to the execve() syscall. SEC(ksyscall/execve)int BPF_KPROBE_SYSCALL(kprobe_sys_execve, const char *pathname) Attaching kprobes to other kernel functionskprobes can also be attached to any noninlined function in the kernel SEC(kprobe/do_execve)int BPF_KPROBE(kprobe_do_execve, struct filename *filename) 7.4.2 FentryFexitIf you’re using a recent enough kernel, fentryfexit is now the preferred method for tracing the entry to or exit from a kernel function. SEC(fentry/do_execve)int BPF_PROG(fentry_execve, struct filename *filename) the fexit hook has access to the input parameters to the function, which kretprobe does not. an example of this: https://github.com/libbpf/libbpf-bootstrap/blob/master/examples/c/fentry.bpf.c 7.4.3 TracepointsTracepoints are marked locations in the kernel code. tracepoints are stable between kernel releases. see the available set of tracing subsystems on your kernel cat /sys/kernel/tracing/available_events gets hit when the kernel starts processing an execve() call. SEC(tp/syscalls/sys_enter_execve)int tp_sys_enter_execve(struct my_syscalls_enter_execve *ctx) Each tracepoint has a format describing the fields that get traced out from it. cat /sys/kernel/tracing/events/syscalls/sys_enter_execve/format name: sys_enter_execveID: 761format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:const char * filename; offset:16; size:8; signed:0; field:const char *const * argv; offset:24; size:8; signed:0; field:const char *const * envp; offset:32; size:8; signed:0;print fmt: filename: 0x%08lx, argv: 0x%08lx, envp: 0x%08lx, ((unsigned long)(REC-filename)), ((unsigned long)(REC-argv)), ((unsigned long)(REC-envp)) I used this information to define a matching structure called my_syscalls_enter_execve struct my_syscalls_enter_execve unsigned short common_type; unsigned char common_flags; unsigned char common_preempt_count; int common_pid;\tlong syscall_nr;\tvoid *filename_ptr;\tlong argv_ptr;\tlong envp_ptr;; eBPF programs aren’t allowed to access the first four of these fields. If you try to access them, the program will fail verification with an invalid bpf_context access error. 7.4.4 BTF-Enabled TracepointsWith BTF support, there will be a structure defined in vmlinux.h that matches the context structure passed to a tracepoint eBPF program. SEC(tp_btf/sched_process_exec)int handle_exec(struct trace_event_raw_sched_process_exec *ctx) 7.4.5 User Space Attachmentsuprobes and uretprobes for attaching to the entry and exit of user space functions, and user statically defined tracepoints (USDTs) for attaching to specified tracepoints within application code or user space libraries. These all use the BPF_PROG_TYPE_KPROBE program type. to attach a uprobe to the start of the SSL_write() function in OpenSSL, you would define the section for the eBPF program with the following: SEC(uprobe/usr/lib/aarch64-linux-gnu/libssl.so.3/SSL_write) 7.4.6 LSMBPF_PROG_TYPE_LSM programs are attached to the Linux Security Module (LSM) API, which is a stable interface within the kernel originally intended for kernel modules to use to enforce security policies. BPF_PROG_TYPE_LSM programs are attached using bpf(BPF_RAW_TRACEPOINT_OPEN), and in many ways they are treated like tracing programs. the return value affects the way the kernel behaves. A nonzero return code indicates that the security check wasn’t passed, so the kernel won’t proceed with whatever operation it was asked to complete. 7.5 NetworkingThese program types all require CAP_NET_ADMIN and CAP_BPF, or CAP_SYS_ADMIN, capabilities to be permitted. The context passed to these types of programs is the network message in question, although the type of structure depends on the data the kernel has at the relevant point in the network stack. Layer 7 covers formats intended for applications to use, such as HTTP, DNS, or gRPC; TCP is at Layer 4; IP is at Layer 3; and Ethernet and WiFi are at Layer 2. 7.5.1 Sockets BPF_PROG_TYPE_SOCKET_FILTER was the first program type to be added to the kernel. It’s used to filter a copy of socket data that can be sent to an observability tool such as tcpdump. A socket is specific to a Layer 4 (TCP) connection. BPF_PROG_TYPE_SOCK_OPS allows eBPF programs to intercept various operations and actions that take place on a socket, and to set for that socket parameters such as TCP timeout values. BPF_PROG_TYPE_SK_SKB programs are used in conjunction with a special map type that holds a set of references to sockets to provide what’s known as sockmap operations: redirecting traffic to different destinations at the socket layer. 7.5.2 Traic ControleBPF programs can be attached to provide custom filters and classifiers for network packets for both ingress and egress traffic. 7.5.3 XDPXDP (eXpress Data Path) The roughly equivalent command for loading and attaching the program to eth0 would be this: ip link set dev eth0 xdp obj hello.bpf.o sec xdp Removing the XDP program with ip link can be done like this: ip link set dev eth0 xdp off 7.5.4 Flow DissectoreBPF programs of type BPF_PROG_TYPE_FLOW_DISSECTOR can implement custom packet dissection. 7.5.5 Lightweight TunnelsThe family of BPF_PROG_TYPE_LWT_* program types can be used to implement network encapsulation in eBPF programs. 7.5.6 Cgroups control groups Cgroups are a concept in the Linux kernel that restricts the set of resources a given process or group of processes can have access to. Attaching eBPF programs to a cgroup allows for custom behavior that only applies to that cgroup’s processes. a BPF_CGROUP_SYSCTL program type that can be attached to sysctl commands affecting a particular cgroup. BPF_PROG_TYPE_CGROUP_SOCK and BPF_PROG_TYPE_CGROUP_SKB. eBPF programs can determine whether a given cgroup is permitted to perform a requested socket operation or data transmission. 7.5.7 Infrared ControllersPrograms of type BPF_PROG_TYPE_LIRC_MODE2 can be attached to the file descriptor for an infrared controller device to provide decoding for infrared protocols. 7.6 BPF Attachment TypesThe attachment type offers more fine-grained control over where a program can be attached in the system. For example, XDP programs are attached to XDP hooks in the network stack. The attachment type is involved in deciding which helper functions are valid, and it also restricts access to parts of the context information in some cases. You can also see which program types need an attachment type to be specified, and which attachment types are valid, in the kernel function bpf_prog_load_check_attach (defined in bpfsyscall.c). For example case BPF_PROG_TYPE_CGROUP_SOCK: switch (expected_attach_type) case BPF_CGROUP_INET_SOCK_CREATE: case BPF_CGROUP_INET_SOCK_RELEASE: case BPF_CGROUP_INET4_POST_BIND: case BPF_CGROUP_INET6_POST_BIND: return 0; default: return -EINVAL; 7.7 SummaryIf you want to write code that responds to a particular event, you’ll need to determine the program type(s) that are appropriate for hooking onto that event. The context passed into the program depends on the program type, and the kernel may also respond differently to the return code from your program, depending on its type. 7.8 Exercisestodo"},{"title":"08. eBPF for Networking","path":"/wiki/ebpf/learning-ebpf-08.html","content":"8.1 Packet DropsThere are several network security features that involve dropping certain incoming packets and allowing others. firewalling DDoS protection packet-of-death vulnerabilities an eBPF program that detects and drops these malicious packets can be installed dynamically, instantly protecting that host without affecting any applications running on the machine. 8.1.1 XDP Program Return CodesAn XDP program is triggered by the arrival of a network packet. the return code gives a verdict that indicates what to do next with that packet: XDP_PASS the packet should be sent to the network stack in the normal way XDP_DROP the packet to be discarded immediately XDP_TX sends the packet back out of the same interface it arrived on XDP_REDIRECT send it to a different network interface XDP_ABORTED the packet being dropped, but its use implies an error case or something unexpected, rather than a “normal” decision to discard a packet. An outline for an XDP program that decides whether to drop packets looks something like this: SEC(xdp)int hello(struct xdp_md *ctx) bool drop; drop = examine packet and decide whether to drop it; if (drop) return XDP_DROP; else return XDP_PASS; XDP programs get triggered whenever an inbound network packet arrives on the interface to which it is attached. The ctx parameter is a pointer to an xdp_md structure, which holds metadata about the incoming packet. 8.1.2 XDP Packet Parsingthe definition of the xdp_md structure struct xdp_md __u32 data; __u32 data_end; __u32 data_meta; /* Below access go through struct xdp_rxq_info */ __u32 ingress_ifindex; /* rxq-dev-ifindex */ __u32 rx_queue_index; /* rxq-queue_index */ __u32 egress_ifindex; /* txq-dev-ifindex */; they are really pointers. The data field indicates the location in memory where the packet starts, and data_end shows where it ends. data_meta can be used for coordination between multiple eBPF programs that might process the same packet at various places on its journey through the stack. hello pingSEC(xdp)int ping(struct xdp_md *ctx) long protocol = lookup_protocol(ctx); if (protocol == 1) // ICMP bpf_printk(Hello ping); return XDP_PASS; cd learning-ebpf/chapter8makeping localhost cat /sys/kernel/tracing/trace_pipe There are two lines of trace per second because the loopback interface is receiving both the ping requests and the ping responses. The network packet that has been received consists of a string of bytes. // Returns the protocol byte for an IP packet, 0 for anything else// static __always_inline unsigned char lookup_protocol(struct xdp_md *ctx)unsigned char lookup_protocol(struct xdp_md *ctx) unsigned char protocol = 0; void *data = (void *)(long)ctx-data; void *data_end = (void *)(long)ctx-data_end; struct ethhdr *eth = data; if (data + sizeof(struct ethhdr) data_end) return 0; // Check that its an IP packet if (bpf_ntohs(eth-h_proto) == ETH_P_IP) // Return the protocol of this packet // 1 = ICMP // 6 = TCP // 17 = UDP struct iphdr *iph = data + sizeof(struct ethhdr); if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) = data_end) protocol = iph-protocol; return protocol; The bpf_ntohs() function used by this program ensures that the two bytes are in the order expected on this host. You should use this function whenever you extract a value from a field in a network packet that’s more than one byte long. 8.2 Load Balancing and ForwardingXDP programs aren’t limited to inspecting the contents of a packet. They can also modify the packet’s contents. the load balancer receives traffic from the client and forwards it to one of the two backend containers. SEC(xdp_lb)int xdp_load_balancer(struct xdp_md *ctx) // 该函数的第一部分实际上与前面的示例相同：它定位数据包中的以太网报头，然后定位 IP 报头。 void *data = (void *)(long)ctx-data; void *data_end = (void *)(long)ctx-data_end; struct ethhdr *eth = data; if (data + sizeof(struct ethhdr) data_end) return XDP_ABORTED; if (bpf_ntohs(eth-h_proto) != ETH_P_IP) return XDP_PASS; struct iphdr *iph = data + sizeof(struct ethhdr); if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) data_end) return XDP_ABORTED; // 这次它将只处理 TCP 数据包，将收到的任何其他数据包传递给网络协议栈，就好像什么也没发生一样。 if (iph-protocol != IPPROTO_TCP) return XDP_PASS; // 这里要检查源 IP 地址。如果该数据包不是来自客户端，我就认为它是发给客户端的响应。 if (iph-saddr == IP_ADDRESS(CLIENT)) // 此代码在后端 A 和 B 之间生成伪随机选择。 char be = BACKEND_A; if (bpf_get_prandom_u32() % 2) be = BACKEND_B; // 更新目标 IP 和 MAC 地址，以匹配所选的后端... iph-daddr = IP_ADDRESS(be); eth-h_dest[5] = be; else // ......或者，如果这是来自后端的响应（如果不是来自客户端，这里就是假设），则会更新目标 IP 和 MAC 地址以匹配客户端。 iph-daddr = IP_ADDRESS(CLIENT); eth-h_dest[5] = CLIENT; // 无论该数据包流向何处，都需要更新源地址，以便该数据包看起来像是源自负载均衡器。 iph-saddr = IP_ADDRESS(LB); eth-h_source[5] = LB; iph-check = iph_csum(iph); return XDP_TX; 8.3 XDP OffloadingThere are some network interface cards that support this full XDP offload capability where they can indeed run eBPF programs on inbound packets on their own processor. 8.4 Traic Control (TC)By the time a network packet reaches this point it will be in kernel memory in the form of an sk_buff. eBPF programs attached within the TC subsystem receive a pointer to the sk_buff structure as the context parameter. The TC subsystem is intended to regulate how network traffic is scheduled. A given piece of network data in the stack flows in one of two directions: ingress (inbound from the network interface) or egress (outbound toward the network interface). eBPF programs can be attached in either direction and will affect traffic only in that direction. Traditional traffic control: classifers: classify packets based on some rule separate actions: based on the output from a classifier and determine what to do with a packet There can be a series of classifiers, all defined as part of a qdisc or queuing discipline. The action is indicated by the program’s return code (whose values are defined in linux/pkt_cls.h): TC_ACT_SHOT: tells the kernel to drop the packet TC_ACT_UNSPEC: if the eBPF program hadn’t been run on this packet TC_ACT_OK: tells the kernel to pass the packet to the next layer in the stack. TC_ACT_REDIRECT: sends the packet to the ingress or egress path of a different network device The first simply generates a line of trace and then tells the kernel to drop the packet: int tc_drop(struct __sk_buff *skb) bpf_trace_printk([tc] dropping packet ); return TC_ACT_SHOT; This example drops ICMP (ping) request packets: int tc(struct __sk_buff *skb) void *data = (void *)(long)skb-data; void *data_end = (void *)(long)skb-data_end; if (is_icmp_ping_request(data, data_end)) struct iphdr *iph = data + sizeof(struct ethhdr); struct icmphdr *icmp = data + sizeof(struct ethhdr) + sizeof(struct iphdr); bpf_trace_printk([tc] ICMP request for %x type %x , iph-daddr, icmp-type); return TC_ACT_SHOT; return TC_ACT_OK; why you would want to implement something like this at the TC layer you can use TC programs for egress traffic, where XDP can only process ingress traffic. If the eBPF program is interested in or wants to manipulate the sk_buff the kernel creates for this packet, the TC attachment point is suitable. This example identifies a ping request being received and responds with a ping response: int tc_pingpong(struct __sk_buff *skb) void *data = (void *)(long)skb-data; void *data_end = (void *)(long)skb-data_end; if (!is_icmp_ping_request(data, data_end)) return TC_ACT_OK; struct iphdr *iph = data + sizeof(struct ethhdr); struct icmphdr *icmp = data + sizeof(struct ethhdr) + sizeof(struct iphdr); swap_mac_addresses(skb); swap_ip_addresses(skb); update_icmp_type(skb, 8, 0); bpf_clone_redirect(skb, skb-ifindex, 0); return TC_ACT_SHOT; 8.5 Packet Encryption and DecryptionIn many cases an application will encrypt data using a library like OpenSSL or BoringSSL that lives in user space. If you want to trace out this data in its unencrypted form, you can use an eBPF program attached to the right place in the user space code. 8.5.1 User Space SSL LibrariesAn application using OpenSSL sends data to be encrypted by making a call to a function called SSL_write() and retrieves cleartext data that was received over the network in encrypted form using SSL_read(). https://github.com/pixie-io/pixie-demos/tree/main/openssl-tracer static int process_SSL_data(struct pt_regs* ctx, uint64_t id, enum ssl_data_event_type type, const char* buf) int len = (int)PT_REGS_RC(ctx); if (len 0) return 0; struct ssl_data_event_t* event = create_ssl_data_event(id); if (event == NULL) return 0; event-type = type; // This is a max function, but it is written in such a way to keep older BPF verifiers happy. event-data_len = (len MAX_DATA_SIZE ? (len (MAX_DATA_SIZE - 1)) : MAX_DATA_SIZE); bpf_probe_read(event-data, event-data_len, buf); tls_events.perf_submit(ctx, event, sizeof(struct ssl_data_event_t)); return 0; 8.6 eBPF and Kubernetes NetworkingIn Kubernetes environments, applications are deployed in pods. Each pod is a group of one or more containers that share kernel namespaces and cgroups, isolating pods from each other and from the host machine they are running on. eBPF enables replacing iptables and conntrack with a more efficient solution for managing network rules and connection tracking. 8.6.1 Avoiding iptablespods – and their IP addresses – come and go dynamically, and each time a pod is added or removed, the iptables rules have to be rewritten in their entirety, and this impacts performance at scale. Cilium uses eBPF hash table maps to store network policy rules, connection tracking, and load balancer lookup tables, which can replace iptables for kube-proxy. 8.6.2 Coordinated Network Programsflat networking mode, in which Cilium allocates IP addresses for all the pods in a cluster from the same CIDR and directly routes traffic between them. Different eBPF programs get invoked to handle traffic depending on whether a packet is destined for a local container, the local host, another host on this network, or a tunnel. 8.6.3 Network Policy EnforcementCilium uses Kubernetes identities to determine whether a given network policy rule applies. In the same way labels define which pods are part of a service in Kubernetes, labels also define Cilium’s security identity for the pod. eBPF hash tables, indexed by these service identities, make for very efficient rule lookups. 8.6.4 Encrypted Connectionstransparent encryption. It’s called “transparent” because it takes place entirely at the network layer. There are two in-kernel encryption protocols in common usage, IPsec and WireGuard. they set up a secure tunnel between two machines. The CNI can choose to connect the eBPF endpoint for a pod via this secure tunnel. eBPF is now enabling a new approach that builds on transparent encryption but uses TLS for the initial certificate exchange and endpoint authentication so that the identities can represent individual applications rather than the nodes they are running on. 8.7 Summarytodo 8.8 Exercises and Further Readingtodo"},{"title":"09. eBPF for Security","path":"/wiki/ebpf/learning-ebpf-09.html","content":"9.1 Security Observability Requires Policy and Contexta security tool needs to be able to distinguish between events that are expected under normal circumstances and events that suggest malicious activity might be taking place. Policies have to take into account not just normal behavior when systems are fully functional, but also the expected error path behavior. Defining what is and isn’t expected behavior is the job of a policy. The more contextual information that’s available to the investigator, the more likely they will be able to find out the root cause of the event and determine whether it was an attack, which components were affected, how and when the attack took place, and who was responsible. 9.2 Using System Calls for Security EventsSystem calls (or syscalls) are the interface between user space applications and the kernel. 9.2.1 SeccompSECure COMPuting seccomp is used to limit the set of syscalls a process can use to a very small subset: read(), write(), _exit(), and sigreturn(). seccomp-bpf: Instead of having a fixed subset of syscalls that it permits, this mode of seccomp uses BPF code to filter the syscalls that are and aren’t allowed. The outcome is one of a set of possible actions that include: Allowing the syscall to go ahead Returning an error code to the user space application Killing the thread Notifying a user space application (seccomp-unotify) (as of kernel version 5.0) Generating Seccomp ProilesIn the early days, seccomp profiles were generally compiled using strace to gather the set of syscalls an application calls. There are a couple of tools that do this, using eBPF to gather information about all the syscalls being called: Inspektor Gadget includes a seccomp profiler that allows you to generate a custom seccomp profile for the containers in a Kubernetes pod. Red Hat created a seccomp profiler in the form of an OCI runtime hook. Syscall-Tracking Security Toolsthe CNCF project Falco, which provides security alerts Users can define rules to determine what events are security relevant, and Falco can generate alerts in a variety of formats when events happen that don’t match the policies defined in these rules. BPF_PROBE(raw_syscalls/, sys_enter, sys_enter_args)BPF_PROBE(raw_syscalls/, sys_exit, sys_exit_args) Since eBPF programs can be loaded dynamically and can detect events triggered by preexisting processes, tools like Falco can apply policies to application workloads that are already running. Unfortunately there is a problem with this approach of using syscall entry points for security tooling: there is a Time Of Check to Time Of Use (TOCTOU) issue. When an eBPF program is triggered at the entry point to a system call, it can access the arguments that user space has passed to that system call. If those arguments are pointers, the kernel will need to copy the pointed-to data into its own data structures before acting on that data. there is a window of opportunity for an attacker to modify this data, after it has been inspected by the eBPF program but before the kernel copies it. The Sysmon for Linux tool addresses the TOCTOU window by attaching to both the entry and exit points for syscalls. if the syscall returns a file descriptor, the eBPF program attached to the exit can retrieve correct information about the object that the file descriptor represents by looking into the related process’s file descriptor table. 9.3 BPF LSMThe LSM interface provides a set of hooks that each occur just before the kernel is about to act on a kernel data structure. The function called by a hook can make a decision about whether to allow the action to go ahead. Here’s a trivial example of an eBPF program attached to an LSM hook. This example is called during the processing of a chmod command SEC(lsm/path_chmod)int BPF_PROG(path_chmod, const struct path *path, umode_t mode) bpf_printk(Change mode of file name %s , path-dentry-d_iname); return 0; LSM BPF was added in kernel version 5.7 9.4 Cilium TetragonTetragon is part of the Cilium project. Tetragon’s approach is to build a framework for attaching eBPF programs to arbitrary functions in the Linux kernel. Tetragon is designed for use in a Kubernetes environment, and the project defines a custom Kubernetes resource type called a TracingPolicy. spec: kprobes: - call: fd_install... matchArgs: - index: 1 operator: Prefix values: - /etc/... 9.4.1 Attaching to Internal Kernel FunctionsThe “fd” stands for “file descriptor,” and the comment in the source code for this function tells us this function “Install[s] a file pointer in the fd array.” This happens when a file is opened, and it’s called after the file’s data structure has been populated in the kernel. 9.4.2 Preventative SecurityIn kernel versions 5.3 and up, there is a BPF helper function called bpf_send_signal(). Tetragon uses this function to implement preventative security. If a policy defines a Sigkill action, any matching events will cause Tetragon eBPF code to generate a SIGKILL signal that terminates the process that was attempting the out-of-policy action. Sigkill policies need to be used with care, because an incorrectly configured policy could result in terminating applications unnecessarily, but it’s an incredibly powerful use of eBPF for security purposes. 9.5 Network SecurityNetwork security tools are very often used in a preventative mode, dropping packets rather than just auditing malicious activity. Firewalling and DDoS protection are a natural fit for eBPF programs attached early in the ingress path for network packets. And with the possibility of XDP programs offloaded to hardware, malicious packets may never even reach the CPU! For implementing more sophisticated network policies, such as Kubernetes policies determining which services are allowed to communicate with one another, eBPF programs that attach to points in the network stack can drop packets if they are determined to be out of policy. 9.6 SummaryIn this chapter you saw how eBPF’s use in security has evolved from low-level checks on system calls to much more sophisticated use of eBPF programs for security policy checks, in-kernel event filtering, and runtime enforcement."},{"title":"10. eBPF Programming","path":"/wiki/ebpf/learning-ebpf-10.html","content":"eBPF programming consists of two parts: Writing eBPF programs that run in the kernel Writing the user space code that manages and interacts with eBPF programs 10.1 BpftraceThe bpftrace command-line tool converts programs written in this high-level language into eBPF kernel code and provides some output formatting for the results within the terminal. a nice tutorial that takes you from writing a simple “Hello World” script up to writing more sophisticated scripts that can trace out data read from within kernel data structures. list the available tracepoints and kprobes on a machine with the -l option bpftrace -l *execve* it’s possible to attach to a kprobe called do_execve. bpftrace -e kprobe:do_execve @[comm] = count(); The @[comm] = count(); part is the script attached to that event. opensnoop.bt reports on files being opened. /usr/sbin/opensnoop.bt 10.2 Language Choices for eBPF in the KerneleBPF programs can be written directly in eBPF bytecode, but in practice, most are compiled to bytecode from either C or Rust. These languages have compilers that support eBPF bytecode as a target output. eBPF bytecode isn’t a suitable target for all compiled languages. BPF programs are required to be single threaded, so any concurrency features in a language couldn’t be used. 10.3 BCC PythonLuaC++10.4 C and LibbpfIf you’re comfortable with programming in C, using libbpf can make a lot of sense. To write your own libbpf programs in C, the best place to start is libbpf-bootstrap. libxdp that builds on libbpf to allow for easier development and management of XDP programs. the XDP Tutorial 10.5 Go10.5.1 GobpfPossibly the first serious Golang implementation. However, it hasn’t been actively maintained for a while. 10.5.2 Ebpf-goThe eBPF Go library included as part of the Cilium project is widely used. 10.5.3 LibbpfgoThe libbpfgo project by Aqua Security implements a Go wrapper around libbpf’s C code, providing utilities for loading and attaching programs and using Go-native features like channels for receiving events. 10.6 Rust10.6.1 Libbpf-rsLibbpf-rs is part of the libbpf project, and provides a Rust wrapper around the libbpf C code so that you can write the user space parts of eBPF code in Rust. 10.6.2 RedbpfRedbpf is a set of Rust crates that interface with libbpf, developed as part of foniod, an eBPF-based security monitoring agent. 10.6.3 AyaAya is built in Rust directly to the syscall level, so it doesn’t depend on libbpf. 10.6.4 Rust-bccRust-bcc provides Rust bindings that mimic the BCC project’s Python bindings, along with some Rust implementations of some of the BCC set of tracing tools. 10.7 Testing BPF ProgramsThere’s a bpf() command, BPF_PROG_RUN, that allows for running an eBPF program from user space for test purposes. You can also get information about eBPF program performance with some built-in statistics information. Run the following command to enable it: sysctl -w kernel.bpf_stats_enabled=1 10.8 Multiple eBPF ProgramsAn eBPF program is a function attached to an event in the kernel. Many applications need to track more than one event to achieve their goals. 10.9 Summaryan up-to-date list of the major language projects around eBPF 10.10 Summarytodo"},{"title":"env","path":"/wiki/ebpf/libbpf-bootstrap-00.html","content":"https://github.com/libbpf/libbpf-bootstrap ENV WSL2 Ubuntu 24.04 BuildingInstall Dependenciessudo apt install clang libelf1 libelf-dev zlib1g-dev Getting the source codegit clone --recurse-submodules https://github.com/libbpf/libbpf-bootstrap.git C Examples$ git submodule update --init --recursive # check out libbpf$ cd examples/c$ make$ sudo ./bootstrapTIME EVENT COMM PID PPID FILENAME/EXIT CODE00:21:22 EXIT python3.8 4032353 4032352 [0] (123ms)00:21:22 EXEC mkdir 4032379 4032337 /usr/bin/mkdir00:21:22 EXIT mkdir 4032379 4032337 [0] (1ms)00:21:22 EXEC basename 4032382 4032381 /usr/bin/basename00:21:22 EXIT basename 4032382 4032381 [0] (0ms)00:21:22 EXEC sh 4032381 4032380 /bin/sh00:21:22 EXEC dirname 4032384 4032381 /usr/bin/dirname00:21:22 EXIT dirname 4032384 4032381 [0] (1ms)00:21:22 EXEC readlink 4032387 4032386 /usr/bin/readlink^C"},{"title":"minimal","path":"/wiki/ebpf/libbpf-bootstrap-01.html","content":"运行$ cd examples/c$ make minimal$ sudo ./minimal $ sudo cat /sys/kernel/debug/tracing/trace_pipe ...-3840345 [010] d... 3220701.101143: bpf_trace_printk: BPF triggered from PID 3840345. ...-3840345 [010] d... 3220702.101265: bpf_trace_printk: BPF triggered from PID 3840345. QA你可能会发现`sudocat/sys/kernel/debug/tracing/trace_pipe`没有任何的输出信息。这是因为在 WSL 中运行的进程处于一个 PID 命名空间（PID namespace）内，因此从用户空间（userspace）获取的 PID 是该命名空间内的 PID，而通过 eBPF 代码中的 bpf_get_current_pid_tgid 函数获取的 PID 则是全局 PID（global PID）。 以下是我的分析和调试过程： 使用 strace 确认 sys_enter_write 是否被调用，通过以下命令重新运行 minimal # 使用 root 用户$ strace ./minimal 可以看到如下输出信息，确认 sys_enter_write 被调用： execve(./minimal, [./minimal], 0x7ffc2c4a8660 /* 35 vars */) = 0...write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0write(2, ., 1.) = 1clock_nanosleep(CLOCK_REALTIME, 0, tv_sec=1, tv_nsec=0, 0x7ffd02023650) = 0 在 handle_tp 的函数入口和函数返回前，通过 bpf_printk 增加打印信息，确认函数的执行流程 SEC(tp/syscalls/sys_enter_write)int handle_tp(void *ctx)+ bpf_printk(handle_tp );\tint pid = bpf_get_current_pid_tgid() 32;\tif (pid != my_pid)+ bpf_printk(pid != my_pid ); return 0;\tbpf_printk(BPF triggered from PID %d. , pid);\treturn 0; 通过查找代码库的 Issues ，我发现如下两条相关信息： libbpflibbpf-bootstrap#75 microsoftWSL#8461 实际上代码库已经给出了解决方案😅，那就是使用 minimal_ns 。 代码梳理这是一个实用的最小化 BPF 应用程序示例。该示例不使用也不依赖 BPF CO-RE（BPF 编译时重定位）技术，因此可在相当老旧的内核版本上运行。 它会安装一个跟踪点（tracepoint）处理程序，该处理程序每秒触发一次。示例中使用 bpf_printk() 这个 BPF 辅助函数与外部环境进行通信。 The BPF side minimal.bpf.c #include linux/bpf.h#include bpf/bpf_helpers.h #include linux/bpf.h 导入了一些基础的、必要的 BPF 相关的类型和常量，以便使用内核侧的 BPF API。 #include bpf/bpf_helpers.h 由 libbpf 提供的，包含了大多数常用的宏、常量和 BPF helper 的定义，几乎会在每个 BPF 应用中用到。 char LICENSE[] SEC(license) = Dual BSD/GPL; LICENSE 变量定义了你的 BPF 代码的 license。在内核开发中，明确 license 是必须的。一些 BPF 功能对于不兼容 GPL 的代码是不可用的。 int my_pid = 0; 定义了一个全局变量，BPF 代码可以读取和更新它。这样的全局变量能够从用户侧读写。这个特性是从 Linux 5.5 之后才支持的。它也经常用于在内核中的 BPF 代码和用户侧的控制代码之间传递数据。 SEC(tp/syscalls/sys_enter_write)int handle_tp(void *ctx) ... 定义了一个 tracepoint BPF 程序，每次用户空间的应用调用了系统调用 write() 的时候，就会触发它。 在同一个 BPF C 程序文件中，可能有多个 BPF 程序。他们可以是不同类型的，有着不同的 SEC() 宏。在同一个 BPF C 代码文件中的所有的 BPF 程序共享所有的全局状态，例如上面例子中的 my_pid 变量，如果使用了 BPF map，它也是共享的。这常常用在 BPF 程序的协作中。 下面看下 BPF 程序 handle_tp 在做什么： int pid = bpf_get_current_pid_tgid() 32;if (pid != my_pid)\treturn 0; 这部分获取了 PID，或者说是内核术语中的 “TGID” ，它存储在 bpf_get_current_pid_tgid() 返回值的高 32 位。 接着，查看触发了 write() 系统调用的进程是否是我们的 minimal 进程。 全局变量 my_pid 是通过下面的用户空间的代码进行初始化的，它会被初始化成真实的 PID 值。 bpf_printk(BPF triggered from PID %d. , pid); 这就是 BPF 中的 printf(“Hello, world! ”)。它输出格式化的字符串到一个特殊的文件，叫作 /sys/kernel/debug/tracing/trace_pipe。 bpf_printk() 和 trace_pipe 文件一般不在生产环境中使用，它们是用来辅助 BPF 程序的 debug 的，帮助开发者知道自己的代码到底干了些什么事情。 The user-space side minimal.c #include minimal.skel.h 这里导入了 BPF 代码 minimal.bpf.c 中的 BPF skeleton。 它是在 Makefile中的某一步，由 bpftool 自动生成的文件，像这样： bpftool gen skeleton minimal.bpf.o minimal.skel.h 它高度抽象了 minimal.bpf.c 的结构，也简化了 BPF 代码部署的逻辑，将编译出的 BPF 目标代码嵌入到了头文件中，该头文件又会被用户空间的代码所引用。你的应用程序的二进制文件中不会有其他多余的文件了，只导入它就好了。 关于 BPF skeleton 的更多信息可以参考: Learning eBPF: 5.9 The Libbpf Library for User Spacehttps://gaoyangu.github.io/wiki/ebpf/learning-ebpf-05/#5-9-The-Libbpf-Library-for-User-Space minimal 应用的 main() 函数在做什么： static int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)\treturn vfprintf(stderr, format, args);int main(int argc, char **argv)\tstruct minimal_bpf *skel;\tint err;\t/* Set up libbpf errors and debug info callback */\tlibbpf_set_print(libbpf_print_fn); libbpf_set_print() 提供了一个自定义的回调给所有的 libbpf 日志输出。它允许捕获有用的 libbpf 调试日志。默认情况下，libbpf 将只打印错误级别的信息。调试日志则会帮助我们更快地定位问题。 /* Open BPF application */skel = minimal_bpf__open();if (!skel) fprintf(stderr, Failed to open BPF skeleton );\treturn 1;/* ensure BPF program only handles write() syscalls from our process */skel-bss-my_pid = getpid();/* Load verify BPF programs */err = minimal_bpf__load(skel);if (err) fprintf(stderr, Failed to load and verify BPF skeleton );\tgoto cleanup; 使用自动生成的 BPF skeleton，加载 BPF 程序到内核中，然后让 BPF verifier 校验它是否合法，如果这步成功了，你的 BPF 代码就是正确的。 我们需要与 BPF 传递我们的用户态程序的 PID，以便它能够过滤掉不相关的进程触发的 write() 事件。上面的代码会直接设置映射过的内存区域的 BPF 全局变量 my_pid。 关于 my_pid 存储在 bss 段的原因，可参考： c语言内存分配https://gaoyangu.github.io/wiki/ebpf/sections/ /* Attach tracepoint handler */err = minimal_bpf__attach(skel);if (err) fprintf(stderr, Failed to attach BPF skeleton );\tgoto cleanup; 将 handle_tp BPF 程序附加到对应的内核跟踪点（tracepoint）上。这一操作会 “激活” 该 BPF 程序，此后每当有 write() 系统调用被触发时，内核便会在内核上下文中执行我们自定义的 BPF 代码。 for (;;) /* trigger our BPF program */\tfprintf(stderr, .);\tsleep(1); 周期性地（每秒）调用 fprintf(stderr, .)，从而触发 write() 系统调用。 cleanup:\tminimal_bpf__destroy(skel);\treturn -err; 在内核和用户空间清除所有的资源。也有一些类型的 BPF 程序，会在内核中一直保持活跃，即使它自己的用户空间的进程已经结束了。"},{"title":"minimal_ns","path":"/wiki/ebpf/libbpf-bootstrap-02.html","content":"minimal_ns 与 minimal 功能相同，但其适用于命名空间环境。 minimal 在存在命名空间的环境中（如容器或 WSL2）无法正常工作，原因是该环境下进程的 “感知 PID”（perceived pid）并非进程的 “实际 PID”（actual pid）。 代码梳理The BPF side minimal_ns.bpf.c int my_pid = 0;unsigned long long dev;unsigned long long ino;bpf_get_ns_current_pid_tgid(dev, ino, ns, sizeof(ns));if (ns.pid != my_pid)\treturn 0; The user-space side minimal_ns.c /* ensure BPF program only handles write() syscalls from our process */if (stat(/proc/self/ns/pid, sb) == -1) fprintf(stderr, Failed to acquire namespace information); return 1;skel-bss-dev = sb.st_dev;skel-bss-ino = sb.st_ino;skel-bss-my_pid = getpid(); stat(/proc/self/ns/pid, sb) 用于获取当前进程所属的「PID 命名空间（PID Namespace）」的元数据，通过返回的 struct stat 结构体中的 st_ino（inode 号），识别当前进程的 PID 命名空间归属（判断两个进程是否在同一个 PID 命名空间）。"},{"title":"some file about ebpf","path":"/wiki/ebpf/linux-ebpf-file.html","content":"查看内核上可用的跟踪子系统集cat /sys/kernel/tracing/available_events 查看跟踪点描述从中跟踪的字段cat /sys/kernel/tracing/events/syscalls/sys_enter_execve/format"},{"title":"c语言内存分区","path":"/wiki/ebpf/sections.html","content":"内存分区(高地址)栈区堆区未初始化(或初始值为0)的全局变量和静态变量 (.bss)初始化的全局变量和静态变量 (.data)常量区 (.rodata)代码区(低地址) 代码sum.c$ cat sum.c int sum(int a, int b) static int val_1; static int val_2 = 0; static int val_3 = 1; static int val_4 = 0; static int val_5 = 2; const static int val_6 = 0; return a + b; 生成可重定位目标文件 sum.o$ g++ -c sum.cpp -o sum.o 查看 sum.o 的段头表$ readelf -S sum.o There are 13 section headers, starting at offset 0x2a0:Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000018 0000000000000000 AX 0 0 1 [ 2] .data PROGBITS 0000000000000000 00000058 0000000000000008 0000000000000000 WA 0 0 4 [ 3] .bss NOBITS 0000000000000000 00000060 000000000000000c 0000000000000000 WA 0 0 4 [ 4] .rodata PROGBITS 0000000000000000 00000060 0000000000000004 0000000000000000 A 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000064 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 00000090 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.pr[...] NOTE 0000000000000000 00000090 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000b0 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000218 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 000000e8 00000000000000f0 0000000000000018 11 9 8 [11] .strtab STRTAB 0000000000000000 000001d8 000000000000003b 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 00000230 000000000000006f 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) .data 大小为 8 字节 在目标文件中占用 8 字节 (00000058 - 00000060) val_3, val_5 .bss 大小为 12 字节 在目标文件中占用 0 字节 (00000060 - 00000060) val_1, val_2, val_4 .rodata 大小为 4 字节 在目标文件中占用 4 字节 (00000060 - 00000064) val_6"},{"title":"gdb","path":"/wiki/linux_tool/gdb.html","content":"123"},{"title":"git","path":"/wiki/linux_tool/git.html","content":"123"},{"title":"strace","path":"/wiki/linux_tool/strace.html","content":"123"},{"title":"光猫","path":"/wiki/wlan/cmcc.html","content":"如何获取联通光猫管理员密码 在地址栏 192.168.1.1 后面加上 /backupsettings.conf 把这个文件用记事本打开，找到 Adminpassword 一行后面的就是了"},{"title":"介绍","path":"/wiki/wlan/index.html","content":"131fd7c5506bb654a6cea69bbe40f3df7da318ecb0403b621d8f115b1f8d302bf6a9a4d5270b84db0e87e59dfe247981efcd8281284099f469b4b4e8f634e868e4671607d4a31592aeff9d649d1e0407bd7e1bc1cbf54d87af3576a02bf8498f2fdbb69f3bef66d718f02ef934c3851bd23c8b140d894efd71c93d3642f3d411603562ce7eae6717ce330a06cf6eef7c9fa36333050b55caf8efd91b39b2131d1ca0948aed75e43787b7163c54d62c027a420ed131665238b87de39ae2d8e7ea6de41a1dce92224b92bf589d1873a158e5371aa4880c0094095609838fe2e76e080c6da16ab74a1c3fb0a14928da5d400cae7a12bcbac5d2c250f791b0d46a905a1381a271cb7eadb98ee1a4ba97835872b4e4626f7f80e727fb3d49ac05760febd85438206bdaa6a09be2f192edce456b782bf63d57da24f8155c5a791e52bd98185580ce691b8734808d92a88dbe0fbd732db0e73c764cae2beb80797ca8b8549a8c76a648b2b16c6aa5137e5ffedbff4ee147d5370a5810ccadb61942ad69cdb241911353fd464bdeda402d9e2404ea735852a7ab9e75f56ba829952669402b15f9ec52fd0bdf7d7f3d42d9bb0534a4f92300fa7ee6df8ec6d9ce9824609e3ff230f3c258ff46f17db7c311c9c10da218083eb5c2e403ca9f838a3f6f12f33df838fe76844e1779e468c512c7ce776b1aa612d330eb79054415608982b02000de020ab1ea2c02648772eb593f4624491a5b891cd162e4d443b97876b9546a7d021109b2f3cfcdd5630fd22a942f99cbd3157ab67a087702322dbead0a1a138b435b2f9d042589146bc194902d9c3537ae34d1e31833f91942f651422588db2159b26ab4d559d936f5f1721af6734d4af09768a65b16c6dbde939c2ad0a1e11c468544ca73bf243cecefb148dbe95b67b1468d80cb31b761291734bc708a3ac7ae9753f5a43d91766afbb254e7a389db40c0a71d272b1471ecf95ab18a890f2ca583102cd106b2a05b54a35b70e1934423975409558894b6a5ddf15164d9ad5c2d67134f1020617df33294d76d15bac449b71ed633afbf4f593655f4df7c913309c76c2cad2aee207071e1f0aecb1cbdb712ff5e87049ffbe1027f1af47000a65a71ab1522e2b93164e02d7a774d54294b9d018945bb633bf0114e375758dd0ec034faa896a8b3a715dbec5c5c8168daff0fefc37a516803e2c1354d26123d0fcb94d23a4cb2dd459d1532d89216f9fe744434257971cd4be4dc3013e22b0cafee42b89aa3a52af0c8518701048962258e1375d2e40e07c75b3d7a21f2c51bee8749659ebdc0b694c5fccd75cf860964b83be091c5e020e6a2ce3f5605890c84a5d717d22ce483b18fe614cc2933b455d495c62843ef750b96c066456d8dcd421a90ee61e3994d32df1c8cd2774877dea24302089cf59f1e0987f4c7e76d116e0b5897c6086c71bbc87020f5c7efeec606db70012ac0b2362d8c32223eb8257e03abe7948e9e5ef3cb1969ba05dcd5d20af794bee131bfd0a41228fe3e6e5559d3b6e82a5d9a220910f7a8cab8089739e36933e285fa9c11c288a19a2dae2b8e51e9416c273d23d8761e2a8c9b21d945db73b8b7d483056f8ffe19cfb02becb4ed3d02da0edf91f74aed61fedb53c884924d501e17f0850b314ac207a148de8786d9909e069ecf0ef493af008ad9f44bf52356e838d561e3f6800a55484ac8d75ea84320f27d05e85a31c910f46e78e2f8ff099dbc93fb11808bc40b60e5cce87f1c51d9c404f79b33df7ddc4102a5b2365ba7b63f7a8d7f906b1a3040baddb5e858d3a9516737a32fedb89a38a7f55c9aebf6b1d975f063f4f9a0abf6014bd7741ed25df7724b6c8443c0d8f078b9959f94679c597cb1f32b1f26d7b8a1b728d614b89fabec5d47d400e2c098bb4904449e69261a62660d365ff35e49c7051a9cd85dc4022ad9eb44a3a795a2d007462b1d0f4e022691bd962106536039145c7d8826acfd432d057e99269f31ae805103d24c25cb6e244b151d070ecb5bcc75130ef7513bcb1d3eccfdcfc7720641120dbb3d2d9e30bb3cd2cc34e1d69dd0e5197c02774eb887dce80799de00465f0c230b9901908f20d399adc2ef6387f72d55a2f26f3f17add585d64da9967ce58a2ee6b8f6c39e7737686e7de74c4747daea0576d18d34feb2b423700764ec2dc56a8b1d3dc26dbd10ca477257077bedbd5f4c01a507c1ce7fa3c08efbfec1a7dd56794cfbad6457dcc7e3507238920beb3856e6916f2a52f525b0a277cfcbb24dc77827c35be75bbd87e6047d563d6eac2f271b6329783a024d1a7efd49580ff58df3531df32b6e66d4caa20bbba3fdd489f9df7b8ad76df863e510e293b0b92dfdfd637eb82b287114935630f018d11dedd806d0d3a88cfbbf112cfe4f64fe58d02fd38a14893bcbf57c57648c67d21167c1f5cfefaedf6e19a059340b53e966cd58fdf1ebd06d05998fa64f05d3410de89f4d6a137cded66dbc5cbb176958a7005141efa5ba41194a6ff74244d12e6c1d6f07008c08bb44f04db7cabc9ad811758f40a319205a90eba1f9991f0a12d5e1c37fdfc3a7742a97fa2266c1e5c569c451c05b3fed136e0fdbbfeea9bcb5e7a7aefdea7abe179f6f0069646f9893e7bd1f814a1d01f185a58257171fdd44 Hey, password is required here."},{"title":"路由器","path":"/wiki/wlan/router.html","content":"123"}]