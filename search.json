[{"title":"每天最重要的2小时 - 05","path":"/2025/11/05/0009-two-awesome-hours-05/","content":"对工作环境做出理性的选择，选择那些能够让我们更加专注、更加深入思考的环境。 声音对工作效果的影响一些基本的建议，能够让你在关键时刻保持专注： 一个独立的、远离噪声干扰的环境能够大大提高工作成效 如果无法离开办公环境，那就戴上降噪耳塞吧 不要听音乐或脱口秀节目 如果在家办公，就把电视关上 如果要完成的这项任务需要发挥创造力，那就不要抗拒背景噪声，可以考虑去一家忙碌的餐厅或者咖啡馆，要么放点音乐也不错 早早起床，先在家工作一两个小时，然后下午早点下班，来弥补早上在家的工作时间。 光线对工作效果的影响蓝色光和明亮的白光似乎都能增强大脑的一些功能，并帮助我们更有效地工作。 在需要有良好表现的时候，可以做一下这些事： 多开灯。 在天气晴朗时找一处有充足自然光的地方，然后在那里工作。 把灯泡换成偏蓝光的。 如果需要完成一项需要创造力的工作，把灯调暗一点，或者找个比较昏暗的角落。 可以通过以下方法对自己的办公空间做出改变： 清理杂乱无章的东西。在心理能量不足以做某些难度较高的工作时，就可以清理它们，比如下午或傍晚。 把电话、水杯或其他工作相关的物品放到桌子的四个角上。 不要在桌子边坐太久。 摆放点植物或者水景画。 想象自己正坐在桌子前一张舒服的椅子上，有足够的空间能让你把椅子往后推，把脚跷起来。做这种扩张性、开放性的姿势，并且保持两分钟，就能够提高睾丸酮水平，并较低皮质醇激素水平，这会让人们更乐意冒险。 把物品放在伸手才能够得着的地方。 在跑步机上走路或出门散个步，能够提高人们的创造力。 结论：与你周围的环境协同工作反思考研期间一直不习惯晚上熬夜，听到某个考研老师说可以不熬夜，然后早上四五点钟起床。不过现在对我来说早起似乎也有些困难。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"每天最重要的2小时 - 04","path":"/2025/11/04/0009-two-awesome-hours-04/","content":"当希望在提前安排的任务中或者某些特殊时刻达到自己最好的精神状态，利用身体活动和食物的即时反应来增强你的心理功能。 我们的身体状况可以影响到精神状况，改变你身体的感受，就有可能改变你的心理状态。 运动对精神状态的影响身体上的运动也会在短期内对你的心理表现产生作用。 运动半小时左右可以即刻且连续地提升执行功能。能够让你地注意力更加敏锐，让你更专注，让你的血糖值稳定下来，降低焦虑水平，增强积极的情绪和感受。 不论现在有没有坚持有规律地锻炼，都可以在需要的时候利用运动来提升自己的思考能力和心理能量。 一些非常有用的运动： 如果没法集中精神，就走出办公室，快速行走 30~40 分钟，上下楼梯 20~30 分钟。 把有挑战性或者会让你焦虑的会面安排到一段适中的锻炼之后。 当日程表上有项极具挑战性或者令人疲累的工作时，要么在那之前进行一场早锻炼，要么就在完成任务后立刻运动一下。 需要制造“高效两小时”的时候，就在之前的一两个小时内运动 20~40 分钟. 饮食对精神状态的影响升糖指数低的早餐更能帮助孩子们提升执行功能，而提升效果最明显的时段出现在早餐后的两个小时内。 即使是那些健康的年轻人，只要体内2%的水分流失，就会对注意力和短期记忆力造成损伤。 小贴士： 只吃半份早餐或午餐，把剩下的一半留到两个小时之后再吃。 一份富含碳水化合物的零食也许能帮助你在15分钟内集中注意力，并且让你感觉良好。 吃一些含有蛋白质、含糖指数低的碳水化合物和健康脂肪的饭菜、零食。 当你非常忙的时候，坚果是零食的最佳选择。 不要傻乎乎地大吃一顿全是由碳水化合物组成的饭。 如果在过去一两个小时内没有喝水，或者刚刚做过运动，那就赶紧喝水。 如果很疲惫或者睡眠不足，那就喝点含咖啡因的饮料，但不要喝太多。 结论：主宰自己的感受我们可以根据自己希望大脑在饮食或运动后如何运转，来决定自己要吃什么或何时运动。 反思最近总是在晚上运动完之后，就立即开始整理读书笔记。 运动后及时补水。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"每天最重要的2小时 - 03","path":"/2025/11/03/0009-two-awesome-hours-03/","content":"我们需要让自己的思绪乱飞。 大脑天生无法长时间保持专注从进化的角度来讲，如果不做到这样，我们人类就很难生存下来。 把那些没必要存在的和会让你分心的东西都拿开。 拿开办公地点的干扰物如果想要最大限度地专注于某件事， 尽量降低噪声，尽可能地关掉各种设备。 把你的设备都收起来，或者至少放在隔着几米远的地方。 没必要当个从人群中消失的隐士，只要找个办法，也许只要能让这些设备在20分钟内不会令你分心就可以。 冥想练习能够让大脑更有效地保持注意力。 走神的重要性走神对于认知性任务（创造性地解决问题和做出长远计划）有很重要的作用。 如果想要解决一些特别难的问题，不妨让你的思绪飘飞一会儿，琢磨一些难度不高又不相干的简单工作，这能帮助你找到更具有创造性的解决之道。 在专注于某个问题一段时间之后，转换到另一个从认知角度上讲难度适中的任务 – 但不能选择某个需要利用到工作记忆的任务 – 然后再转回到最初想要解决的任务。 比如： 欣赏墙上的画、房间里的植物、窗外的风景，或是你桌上的照片，注意各种颜色的深浅 整理桌面和书架，把桌子擦干净 听音乐，注意聆听这首曲子里用到了那些乐器 玩个小游戏，比如只要看到有人一边走一边发短信，就在纸上画一笔 不建议在走神时做以下事项： 整理文件 看新闻或博客 查阅和回复邮箱 排练你要演示的PPT，或者为某个会议做准备 研究一个高难度问题，比如填字游戏或者数学难题 “觉察注意力”，放任自己走神，在觉察到我们的思绪飘走了之后，再温和地把它们带回我们再眼下所进行的事情上来。 不要理会那些不能帮助你继续完成任务地想法，就像冲浪者们放弃不够合适的海浪一样。 大脑会产生各种想法，你并不需要对每个想法都做出反应。 结论：给自己一个喘气的机会反思工作时把手机放在视线外的地方。 尝试冥想练习。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"Linux 系统中常用的时间操作函数","path":"/2025/11/03/0014-time/","content":"ef77cdfd35a516030a30622d6798f966922f09fa54d377420ff3f0fc2944db5b883f34d1acc43189aad7e189bb52aa7f01f63e95133dfdb4a8517b8c8eed389ecbcc216614bf14afa2364a29099391971d3f3332d2eafe6cf0680bd7b20512ca17993dc180ec3ab0a4016db97acc4938d032726d128e25795ec607fec28a3354e1151f9a576d06bb1bea4e18df27253b711d47ea1c5e56894d52f6e9e23e417e3c7726d6bd9b3e1bef4084155c84006b5e1fbdd15584af5f991c58786d9893cd42ffe10bab0d350c6da9e8f095901620bc5b3bc65c0c35ba05eec27cfbb250ef274e716646021aedf44af33ca4561da947e6b730e3644c0f0629da552c4b460de3c28edbd6c62a6d280d413cdae9aaecdac783a65797b4c04582f4d8c96294965ebc8e42363854d4a4529037d9bafdcf5e1bcc06d404dd7c15b4474580af3f70e87ac1c593b5c08adb657f8989487e28ecda0331a402d166814102fe4c117d8cc12b2bd8769917db9916e52372eac3b49f33e086cf9abf1e1dde5c535425268a39b748cfe175fce6723cc692b830c43da307482b0ca202eb12f99193e1d1e4778232567260b72dabbce06a62c3c8f3eb266e1a41b25634d1c4e2e7e463d0398dea5fa12234c67f8ed8044616ad54fd923fb26467eeb8993de927e736e664639b82f9c836945c6ebfd0c5c1846ba36d57ddfe079d876ea6fd58799e8be728f966bb5dda97090a36b3a46ee43be1d09bac6bcb934118204142e0023492af15dfc12ca0abfd95d1318214cef542106175645eb63c0ab6e439569e58bfa5936dc5577b8fa052474331a212b8d4405a0665f8ac65894dbdd0e6400f7945a5d41383fa58d5cbd04ce173ee080d5b05542e8d4dd84cccaaa3e790c07534fc5fee5be5f480ac4f7ef2a11976ab6ef3d192f9f23078bf78038867b90b4417f3741ca0e7b74648df5030210293f4fd2f190bd85e9b521ad88db01c4ef4d2c92c2d46465678b3ddb207571da7fa51d7426ae96f800fa2cd3afaaca0e2e1d356b2245d91e2770e1c1dd88f856c41496f5a2100c5651e4efd52ce3b2a82f41eeba106ec52a917e1c0ade33a53109e3c253d56a034f3d85117482773dec2ea33bd002005d8d2e5484f6af95dec4fa7e26437ae0b61622dfd528ce3e2d1cce170db30ef1eb821438d481d7cbb55eab4a3bd98d007f986ff7a7de304b72853a7184f232abdebbf1d2e3e40bc1073f79a512442e7281f4a55c634f45d65b6a00579029459794318ed536c1ddc461d0ed85f096bc45dde5ee290f0b7cf733340b6f11143472a8eb4b883badd64363fef69e8d6d48d893de27e9bfca981036d07429d152deb3cefacf5a74a16a36a3bfed860583146168c2e4abfdf7944b82898f3ea5b5517687c812b89a481808f92f05697ce3b06b9780758b7d195ee7cc54a0edeec6024ebdd6b805ce38b340d6267aab3a63e82f996ccb943030dc822a8437c38e834f51950d74625265d1d69e60af423762e9d9adbd8d764b149da9890d61be7d39843d6339622e455c17fc88ee1844e586883d99c4775806b277f4b04f824301898f6cb2228025f7d55efbae07a4665f0f9d4033d38c28cb8e3e365cb1bffe92563049fc79eeb913b7ceb481689e664bdcc5de26c18704ee342c31d60b4c58f824d585e2a26f7bad7ff5fc76732e90a0862688130c26c58a4724cb65790142cc1b5392f5d3f63938c179565797fae36e8651660b1c38e007414735b3d509c9f8ae1ca069b4d199c2e66586283aa8bc2a375309a5fed67d17691c0e4f76997b3d2919129b546a188de468c7186f2132f458b19d4b9ad97a2844f33a7de147e33aa6cbf678f7610107fa2d5dcbc16516da19a9dd42132842895ab67c6628f8ec72064e3c34a88b4f5efaad327c5657ad2f42e5f0f106dd5728d9542b6be992c59628c08b75f16e33bdebd7160bcd9d47a1bbebe2684fa71d94b578bd9bfbee68639180fe0fdb682b68442470d6e978d43a09ab025f3d620dfc3c461559fdb21366a6d48302bc09b32779823cf5cde9edfcb2a2ce2d04217d83559dcbe226e0e1ecfc5e5d98bcc0de4c8c57d08e1aa161a0c968bf32f9b12bcc4d44ae4f2fdf27ef17519522bb81bd1e84cce07fd35d5ab5555bcdf5db8bb0d12430e091bab1e082f31cb091728aa556d59758b222a1d7293a27c6b8a8f0826d85460eef4e72a56480759a1d7e71ae5c5e073df8c64ef2d15a0f0954e6bf503c6ec47aa345e076ff1d8a7b5e8c9b536e79040eb83affc27fb80ce3e72184477a01ec42ed7bbf6b86dd23f4ad5946a62a39a62dbe78226487fbfd8faf5976f43abc013dc356ae724a9b1887f0295ff3e2b4ef491ef912776e0857ee73fbb8436e856c49fba59bfd2470032ca08001ec6a4fa9b6f8adfee825537cd51b3be57e26f7b45debdfcd89ffb7f7c294e6c326242b29102cbf65914da19a653847e3474689d21150a09043e61cc9ff1b849559b5ec51f0d4c53705a0ec49724dde5c7485f969327fb4593a31b5f1f39fc20ece38b3f393cae1acc87a29ddff8c8ce0f14fd943a9cf4e727bfc5cfdfe3196ebce955db091bf1f61748c20dd07372c90d768764af25fc4dcd341dfb520564b46d38566b92c5e991303397493ca1304d55acd7945334155398e0142d74d3e89d02e1420db9cd3bdb46303d298221cc758d408afb1ae8ff78f10e7dccac72de7a8366f2a30dbbadbc01163b35aa0f1725b0ec5724ef2d3940af5cf092eab0f47bf71cb9b0f81d93a66186f04078f5d1e0149ab9dee1904fe7b14d5b521ee9a27ebd8752888fe967cad8123d82fc44e7c1626542bfee351eb89c717784e71ef0322255be2a8de4307af0a299cb7d0ec7d5e09b9afb948e2f5b95402a3faa821fb79fdf89662a7e1201cfa3c3c26399878eda6132e765990cae9fa9a5d019135d678a549bc3be3a8fb217cd92d32f517767bbe976cfd5abbbca560ef77c7deba57d357ca291f8400dd2f056f59ca6c27ca655b654d133bcb3324551594feac06663e7e6226d2cecb9309fb241df2763622a9399a00d8ab334d83dc8b175b6627ad5919c30841881d8bfd97737b3348fdfe9257e4d056eba1334f5ef94b97f94c04f553819837b7e5ca5fb37690c45851685c6a93153fb50b20c37addbe0678d777c242af49e1e27ec931e957f8f4917f966c992212b08ad9845e50f38e80b7b2e807d07192f89a941b15ae96a40b1744a7c2e41bde9c48fcbbd4e1426ed07b7de90ff042e5a69e4f67ae34a38c50745ee2c0aed61372ea6edf355fdc40d8a3b188839fdcd0233fc788b18c737225ced709defa6793c8b26631e1a8232b1459681c8dc1cb7c66500151a6675a4fbeabcc410a4cb198f93341047100b36d090abd4eb04139a0b0ccc441569430a62a194869905cd55dabe5f9e7cac96c4d8842a2d09f230222efdf46d9d987dbc55fd43fd4ffaaba0460b78c407282917c38fdb73022e7a99adebe091da8b11fc527926180bb81baa2a00abbb651cb2a7507e1533d082f1f509ef93c86b196756b8862a99c10924df720983fe4ffe5b2674c053d6a3e4d834c9c5530431d08f20c85df2b05d21907629d0a5c051d6289988d0383b91969ff2ab17120fe25f3703df54cf2cd580aa00fb0461f6131bbedd1dc1952ba9e7739a993a82769c097e837ba68ce5e00818a7a8913211c105e757beefd58ee1bfb6e8599c57ab9817e38f8eb72ae82d811a4813693d8bf6168530ddebd8c2c6771a4d862fd86f7764f8081709f74ab76ff91e0ec66b96b7d0916bdc825e577a8c1ffc19db0d24c5e07c6a9971d2137bed9b2fd2ff3ef460fe3d7d787d21b804ee42112e4b0e3c62e89ff7ff67e831ed6d59b1fc17546c68f807c765fb30ba2dae41d7f7e7e464851524a7753d67617ffeb229cbde5da2f607581c607970850ec56726eedde02782b8583bb2f7a0631066389330fa09d8965778b09194d3bdf91ec27490ad567fdd4487a277d71a5776f807823856fde4ac641333e239951598751bb63c0ee93693ad4a34bf1b90d18226da35dfc50f01d5c5efddac0224fefe3053ff1a0d8a5bcc455bb34a8d47fe80a9de70163d7d78316e53899461f8aa6d981526acaed97e8482cc865136586e07f0a713c1d8d6733b90ab0ba19bf0cedfb07334889ce14ea9ad68d16c5ca8ab193caa33c9a8c752d6ea89d763bc652b5c896ed6bcd7e5d56ce070d9f8a49a6a38db53b762eba15fd69bc812d7bc0f1246dfa2d9300b26b3b70dd5adcacfc1a00dff01b4b973ef3c4a5d373b18b78a3badaf6e51c565f1150142cb9f49401c5906953e082bad3789a21a943c7eb0b50350c405849bb3a2e289f95fa9af0d6e5b021397b015d19f64bcaf38ac969e1cfc997410e15e1a6b19f5dd98f176ac601ae24f28ac8481afce5414977163ffeb755f254be235f2c126b5b6a2b4ce5cd46562d4a91147249ea00f636c7d31ad075766799f7a9e1170fd721d7735a76ffc7fc95323dad15aa147b2a83e01a4e6d5f3e01e18e07540bf0b05d302fc5aaf5be1311b99a4cc105d62312af31cf31b1fec608209450853abc6ed12efbea72b39bd028e07b77fce1ce40754e2d111e003f0aed56f8138d59e8889df03573dae3d162462b05bdb2b2afbaa701ef1f2efd6e7dfb58b60c9de4d72c9029c548958d2ea902d03148a9e374cd2bfeb0b82409ceea0b44e2398dd20647eaf3d42e2fd328b4b8a786ab1a7bf24ac7272325772318307432d7483a7dd95e27f7f97bf2330201f004bb3cb8d1210abfceea0162c8104e1b62a1459e05a738364144009faf62d533e8a8fdc3e8e7e25a42b7b30949c283c796bbff9c3eaa6c287c493a60c7c8a6151e885591c7dc97df259966711c1383203f0f8b81d05c16051c38d0a310e953611b76f3c8646b1eeccc851812a53351dbec29f7d95b6bc03c29ecfae502f40c2d2d3a2e500438407defb3281bdf73e202e08a44456530eb4d9f5c60f42a63e145bb228e34a2d4c5f7cd19c117cd1285f917d6542a29e823d5dee29d696a052d2d93d33a677789afd4b51c454b48f88aff5ed09f1ddb9a57610bfb53f08abe945ce5b470d258e28da5a07d76fa3e642094e93f1388861aaacd62bdee35db1e87421ea0d14ac3ead59cbc9bbe3d6c090547d5fd66c3e126a304ec0d3b722731db0027fd33ab4f39f78e00ff5cfe589507f5e6df4f0931dc3c6fc8722273fe426e63ce88c925cbe8d9a334ab773e55470065ce5b792bc0fff223671a9108e65c7f95fe57b54e292be34b84ae6be9aff4180dbd7dc1483a765ddd8524c54901beb1ef5585986abfcf6b18716aec221bd7f816d83f871e022ef6c69b5ac66867b3e19f6986f2ddabe4d130aaf92eb3e26b87de1f3fd196356a6c4c43b251546c78f5197a102ec7ae580ffe2ffe4d5b0493b8c8d96b02c98c88d8dd116497eb93e651a219d4790949f73fce87521fe9a07450e545ac68ef91c13ffaca61584b069fbc2a87849d1d81693e6f851f149206378190a2b262b071428555cc7b74f1ac4c982c1f1c08baa896309d10661fbb9db3ff14e3d2ad4e550844681c42235bea9c11c65727bda8df30fcf1ef82ff0e03298c9dcbf0be871ee09459d6ae9f604c4a2f7525a77786b27a99617f22942d88353d2a62130ce34add89451d72d958994176431472461233783af09d09bd969d904605dbaa525060ee2a5796b63495e0e126cf80cc47865d8d675e06a46e57ae40abdd381ad827f31f25811040a99a55702dedd80f734e2eaab1e040653b3d927d23c89cfe4489c17d372f5f2faf24ba009b042f8ead11585c6131f3a3db184d81ae70b56d9782c81e6203dab61b6b92b825856b1ad4ede8ad13c7144fe5f180caeae4cbfd10d2d128d220fecc2541db8895e7793f81009450c91a601bf995d45c715e94aae492e43d5c4bf74310f681d962992a5fe482d922ddbe0c59a3f7856d43bd106f36c24306f209a93028f8201b829c7e277881e8dd7af2c72c972d4a58f5b35ec83ceab2ca05f4a9fb1b0f4cc71a2f7caf8b09e509c7bf093118edbb20c66e094aa96e69aa5b0f444582075a930a79c8ffd8de832496b422d54927d2cea80ae391c07e33a95d4143c76ea30418e774ee6507907afa6cc9c84a5f35921739ff4f4d3fce6ccefed8aa33ecb5dc28a4ae3f6e795b93198a3768cbf6a5ea6b0bc4c57567bc767403c46714e882fe85c9d9e3bb106b68f506836ca7fe7c876e13f3696b49a29d6df736fb3162b157390554331015d449a587f37e9d3a976824e32c43b0b79c3de6a26a47744733e516747e7bf8804b1f79ceacef47bd3adcc99a4b07d36a1db03129bf21c9ff06616aa5e20fcd08e551c26b3583a786e6c2b274c630996f225aa79ab572018737d68dd2495a95a8f1bed48846bf3a6f9cb1086aa4ddbb1d20d5fad1394a8ba37f227901596b5b6e19155bd6771664ff9f52a2c5def8470f9e92516867d45d03a58c613c43564ce4b6e9bc18c1588ef6478c4e81078c5915f10b610e9dac36ef36b9403575429584d7c878af726e55683108f4a6de6a8e804f77e696c3c0e5c9299fccd1a16c729f3476c8a56528286b8cf5152e21dee637fc5f0151f82de2a1e02ee463dcd269328c297614e6f99539d1d5ace7ef4b5650d0764a451f79a8a8081009e1fba7cafbf40b58caf20198b3569c327904332230f9cc381b37374aaa628c69d4ec8342bf7e4b802fcb97a6cc81b98e624ffd4ac880ba1695debf4439bad2849d711f30fac699270db36aef7ddd12d7befa2a9033b4e66e8bf1bdd502105c04de27224ad1df6c0cf959bf79894048647dc5d363aed55aa4b937a2b7319b90af28518d72cf4e233355011eb8f4a05d88cfb1700a8369c271f3d8059790c004edb258edecd8a8fe8c7fff746803d92dff8e71126ea8fe8379617fc03190b4722d90c176b3ebc618db0f6943c67c9014013fff4ae18dfcdd99a53a7699dd7a38b3bc51256307dc299e95fad7c7809371e3100d698629f312bf359f9e4070f8140aa054fe2125c13962026474db4740cd29ab087786e3438409fc0ce1cf896b3736c860bd42d8326bc93b18641267273785697040233da51501d3417614520c45ec01621013dadb0ecd52e117b0e95303e25aa59d1db0ecc8b3e71f1323f2b0b265ae62fdf3a47b1f46dd6b7f4696daef79a2b28ef3a146e5a15b96af23f0524248172444dd0c92025e6727004ba77b6db0f8e3541ae81478dcdf938cef2fbea7a1be16b0de1040878280bcae443e769740b41de9815ceec4648485d493a7a903787dab64fcc89c96ce42d1f35c74b2c42a973f52b3cfe0379ad55f9cca2da5020ce94073bb219342f46aa798844c5d819534ad132dc103b0f462ca1a51411ccf5ef5ab2f7390228704d78a9160e23f1c3143b25683cf5a3f5687465d31ecb14012ab23769611fdda665e1310c871dee13e14f59631a9696f214697cf14360eff23343cef8114ed896e749482dceb8f204b0fafbf25fb7c36821f70f26c07d9648ae1634caf64dd8d4f1e3e48633ff6423b22eb599edba6b694c787f098b1a93e86ecd5ca92775eeff8224dbde636501841df7df601e8700e1e3278479c4c09ae96a988e66890a3574816b6b6b30bbd8c72ad3bebca6d2a6509ea1a5eb65fb4f5a27df567df30e71fdfda49de6bf44bf27aa053582da4110a2fae9525b2cc1c22fdae300fcef604f764b4a7f54075e8ffa2375f94fb70865fea42686640f8e23aa8eaca00f812132816f35e0d89457f8d20e1f6b546d59027a6b4c4a6a0d7f1037e451808a812e75b65064cfbd54696c9d221ced911621419173192a524075547538b223343f75980d9f651ce6e8f198c28803271259d3366789e3f5f233ee506345faa9a51ce525b77d0679bd505ce6a479a44438532941cf80aa78fb73c1df7f2b0fd05b4e31c5e6f6cbd516e9bc8aff03e294bfbdd364b8b18c916eed8790adfc2c94eba90ae67eae9c649a398f65f21d288a18b870dcae6a81171265d41945b908877eeff5e18a5d7619ca2c2d31805ed7270eb9e9aacd65e020e4d92650a23456278095123654eade37b6e534a9d3970c98cdc4b2d22e690a69f1f0ec4fb1fc5d00a05331528a001f324bd10ba705f6ccff7d02410cfea60c8a81267142fc881bbfd1b3d1fd7376fee01da21f339ee2c875876f04f95ce75f4a6e034d0fd5c2c5d42b36cdea6a4409c9fc0371da232c5317fe54f2d0d8a2b6775fd6fcf407b9709442077c1c0cbba8a2173bab915accdd5a4657702e0658dedb01d1f90de5bb5ba1fd42b5fa24c0f41f8aba7afe839441de8a7bfce16875b923450b61722dee442ba762efde94e9a83b23d92ff0ae851253b7089110a0d5cd85162cd3b6270aa05bad7e63afd1b395adfa29052c8bf85b6d5cca153e1fdbcdbf4f0b8b265ec944e106ee60875a744b2f0e599709d60b172b284808ee3782cf54876d9a50867f2a997cc0e26b0d678e34ed41227911b1560d0299620394e3ea337b6156f347ad824b446248b9be0fe68413ffbb5c25d932dd4010cc598470ad059d1426d1744f823eeb4ed04635ad02b958a4e2562a3b014027065ac01f88b89ae11e890c533de0e7cd032b1712e3c75dba7df485c7a2cad65dd9ee5f05b2c4ad33d3d1b0f5aaea4652718d78ddc93b294551bc26aeb46378705736cb9f1bc7d2244b671cfbd544d5df37ad2f0af46f04fef05731da93eb86539901f5160d2f93eb87f6233da53a0dd3900476e23d11a874cf9af3a136c0801e287898f98032b996fc03285ff94c540f4b95d88faf9f3d60d2b265c574791cc99f7dad9b69500b08ef8160c6297a34957a4cc43e9d05ac29e4249053c0dc271f4d3e07b2851804c1d8cbe798e6b3e8cbef7ca7aa4878b5bdccadc59881c70499b01bd08b2c20bea4f2dec5522ce4ee4d14183cb5d08657efcd3103924b1907d67014211d204914fc93314d6a2660800c3b1ee010cc901a9b7a0bfa2b6392e3172f582b7e6b79c1282bef68ef03209b1c2467be80aa5e434469de9dfc2d9e3b46f960709d54e94befdf8ceb1a4462740a98915528a11b38545da8ea24b3677ba04a593091449dfc99146cf13e17b5fd04a74a67daebb3d0927cf6240210971a1b8fb42c6c7005825e4eccb7bf72388be5a511c62bd06a987e50af6c02a6a10e4e6065fa7708482d0864d0de13c4c0c314a799ff44a0db502a1f93bb4c142d6d Hey, password is required here.","tags":["时间"],"categories":["Linux"]},{"title":"NTP 相关内容备忘","path":"/2025/10/31/0013-ntp/","content":"注意事项 NTP 使用 UDP 123 端口。 ntpd 既可以作为服务端程序，也可以作为客户端程序。所以当设备仅使用 NTP 客户端功能时，要在 etcntp.conf 中增加以下内容： restrict default kod nomodify notrap nopeer noqueryrestrict -6 default kod nomodify notrap nopeer noquery #针对ipv6设置# 允许本地所有操作restrict 127.0.0.1restrict ::1 配置文件etcntp.conf NTP 服务（如 ntpd）的主配置文件，核心作用是定义 NTP 服务器的运行规则，包括时间同步的来源、客户端的访问权限、安全认证方式等，直接决定 NTP 服务如何工作 etcntpkeys NTP 服务用于身份认证的密钥文件 文件中每行定义一个密钥，格式为：[密钥ID] [密钥类型] [密钥内容] $ cat /etc/ntp/keys10 M 123 密钥 ID：1-65535 之间的整数，用于在 NTP 配置中引用该密钥（如 trustedkey 1 表示信任 ID 为 1 的密钥）。 密钥类型：通常为 M（MD5 加密，最常用），也支持 S（SHA-1）等，指定密钥的加密算法。 密钥内容：由字母、数字或特殊字符组成的字符串（建议长度 8-32 位，复杂度越高越安全）。 常用命令网络抓包tcpdump udp port 123 -w ntp.pcap ntpdate 使用的是系统随机分配的空闲端口。 ntpqntpq -np ntpq -crv 查看认证状态 ntpq -c as ntpdate# x.x.x.x是 NTP 服务器的 IP 地址ntpdate -u x.x.x.x 认证相关 ntpdate -a 10 -k /etc/ntp/keys x.x.x.x 在对时间有严格要求的生产环境下，使用 ntpdate 可能会产生严重的后果。 ntpd 是步进式的逐渐调整时间，而 ntpdate 是断点更新，比如现在服务器时间是9.18分，而标准时间是9.28分，ntpd 会在一段时间内逐渐的把时间校准到与标准时间相同，而 ntpdate 会立刻把时间调整到 9.28分。","tags":["NTP"],"categories":["编程"]},{"title":"keepalived - VRRP 协议","path":"/2025/10/30/0010-keepalived-00/","content":"虚拟路由冗余协议 VRRP (Virtual Router Redundancy Protocol) 主机设备通过网关与外部网络联系，当网关出现故障时，主机设备将与外界失去联系。 VRRP 将多台设备组成一个虚拟设备，通过将虚拟设备的IP地址配置为网关，当网关设备发生故障时，VRRP 机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。 概念 VRRP 路由器(VRRP Router)：运行 VRRP 协议的设备，它可能属于一个或多个虚拟路由器。 虚拟路由器(Virtual Router): 又称 VRRP 备份组，由一个 Master 路由器和多个 Backup 路由器组成，被当做一个共享局域网内主机的缺省网关。 Master 路由器：承担转发报文任务的 VRRP 设备。 Backup 路由器：一组没有承担转发任务的 VRRP 设备，当 Master 路由器出现故障时，它们将通过竞选成为新的 Master 路由器。 VRID：虚拟路由器标识，在同一个 VRRP 组内的路由器必须有相同的 VRID。 虚拟 IP 地址(Virtual IP Address)：虚拟路由器的 IP 地址，一个虚拟路由器可以有一个或多个 IP 地址。 IP 地址拥有者(IP Address Owner)：如果一个 VRRP 设备将虚拟路由器 IP 地址作为真实的接口地址，则该设备被称为 IP 地址拥有者。如果 IP 地址拥有者是可用的，通常它将成为 Master 路由器。 虚拟 MAC 地址(Virtual MAC Address)：格式：00-00-5E-00-01-{VRID} (VRRP for IPv4); 00-00-5E-00-02-{VRID} (VRRP for IPv6)，其中 00-00-5E 是 IANA 组织分配的，00-01 是为 VRRP 协议指定的，VRID 是虚拟路由器标识，取值范围为[1-255]。当虚拟路由器回应 ARP 请求时，使用虚拟 MAC 地址，而不是接口的真实 MAC 地址。 非抢占方式：如果 Backup 路由器工作在非抢占方式下，只要 Master 路由器没有故障，Backup 路由器即使被配置了更高的优先级，也不会成为 Master 路由器。 抢占方式：如果 Backup 路由器工作在抢占方式下，当它收到 VRRP 报文后，会将自己的优先级与通告报文中的优先级进行比较。如果自己的优先级更高，就会主动抢占成为 Master 路由器。 VRRP 路由器的优先级0优先级为 0 用于指示当前虚拟路由器的 Master 路由器停止参与 VRRP 组。主要用于触发 Backup 路由器快速地迁移到 Master 路由器，而不用等待当前 Master 路由器超时。 255如果 VRRP 路由器是虚拟路由器地址的IP地址拥有者，那么其优先级必须为255。 1-254Backup 路由器的优先级必须在1–254之间。缺省的 VRRP 路由器优先级为100。 典型组网案例主备备份业务仅由 Master 路由器承担，当 Master 路由器出现故障时，才会由选举出来的 Backup 路由器接替它工作。 负载分担在路由器的一个接口上可以创建多个虚拟路由器，使得该路由器可以在一个虚拟路由器中作为 Master 路由器，同时在其它的虚拟路由器中作为 Backup 路由器。 为了实现业务流量在 Device A、Device B 和 Device C 之间进行负载分担，需要将局域网内的主机的默认网关分别设置为虚拟路由器1、2和3。 在配置优先级时，需要确保三个虚拟路由器中各路由器的 VRRP 优先级之间形成一定的交叉，使得一台路由器尽可能不同时充当 2 个 Master 路由器。 keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"每天最重要的2小时 - 02","path":"/2025/10/29/0009-two-awesome-hours-02/","content":"我们的大脑能量是驱动我们行为的燃油，如果没有了它，我们就寸步难行。 什么会让你心理疲惫“执行功能”指的是大脑所拥有的各种控制和决定方向的功能。大脑的执行功能包括做出决定、做计划，必要的时候，还要短暂地记住一些想法。 进行自我控制往往会削弱我们的自控力。当进行自控行为之后，我们的这部分大脑功能往往会显得疲惫。 即使是做一些典型的、日常的、不重要的决定，也会让人在接下来的自控性任务中缺乏动力。 情绪决定你的表现情绪能够帮助我们解决和应对眼前的情况。 愤怒或不快能够让我们积极应对某些特定的想法和行动。下一次，如果你明知冒这个险才是正确的，却又不敢冒险，不妨让自己愤怒起来。 当我们感到悲伤时，往往会在做决定时尽量少带成见。 焦虑是一种能让我们高度警觉、对任何突发状况做好准备的情绪。 如果想让自己在那些不太重要的事情上放开手，如果要发挥自己的创造力，如果需要做出迅速的决定，试试带着积极的情绪去面对。 如何管理心理能量首先要分辨出那些工作最容易极大地消耗你的心理能量。在进行需要自己百分百投入的工作之前，一定要尽可能地避免做那些消耗心理能量的事情。 如果你在做完某项任务之后觉得很累，很有可能就是它让你消耗大量的自控力。 试着做一做下面这四件事： 早上第一件事（真正的第一件事，在看任何社交媒体之前）就是完成你最重要的工作。想想你自己手头上最具创造性、最有意思的工作，或者长远来看最有益的工作是什么，然后在早晨花一两个小时去做。 考虑一下今天所有的待办事项，把他们分类为重要的、创造性的、其他。在一天中较晚的时候完成其他分类里的工作。 试试在下午花上一个小时阅读并回复你的电子邮件。 在第二天有重要活动时，头天晚上就提前做一些决定，比如穿什么，早餐午餐吃什么，也可以是重要的决定。 迅速补充心理能量的三种方法： 缓慢地深呼吸一会儿。 尽情地大笑一场，积极的情绪可以为我们“充电”。 短暂地打个盹儿。10分钟的短暂睡眠能够帮助缓解疲劳，还能够提升警觉度以及许多不同的认知功能。 有时候果断地放弃一些事，以保证自己在最重要的时刻拥有良好的状态，对我们而言或许更有帮助。 为了真正利用好你的心理能量，你需要做的是出色地完成事关紧要的工作，而不是平庸地完成所有的工作。 结论：让你的效率达到最大化下一次，如果你发现自己正处于抉择点，能够开始一项新任务时，请务必回顾一下：刚刚完成了那些任务？大脑是否已经因为做出了太多决定而疲惫不堪？目前的情绪如何？它们有没有影响到你的下一项任务？ 反思Dan Koe 的视频中确实也有提到愤怒的情绪的作用。 某天，我发现折腾博客的个性化配置会让我很累。 时间管理不是把日程塞满。 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"keepalived - VRRP 同步","path":"/2025/10/28/0010-keepalived-03/","content":"Keepalived 的 VRRP 同步功能（即同步组，sync groups）解决了复杂网络环境中的一个关键问题：在此类环境中，多个 VRRP 实例可能需要维持状态一致性。若缺乏同步机制，各个 VRRP 实例会各自进行独立的状态转换，这可能导致 “脑裂”（split-brain）场景或路由路径不一致的问题。 keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"Source Insight 配置记录","path":"/2025/10/28/0012-source-insight/","content":"快捷键 F5: 跳转到指定行 F8: 高亮选中 Ctrl + /: 全局搜索 Source Insight 的两种高亮方式1. 自动高亮（鼠标点击高亮） 打开选项设置：在菜单栏中选择 Options File Type Options…。 勾选高亮选项：在弹出的窗口中，找到并勾选 Highlight references to selected symbol 选项。 效果如图 2. 快捷键手动高亮 选中要高亮的部分，点击 F8 效果如图","tags":["SourceInsight"],"categories":["编程"]},{"title":"keepalived - VRRP 调度器","path":"/2025/10/28/0010-keepalived-02/","content":"代码版本： https://github.com/acassen/keepalived/releases/tag/v1.1.12 通告处理VRRP 调度器处理传入的 VRRP 通告，并根据实例的当前状态对其进行处理： 代码流程vrrp_read_dispatcher_thread vrrp_dispatcher_read /* read affect received buffer */ read(fd, vrrp_buffer, VRRP_PACKET_TEMP_LEN); /* Searching for matching instance */ vrrp = vrrp_index_lookup(hd-vrid, fd); /* Run the FSM handler */ prev_state = vrrp-state; VRRP_FSM_READ(vrrp, vrrp_buffer, len); /* MASTER */ vrrp_leave_master vrrp_state_master_rx /* Process the incoming packet */ ret = vrrp_check_packet(vrrp, buf, buflen); if (Lower priority) vrrp_send_adv(vrrp, vrrp-priority); vrrp_send_gratuitous_arp(vrrp); return 0; else vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); vrrp-wantstate = VRRP_STATE_BACK; vrrp-state = VRRP_STATE_BACK; return 1; /* BACKUP */ vrrp_backup vrrp_state_backup if(Higher priority) vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); else vrrp-wantstate = VRRP_STATE_GOTO_MASTER; vrrp_send_adv(vrrp, vrrp-priority); vrrp_send_adv VRRP 协议报文封装在 IP 报文中，发送到分配给 VRRP 的 IP 组播地址 在IP 报文头中 源地址为发送报文接口的主 IP 地址 目的地址为 224.0.0.18 TTL 必须是 255。（VRRP 路由器会丢弃 TTL 不等于 255 的 VRRP 协议报文） 协议号是 112 /* send VRRP advertissement */vrrp_send_adv /* build VRRP packet */ vrrp_build_pkt(vrrp, prio) /* build IP header */ vrrp_build_ip ip-ttl = VRRP_IP_TTL; ip-protocol = (vrrp-auth_type == VRRP_AUTH_AH) ? IPPROTO_IPSEC_AH : IPPROTO_VRRP; ip-saddr = VRRP_PKT_SADDR(vrrp); ip-daddr = htonl(INADDR_VRRP_GROUP); /* checksum must be done last */ ip-check = in_csum((u_short *) ip, ip-ihl * 4, 0); /* build the vrrp header */ vrrp_build_vrrp(vrrp, prio, vrrp-send_buffer, vrrp-send_buffer_size) keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"Linux 进程间通信：共享内存","path":"/2025/10/27/0011-ipc-shm/","content":"头文件 sys/shm.h shmget 创建共享内存 第一次创建完共享内存时，它还不能被任何进程访问 int shmget(key_t key, size_t size, int shmflg); shmat — at：attach 启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间 void *shmat(int shm_id, const void *shm_addr, int shmflg); shmdt — dt：detach 将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用 int shmdt(const void *shmaddr); shmctl — ctl：control 控制共享内存 int shmctl(int shm_id, int command, struct shmid_ds *buf);","tags":["进程间通信"],"categories":["Linux"]},{"title":"keepalived - VRRP 状态机","path":"/2025/10/27/0010-keepalived-01/","content":"代码版本： https://github.com/acassen/keepalived/releases/tag/v1.1.12 VRRP 状态机VRRP_FSM Read_to: read timeout struct void (*read) (vrrp_rt *, char *, int);\tvoid (*read_to) (vrrp_rt *); VRRP_FSM[VRRP_MAX_FSM_STATE + 1] =/* Stream Read Handlers | Stream Read_to handlers * *------------------------------+------------------------------*/\tNULL, NULL,\tvrrp_backup, vrrp_goto_master,\t/* BACKUP */\tvrrp_leave_master, vrrp_master, /* MASTER */\tvrrp_leave_fault, vrrp_fault, /* FAULT */\tvrrp_become_master, vrrp_goto_master\t/* GOTO_MASTER */; VRRP FSM Macro/* VRRP FSM Macro */#define VRRP_FSM_READ_TO(V) \\do \\ if ((*(VRRP_FSM[(V)-state].read_to)))\t\\ (*(VRRP_FSM[(V)-state].read_to)) (V);\t\\ while (0)#define VRRP_FSM_READ(V, B, L) \\do \\ if ((*(VRRP_FSM[(V)-state].read))) \\ (*(VRRP_FSM[(V)-state].read)) (V, B, L);\t\\ while (0) VRRP_TSM当某个 VRRP 实例发生状态变更，且需要与其同步组（sync group）内的其他实例进行协调时，将使用 VRRP_TSM 。 使用方式可以理解为：VRRP_TSM[from_state][to_state] struct void (*handler) (vrrp_rt *); VRRP_TSM[VRRP_MAX_TSM_STATE + 1][VRRP_MAX_TSM_STATE + 1] =/* From: To: BACKUP MASTER FAULT *//* v */ NULL, NULL, NULL, NULL ,/* BACKUP */ NULL, vrrp_sync_master_election, vrrp_sync_master, vrrp_sync_fault ,/* MASTER */ NULL, vrrp_sync_backup, vrrp_sync_master, vrrp_sync_fault ,/* FAULT */ NULL, vrrp_sync_backup, vrrp_sync_master, vrrp_sync_fault ; VRRP TSM Macro#define VRRP_TSM_HANDLE(S,V) \\do \\ if ((V)-sync \\ S != VRRP_STATE_GOTO_MASTER) \\ if ((*(VRRP_TSM[S][(V)-state].handler)))\t\\ (*(VRRP_TSM[S][(V)-state].handler)) (V);\t\\ while (0) 状态图 初始化期间，从 INIT（初始化）状态开始 若所有检查均通过，则转换至 BACKUP（备份）状态 若未从优先级更高的主用（MASTER）设备接收到通告消息，则转换至 MASTER（主用）状态 若接收到优先级更高的通告消息，则转换至 BACKUP（备份）状态 若任何被跟踪的资源发生故障，则转换至 FAULT（故障）状态 当故障条件清除后，返回至 BACKUP（备份）状态 INIT 状态/* Initialize state handling */static voidvrrp_init_state(list l) for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) vrrp = ELEMENT_DATA(e); if (vrrp-priority == VRRP_PRIO_OWNER || vrrp-wantstate == VRRP_STATE_MAST) vrrp-state = VRRP_STATE_GOTO_MASTER; else vrrp-ms_down_timer = 3 * vrrp-adver_int + VRRP_TIMER_SKEW(vrrp); vrrp-state = VRRP_STATE_BACK; BACKUP 状态 当处于 BACKUP（备份）状态时，该实例会设置一个 master_down_timer（主用设备下线计时器）。 每当从优先级更高的主用（MASTER）设备接收到有效的通告消息（advertisement）时，此计时器就会重置。 若计时器超时（即在超时周期内未接收到任何通告消息），该实例将转换至 MASTER（主用）状态。 /* Handle dispatcher read timeout */static intvrrp_dispatcher_read_to(int fd) /* Run the FSM handler */ prev_state = vrrp-state; VRRP_FSM_READ_TO(vrrp); // vrrp_goto_master /* handle instance synchronization */ VRRP_TSM_HANDLE(prev_state, vrrp); MASTER 状态 拥有并维护虚拟 IP 地址（VIPs）。 按照配置的时间间隔发送定期的 VRRP 通告消息。 处理接收的 VRRP 通告消息，若接收到优先级更高的通告消息，该实例将转换至 BACKUP 状态。 static voidvrrp_master(vrrp_rt * vrrp) if (vrrp-state == VRRP_STATE_MAST) vrrp_state_master_tx(vrrp, 0); FAULT 状态由于出现错误条件，该 VRRP 实例无法以 MASTER（主用）或 BACKUP（备份）状态正常运行。 keepalived","tags":["高可用","keepalived"],"categories":["编程"]},{"title":"每天最重要的2小时 - 01","path":"/2025/10/21/0009-two-awesome-hours-01/","content":"意识到每天的关键时刻–抉择点我们一旦开始了一项神经性常规活动，就会像电脑程序一样一直运行下去，直到完成任务，或是被打断。 实际上，每一天都是由一系列习惯性的神经常规程序组成：早上起床、穿好衣服去上班、打开电脑、回复电子邮件等。问题在于，我们经常会从一个任务跳到另一个任务，却不仔细想想下一步最好该做什么。 学会意识到一天的当中的几个特殊时刻，在这种时刻，你有机会也有能力决定自己将如何度过接下来的时间。 做出最恰当的选择当常规程序结束的时候，自我意识就会浮现出来。意识最重要的功能就是在我们的自动式神经常规活动遇到困难的时候做出决定。 抉择点通常是作为冲突–无意识的自动行为之间的冲突、行为和目标之间相冲突–的结果而出现的。正因为这些抉择点会令人不舒服，我们往往才选择尽快跳过它们。 忽略抉择点的坏处匆忙跳过抉择点，很可能接下来进行的任务并没有那么重要，或是不适合在这段时间完成，损失也许会更大。 充分利于抉择点的三个诀窍在这一刻，对我们而言究竟什么最为重要。 珍惜每一个抉择点 意识到抉择点的出现，并尽力抓住它；要承认它的存在，而不是无视它，一头扎进无意识思维指引你去做的下一个任务里。 抉择点能够让你与眼下最关注的事保持一定的“距离”。 提前为抉择点做好相应计划 “计划不去做某件事”常常会失败，关键的一点是，你做的计划要让自己在这一刻进行一项新的活动–一项你乐意做的事。 当我们在脑海中设想某一个行动时，所利用的神经回路其实和真正去做这件事时的神经回路相同。 不要随便开始一项新任务，除非已经有意识地决定了它确实值得做。 一旦你完成一项任务，不要去想接下来自己可以是轻松地做些什么，而是把这一刻标记为抉择点。 怎么决定什么事最值得花时间？判断依据之一就是自己当天最重要的任务。 结论：聪明地安排你的时间用途在完成不同任务的间隙之间，我们终于从忘我工作的状态中脱身而出，这些时刻实在是不可多得的礼物，而我们完全应该审慎地利用这些时刻。 反思 早上睡醒之后，会无意识的在社交软件，购物软件之间来回跳转。（睡前将手机放在客厅。） 下班前会突然冒出不想运动的想法。（想象下班后运动的过程。） 每天最重要的2小时","tags":["每天最重要的2小时"],"categories":["读书笔记"]},{"title":"孕期检查备忘录","path":"/2025/10/20/0008-pregnancy-checklist/","content":"名词解释13+6医生关于孕期的常用描述，13 是指第13周，+6 则指的是第6天，比如 NT 检查需要在 11 到 13+6 这段时间进行，意思就是需要在第11周到第13周的第6天之间的这段时间进行。 重要时间节点NT 检查 时间：孕11周到孕13+6周 通过B超检查胎儿颈项透明层的厚度。 建档（母子健康手册） 时间：孕12周 一本粉红色的小册子，需要保留到孩子上学。 建档需要进行抽血检查，所以当天早上记得不要吃早饭。建档之后，需要按照时间要求，定期到医院进行孕期检查。 准生证（生育登记证明） 时间：怀孕3个月后 准生证应该是计划生育时期的叫法，现在应该都是通过各地的相关公众号进行的。 唐氏筛查 时间：孕15周到孕20周（以医生建议为准） 用于评估胎儿患有唐氏综合征的风险。","categories":["生活记录"]},{"title":"顺风车车主初体验","path":"/2025/10/19/0007-hitch/","content":"更新记录：2025-10-28：偶然看到保险会以非运营车辆进行营运拒赔的说法，所以最终还是把所有平台注册的顺风车给注销了，避免不必要的麻烦吧。 在国庆节的末尾进行了爱车的第4次保养，我已有两年的驾龄，由于最近经常需要在周末开车往返于两地，所以下定决心跑一下顺风车平摊路费。 在没有注册成为顺风车车主之前的想法是顺路了就接一单，实在没有就算了，也不指望创收；但在成为车主之后，我的行为竟然瞬间出现了变化，我发现自己早早的发布了几天之后的出行信息，开始频繁的查看三个平台寻找合适的乘客，在乘客莫名其妙的取消订单之后觉得失落，在没有订单的情况下觉得要不再等等看有没有合适的。 在体验了一次顺风车车主的行程之后，我发现与我希望的方式（不接不送，顺路上下）不同，无论是高德、哈啰，还是滴滴，都需要车主按照乘客指定的起点和目的地进行接送。 因此我决定记录并提醒一下自己跑顺风车的最初想法和要求： 不需要跑顺风车创收，有合适的就跑，没有也无所谓 三环以内的订单不接（感受过市区下班高峰期之后的第一个决定） 距离我的起点和终点超过10公里的订单不接 每周五查看平台信息即可 接单后，及时与乘客电话沟通确认 除了上述提到的三个平台之外，在我的城市还有一个公众号平台，早期我也确实作为乘客体验过三四次，这个公众号上车主发布自己的具体行程，乘客依据自己的出行需求选择合适的订单，并主动与车主电话沟通。 哦，对了，那顺便说一下三个平台的逻辑， 高德：车主端可以看到乘客发布的行程；乘客也可以看到车主发布的行程；双方可以根据行程信息相互进行邀请 哈啰：暂时没有体验到 滴滴：乘客发布自己的行程，但看不到车主发布的行程，只能被动等待；需要车主依据自己的行程选择合适的订单 对比下来，我更喜欢高德的顺风车方式，不过感觉好像滴滴上的订单更多。","tags":["顺风车"],"categories":["生活记录"]},{"title":"结构体的内存对齐和变长数组","path":"/2025/10/15/0006-c99-vla/","content":"引入项目中业务模块产生的日志在通过本地 socket 发送给日志模块后，日志模块记录的内容总是会丢失前6个字节。经过排查，业务模块和日志模块使用的虽然都是 log_msg_t 结构体，但结构体中的变量类型定义却略有差异，如下所示： 业务模块的结构体定义 typedef struct\tunsigned char type;\tunsigned char level;\tunsigned short size;\tunsigned int pid;\tunsigned int cds;\tunsigned char imm;\tunsigned char u8wf;\tunsigned char data[]; log_msg_t; 日志模块的结构体定义 typedef struct\tunsigned char type;\tunsigned char level;\tunsigned short size;\tunsigned int pid;\tunsigned int cds;\tunsigned char imm;\tunsigned int u8wf;\tunsigned char data[]; log_msg_t; 显然，由于结构体中 u8wf 变量类型的不同，导致出现了内容丢失。但 unsigned char 的大小为1个字节，unsigned int 的大小为4个字节，怎么会出现丢失6个字节的内容呢，这与结构体的内存对齐有关。 内存对齐为什么需要对齐在 C 语言中，结构体的内存对齐是编译器为了提高 CPU 访问内存效率而采取的一种内存布局优化策略，是一种拿空间换时间的做法。 CPU 访问内存时并非逐个字节读取，而是按固定大小的 “块”（如 4 字节、8 字节）读取。如果数据的起始地址是块大小的整数倍（即 “对齐”），CPU 可以一次完成读取；否则可能需要多次读取，影响效率。 内存对齐规则 第一个成员在与结构体变量偏移量为 0 的地址处。 其他成员变量的起始地址必须是 min(该成员自身大小, 编译器默认对齐数) 的整数倍。 结构体的总大小必须是所有成员中最大对齐值的整数倍，即 min(结构体中最宽成员类型的大小, 编译器默认对齐数) 的整数倍。若不足，编译器会在最后一个成员之后添加填充字节以满足此要求。 练习下面两个结构体的大小分别为多少？ typedef struct\tchar c1;\tint i;\tchar c2; S1;typedef struct\tchar c1;\tchar c2;\tint i; S2; S1 和 S2 的内存布局如下图所示: 相关函数sizeof 获取结构体的大小 printf(%ld , sizeof(S1));printf(%ld , sizeof(S2)); offset 宏 计算结构体中某变量相对于首地址的偏移 头文件: #includestddef.h printf(offsetof(S1, c1) = %ld , offsetof(S1, c1));printf(offsetof(S1, i) = %ld , offsetof(S1, i));printf(offsetof(S1, c2) = %ld , offsetof(S1, c2)); #pragma pack() 修改默认对齐数（谨慎操作） // 将默认对齐数修改为 8#pragma pack(8)typedef struct\tchar c1;\tint i;\tchar c2; S1;// 恢复默认对齐数#pragma pack() TIPS在设计结构体的时候要满足对齐规则，又要节省空间，如何做到呢？ 在定义结构体时，将大小相同或相近的成员声明在一起，并且按照从大到小（或从小到大）的顺序声明，可以最大限度地减少填充字节，节省内存。 可变长数组此外，可以看到 log_msg_t 的最后一个元素为 data[], 且如果使用 sizeof(log_msg_t)，可能会发现结果并不符合预期，这一切都与可变长数组的特点相关。 介绍变长数组是在 C 语言的 C99 标准中引入的新特性。结构体中的最后一个元素允许是大小未知的数组。 比如： struct S int n; int arr[]; // 部分编译器可能会报错，可以将 arr[] 改为 arr[0]; 特点 结构体中的可变长数组前面必须至少有一个其它类型的成员。 可变长数组必须是结构体的最后一个成员。 可变长数组不占用结构体的存储空间，使用 sizeof 计算结构体的大小不包含可变长数组成员。 结构体变量相邻的存储空间保存的是可变长数组的内容。 log_msg_t因此，两个模块使用的log_msg_t结构体的内存布局如图所示: 可以看到两个结构体的 data 成员相对于起始地址的偏移量相差 6 个字节，这也就是为什么日志模块记录的内容总是会丢失前6个字节。 优势使用指针struct S int n; int *arr;; 那么在使用时就需要两次 malloc 和两次 free， struct S *ps = NULL;// 动态分配结构体S的内存空间ps = (struct S*)malloc(sizeof(struct S));if (ps == NULL) return -1;ps-n = 10;// 为结构体中的数组成员分配内存ps-arr = (int*)malloc(ps-n * sizeof(int));if (ps-arr == NULL) free(ps);\tps = NULL;\treturn -1;// do something // 释放所有动态分配的内存free(ps-arr);ps-arr = NULL;free(ps);ps = NULL; 使用可变长数组struct S int n; int arr[0];; 使用时只需要一次 malloc 和 free， // 分配内存以容纳结构体S和10个整数的数组struct S *ps = (struct S *)malloc(sizeof(struct S) + sizeof(int) * 10);if (ps == NULL) return -1;ps-n = 10;// do something // 释放分配的内存并置空指针free(ps);ps = NULL; 总结使用指针： 为了防止内存泄漏，如果分两次分配结构体和缓冲区的内存，当第二次 malloc 失败时，必须回滚释放第一次分配的结构体内存。 进行了两次 malloc，需要对应两次 free，如果我们的代码是在一个给别人用的函数中，我们在函数里做了两次内存分配，并把整个结构体返回给用户；虽然用户调用 free 可以释放结构体，但用户并不知道结构体的成员也需要 free，造成内存泄露。 malloc 次数越多，产生的内存碎片就越多，内存的利用率就会降低。 使用变长数组： 连续内存有利于提高访问速度，同时减少内存碎片","tags":["C语言"],"categories":["编程"]},{"title":"我的影视资源解决方案","path":"/2025/10/15/0005-emby/","content":"影视资源站最初主要在一些影视资源站看视频，比如在在线之家看完了全季的《权力的游戏》。 以下是几个仍保留在收藏夹中的资源站： 低端影视 在线之家 NO视频 网盘网盘在很长时间里都是我获取影视资源的主要阵地，从百度网盘、谷歌云盘、阿里云盘，到现在主要使用的夸克网盘。在阿里云盘开始收费后，我发现88VIP会赠送1年的夸克网盘会员（此时，我已持有88VIP将近半年的时间）。 夸克网盘会员(88VIP版)有6TB的存储空间，且在电视上有对应的客户端，几乎满足了我所有的观看需求，但影视墙功能仍需付费开通SVIP才能使用。不过，最近在折腾飞牛OS里提供的飞牛影视可以挂载夸克网盘，并且能够进行直链播放，也是一种免费使用影视墙的解决方案。 PS: 88VIP还提供1年的优酷会员或芒果会员，应该已经能够满足大部分的观影需求。 以下是几个我目前常用的网盘资源搜索网站： 云盘盘 SeedHub 夸克盘 EmbyEmby 在我看来是强者的存在，几乎可以替代爱优腾和各种流媒体平台。互联网上有大量的公益服和付费服，我记得最早使用的是叫做普拉斯影业的公益服，不过目前好像已经不能使用了。 以下是一个关于 Emby 的介绍视频，部分信息已过期，不过有助于你简单了解 Emby。"},{"title":"家庭网络折腾备忘录","path":"/2025/10/14/0004-cucc-modem/","content":"002a748617e5cc304f438c1409bd96526eb4ad4593d4d71e04e8698e3520de0cf8e5545d3a653be200d7127a72677075b27591933b5624dc42316f783c49f5b39cbe5476d1a3a35076c86152eb558d28c39678e517a24164134ed90692d8bcc00395ead76bb9bf955b19704afa3fb2075cb8988f8d95f0d888ee1b9577408744a705fd6d0008bb468613f9e3165557b4881365223a42ae4d5cda13bc70d5f635bc2932f657c2a25e8aac2cf984edcdbd4f56c4da662c37bea241d1efb52c41221c8e663eac64dc536ef2ed9c1315f235e1631b7eb9ad79cf3f1eb466e1d4ea8dd90ccf78a7ff9632a3b584aede277aeec0cf8c338b321fbeaeb833eb5cd5ff1bf6572b52d008132cb3b4a66efdd439eb75e56f271a6d2ff57e84ab760f4d279279cd828a918447fbfceaafbdb556a2513d4629afbba1ffd5b520a690fff390570a8febcf3bdf62b223a4f032ac02c0d731011c6c1bf4cd79f1596d484a6e477183ef99d4f92e03028d4cc176033163aa1f1c5bb1922adcaeaaf03538658f4c223c21e0f7f985e9032730a942ff60c5619f4f344dac000b70427f472ed7b2225d4195a28db1ad60db56a6dcc178a3325542a44e652800c9212138c3c29916fc9ce344bb42d2e54c6f91a678bd9fd8844ab925b7210a19b05d6fd1d7a3f282927cb658efa98d9547e0ebc4a5da9de7ccf847aeca4c67a77e23bb5855dd8d3391a457c7d1918d32545e6a9ef5ea30c2b9758fbd83455d0ef7a69f489d8b95c29122a21bd94b572a99e28766ea16801946cc Hey, password is required here.","tags":["光猫","路由器"],"categories":["网络"]},{"title":"Hello Stellar","path":"/2025/09/30/0003-hello-stellar/","content":"安装主题在根目录执行如下命令： npm i hexo-theme-stellar 主导航栏根目录下的 _config.stellar.yml # 侧边栏主功能导航菜单menubar: columns: 4 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 # - id: post # 页面中高亮的 menu_id # theme: #1BCDFC # 高亮时的颜色，仅 svg 中 fill=currentColor 时有效 # icon: solar:documents-bold-duotone # 支持 svg/img 标签，可以定义在 icons.yml 文件中，也支持外部图片的 URL # title: 博客 # 标题 # url: / # 跳转链接，支持相对路径和绝对路径 # - id: wiki # theme: #3DC550 # icon: solar:notebook-bookmark-bold-duotone # title: 文档 # url: /wiki/ # - id: explore # theme: #FA6400 # icon: solar:planet-bold-duotone # title: 探索 # url: /explore/ # - id: social # theme: #F44336 # icon: solar:chat-square-like-bold-duotone # title: 社交 # url: /friends/ 文章模版根目录下 scaffolds 文件夹中编辑 post.md ---# 基本信息title: title date: date tags: []categories: []description: # excerpt 也可 # 封面cover: banner: poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选# 插件sticky: # 数字越大越靠前mermaid:katex: mathjax: # 可选topic: # 专栏 idauthor: references:comments: # 设置 false 禁止评论indexing: # 设置 false 避免被搜索breadcrumb: # 设置 false 隐藏面包屑导航leftbar: rightbar:h1: # 设置为 隐藏标题type: # tech/story--- 文档系统（wiki）source 目录结构如下： .+ ├── _data+ │ ├── wiki+ │ │ └── hexo-cpp.yml+ │ └── wiki.yml ├── _posts │ ├── hello-hexo.md │ ├── hello-stellar.md │ └── hello-world.md ├── about │ └── index.md+ └── wiki+ └── cpp+ ├── backup.md+ └── index.md hexo-cpp.yml name: C++title: 学习指南subtitle: 从入门到再次入门tags: 博客主题icon: https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/icon.svgcover: https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/icon.svgdescription: 这是一份从入门到再次入门的学习指南。search: filter: /wiki/cpp/ placeholder: 在 Stellar 中搜索...leftbar: - tree - timeline_cpp_releases - relatedbase_dir: /wiki/cpp/tree: 快速开始: - index 网站备份: - backup wiki.yml - hexo-cpp index.md ---wiki: hexo-cpp # 这是项目id，对应 /data/wiki/hexo-cpp.ymltitle: c++--- sites 网站卡片 source 目录的文件结构如下： . ├── _data+ │ ├── links+ │ | └── tool-life.yml tool-life.yml 的内容如下: - title: 中国科学技术大学测速网站 url: https://test.ustc.edu.cn/ cover: icon: description: 非 WIFI 环境下慎点 在需要的位置添加如下内容： % sites tool-life % timeline 时间线静态时间线 在需要的位置添加如下内容: % timeline %!-- node 2021 年 2 月 16 日 --主要部分功能已经开发的差不多了。% image https://res.xaox.cc/gh/cdn-x/wiki@main/stellar/photos/hello@1x.png width:300px ratio:1179/390 %!-- node 2021 年 2 月 11 日 --今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。% endtimeline % 侧边栏组件 参考链接：https://xaoxuu.com/wiki/stellar/widgets/ 在 source/_data 目录下新建 widgets.yml 文件 about_sidebar: layout: linklist columns: 1 items: - icon: svg.../svg # 或者 icons.yml 中设置的 icon 名称 title: 关于 url: /about/ - icon: svg.../svg # 或者 icons.yml 中设置的 icon 名称 title: 说说 url: /memos/ 在使用的地方，如 about/index.md中添加如下内容： ---leftbar: [about_sidebar]--- hexo","tags":["hexo"],"categories":["博客"]},{"title":"Hello Hexo","path":"/2025/09/30/0002-hello-hexo/","content":"本文描述的过程主要为如何在本地部署Hexo。在了解和熟悉本地部署的流程之后，更推荐利用 GitHub Actions 实现自动化部署 Hexo 到 Github Pages。 前置条件安装下列软件： Node.js Git 安装安装 hexo: npm install -g hexo-cli 查看版本： hexo v 创建创建 blog 文件夹mkdir blogcd bloghexo init 部署 hexohexo g 本地化预览hexo s 写作创建草稿hexo new draft hello-hexo # hello-hexo 为文件名 发布hexo publish hello-hexo # hello-hexo 为文件名 图片全局资源文件夹如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。 然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 文章资源文件夹将 config.yml 文件中的 post_asset_folder 选项设为 true post_asset_folder: true 在通过 hexo new [layout] title 命令创建新文章时，会自动创建一个与文章同名的文件夹。将所有与该文章有关的资源放在这个关联文件夹中之后，可以通过相对路径来引用它们。 相对路径引用的标签插件当打开文章资源文件夹功能后，把一个 example.jpg 图片放在资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](example.jpg) ，它将不会出现在首页上。 正确的引用图片方式是使用下列的标签插件 ： % asset_img example.jpg This is an example image %% asset_img spaced asset.jpg spaced title % GitHub Actionsname: Deploy Hexo to GitHub Pageson: push: branches: - main # 或你使用的默认分支名称jobs: deploy: runs-on: ubuntu-22.04 steps: - name: Checkout blog source uses: actions/checkout@v4 with: path: blog - name: Set up Node.js uses: actions/setup-node@v4 with: node-version: 22 # 设置 Node.js 版本 - name: Cache dependencies uses: actions/cache@v4 with: path: node_modules key: $ runner.os -node-$ hashFiles(**/package-lock.json) restore-keys: | $ runner.os -node- - name: Install dependencies run: npm install working-directory: ./blog - name: Install Hexo CLI run: npm install -g hexo-cli working-directory: ./blog - name: Install Hexo Theme run: npm install hexo-theme-stellar working-directory: ./blog - name: Generate static pages run: hexo generate working-directory: ./blog - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v4 with: personal_token: $ secrets.PERSONAL_TOKEN publish_dir: ./blog/public external_repository: username/username.github.io # 更改为你的 GitHub Pages 仓库, username 是你的用户名 publish_branch: main # GitHub Pages 分支 hexo","tags":["hexo"],"categories":["博客"]},{"title":"Hello World","path":"/2025/09/30/0001-hello-world/","content":"10d79030e8222445804370796b90fca1cf7dd2ee01010d95413afa643c36d75c6da7dc8584583c53132d123565a83bc482d57efe09dbb13f6be1ebadf67b396c5e9af14ae37a94b87d779719bc8c1cd1a95420a6d53586101970b6bd1e11383c5fb9eb6a2afd2dfd764940c736e232c31819ba63da4a7c6eb6c1003cc6443dcf2082b9f749ca03a1484b87b08c908b3c310d7b631064a7fc3f9ca36177e4c3059978875c3caa78a7dceb6037a9522caf5c4adf858dd97440561f76a5ba5e4fd77e9898dfeb4cad54c4bb643f9c0ecbaef49a3431bdd2455830a88255232397afbbe9b23eb9395dfae6f0824e03416bc0b3804386abdc6c923976a913424fdbf1ba89bde972822239ac5e9109f398b65ae65ef00629508a203d30649f6408e1f61f5f6e73d99349907d745bd4c4ef0763621826913a2677273e3b66ae19439d1940d9ebcc45d324738506f0ac5dca5093adf45b82a24da2d49432e9f7cea3b56d73ea8b80628014008c75e6df0aa070ccdaa53907f1adc5e6234b2ab2f7f8485fb9383dc64927d631e20713c7d719815e20c9d6247aa120998e681a19e43d40ca49e20ce7419d535072ff85e74c96caabe848f11f049126a6f4cbbfc746a3cae3d4b6c98db711e8b3bdbd372def67e3d1bf776ee35037a2377d5898704789976ec22fc47c64eb83da5766f0408afee5b438701c6084a1025c673100e7ac0cf710407782790b56679a3fbb40313022e90f715c1a39914fe4b710beb621310bee163ece727a9d02da8b2ef0925acbeedbed1bdf2fb2a5a106956f607dcb5fcef0e36a97afa6fe5d415be51d647cc196fec6186575845eba2577edf79b237f40501d9e0516fe26fcc18e5bb029218ceea51ed6571ed6499c1b863fe5e4184373aee7af54e687aecc3ffa4986afe90e3a5fd67d73f47c0c882443054fed1625259e96370f07d55431f1a03130d5486c9ac1bc2c51d48a7b31ca8c81fdd6cc8795e3296ee5cc4dd66f3e582583d5516a299f41c5bc32710ee392ddb18d02b9fea50df38fbea6579d1f8a7a1ec2fdcff1a546b8a51d96657a2c6538c2dc93476d69467cb3671b880c09d3c422cfb3bb9199050f0c77a137b4b0dbdb4041a1be97361f0b783b6ab8bbbdcfdf1c9d545e17a129eca1e4cc3aabe88b7ab633ec35eacbb26e1b4b8c0876bd6ed5f351cc4d04c974e55a4f37f0580b599953ae28a9a6f6ea344c8bee255996315fa0673b087d06f292b6f9e84801a38c8ffea05fecb03b16577db7697bbac072e1d372bf5fb0dfd48bdb369ba8ac97c5f3f8b3173cbee017a98e2eea5f78edd3ad8ae87ff061a3e43ccbb435291c501139a80744cf59040e4b980306c75cfb527b82fe4c578a8973a6a75baeb2be249b344f14cd6153f99e07309fee10b0e8e4702ded0dbde9bcc5b0eb0d117b479db98f93d36f1c8721a712a9650023572dd95effb7718f45c2948d9192a1d27b38e652903d68992618f4c9feee5c5dfc2fcb15fbf1d3fd5896245a14bc1bdabb6dddb4db0ea3fc36165bbc4b56ffbbb0ed570e77f7d8820a5078d5fe499945473ff216f85fe92c706d7aa308198dfcd4d85abe4f1fcb8924d6b5c72b05a03333c163fedfef1f479daeff26a1d99802645980fefa0f8be445851c3f508e0b5ee79b06b504a054b4e7ad26f9d0344d2395322d452565b03020d13fe150bbc9ca3e433e04e3411da56239b42807d0090d11b5858ff8487212fb6771f4914fdcd8393d2cd2150eb82d8e82be0db2e71679f2f78d5b22b32a305993748f09821838303b75df669acf24e08c3eab2fe0433662a1056cc392ccecc20041dbf44a229ada35bed43255979bfd7e150b6e812c6c23466dd45e57c5b443d976b298b5f5e4d977130bcaf5ec26e2e2c727886f3f116fd1fbad331bbf9d1ca9efa141a0174450b00f818e2b59a784a40b77918ba82e75a31bd542e611a43010f08fc30369e93386f239e5fb9a515d6c2afc272997890c0ec4619f78f4b5fed881f0002b85e8165088649391e0249613310e523cdf5e2dfd5d4b4236bf38c02fb72341cfe539508f7af5c7db00d07b8425db13d92aa628930b5521eba6daf54fce1a8a6a36e1b095f67ebadd2fb0c096012eee795a471f33f501a0fef0a9075dfce83a3227087b12382ff22011db6d7fc3cc877c19d425b5b672b574f4df7643bee516ecdc66629c21963733bea688bc205c9add0c36479130ca3eee5dc72698d00713bf52775cba1634cf4cdb9d5856c60135524af408c949847e6cce9729997a3858154a3cf638ec1f1d326b3caa59b6a3555f947a761998b37a3890339d86cf8eaaf75260de0475d5ba017d78d7e2671849c4f8924658a4fa3a6bb478e5dde99ccb965fc5f099418feda6e45cb85e810e253d8da0ec932b4f426793cb86b882291a6d98f048b162b71dd6888262a0e3d96caa0538f96845e3bddee62faf30f9b8e3176953e68652ed0b429f284bbd828de3d2c4815b2b69cd2f5cd993b1bcf65d2c8b67f3a5cc99dab9d029d01f9730eccf97c48dcfefbd9c3589bee7e98ebc76468ce1e4d47c4a4c89e275bb743892c4b8558d8ea957afa93b5ce2bd02f94ee38eb9fdcddcb8231584cc840b914a3eefe46c659029555aa0c43e523b507722c6753aa625f67b07ade89ad34eabd449f4c1d2822e0a0f435ce2602c2f5427dabec0f8cee68c5d64d9685cfc8e367505320dff6026c07f62ddb32c3039fe867067bcac7347b455893575e795974c91cd2b13bfe2341efd7b5e24b81aac898e60bb569def27c91bd3554bcf25d039002a7541daf01684f1aa4e4eb493a7ef9d3ab8c8489f98da8bf72989e524f97268729a6f437727d3354db4d2e5890f9b70fe2daa36cfbba178ccb0ead684e862eacb694e5c22f388c7d8b1f360f0459117529cf67e806255f61f71f840674c20c1b6c9b0ba4072bb7b1e19abec986c902fa25e735c93371dfb51ec15e9a2440cf886f29bc4e911d7c8925922efbc893b336161da60f33600143637d99e132a76da2087f75934b4997351f5e29ce8da8b847b61959afe5e9c612a2cc64730cf8dcb02cd15002ed3ec0088023a12023dcab79efe9d7f1f1d222b1193c79f0bab1a8e6a2dff9665327e827e675d76d3555cdc880e Hey, password is required here."},{"title":"关于","path":"/about/index.html","content":"2025 年 11 月 7 日增加评论功能。2025 年 9 月 30 日使用 hexo + stellar 重新部署博客。"},{"title":"探索","path":"/explore/index.html","content":"工具纸由我 PaperMe在线自定义打印纸生成器PDF24PDF工具中国科学技术大学测速网站非 WIFI 环境下慎点 公开信息查询中国裁判文书网https://wenshu.court.gov.cn/专利查询世界知识产权组织的免费专利数据库wikiHow互联网上最值得信赖的指南网站 自用闪卡导入 CSV 创建卡片引导"},{"title":"说说","path":"/memos/index.html","content":"2025 年 11 月 4 日在晚上运动后，立刻开始整理《每天最重要的2小时》的读书笔记，感觉确实不错。这也能够驱使我晚上坚持运动。2025 年 10 月 30 日如何做一个有质量的技术分享：问题 - 方案 - 总结2025 年 10 月 29 日昨晚无意间刷到一个外卖员练习英语的视频，想到自己也可以下载一个多邻国试试。"},{"title":"code","path":"/wiki/cpp/index.html","content":"工具DeepWikihttps://deepwiki.com/TemplateRepoCxxVS Code C++项目模板PlantUMLhttps://plantuml.com/zh/Linux Manpagesman 手册 C++恋恋风辰的官方博客https://llfc.club/homeCppGuide社区https://cppguide.cn/c++自救指南https://www.blogchn.com/pages/3001d9/c++全栈知识体系https://stibel.icu/阿荣的个人网站https://www.arong-xu.com/ linux开发内功修炼https://kfngxl.cn/熊喵君的博客https://pandaychen.github.io/文先生的博客https://wenfh2020.com/ other技术文章摘抄https://learn.lianglianglee.com/深入高可用系统原理与设计https://github.com/isno/theByteBookTCP/IP详解 卷1：协议在线阅读版（全网唯一）"},{"title":"interview","path":"/wiki/cpp/interview.html","content":"CVLapisCVhttps://github.com/BingyanStudio/LapisCV 八股阿秀的学习笔记https://interviewguide.cn/小林codinghttps://xiaolincoding.com/卡码笔记https://notes.kamacoder.com/ 刷题代码随想录https://github.com/youngyangyang04/leetcode-master"},{"title":"编译与运行","path":"/wiki/cpp/tws-build.html","content":"开发环境 WSL2 + Ubuntu-24.04 mysql-8.0.43 MySQL 安装与配置 mysql-server 安装 sudo apt-get updatesudo apt-get install mysql-server# 查看 mysql 的版本mysql --version 客户端库开发包安装，提供头文件和链接库 sudo apt-get install libmysqlclient-dev 数据库建立登录 MySQL 服务# 远程mysql -h localhost -P 3306 -u root -p# 本机mysql -u root -p 可能会遇到如下报错信息： ERROR 1698 (28000): Access denied for user root@localhost 这是因为MySQL默认使用了 UNIX auth_socket 插件进行认证。解决方案可参考：stackoverflow。 这里使用回答中推荐的第2种方案，即创建一个与系统用户一致的新的数据库用户： 注意：tws 可修改为自定义用户名 $ sudo mysql -u rootmysql USE mysql;mysql CREATE USER tws@localhost IDENTIFIED BY ;mysql GRANT ALL PRIVILEGES ON *.* TO tws@localhost;mysql FLUSH PRIVILEGES;mysql exit;$ sudo service mysql restart 之后登录 MySQL 服务就可以使用如下命令： $ mysql -u tws -p# 默认没有密码，回车即可登录 建立数据库$ mysql -u tws -p# 建立 twsdb 库mysql create database twsdb;# 创建 user 表mysql USE twsdb;mysql CREATE TABLE user( username char(50) NULL, passwd char(50) NULL)ENGINE=InnoDB;# 添加数据mysql INSERT INTO user(username, passwd) VALUES(admin, 123456); 编译代码修改 修改 main.cpp 中的如下内容: //需要修改的数据库信息,登录名,密码,库名string user = tws;string passwd = ;string databasename = twsdb; build$ chmod +x build.sh$ ./build.sh 运行run./server 服务访问 访问地址: http://127.0.0.1:9006/ 用户名: admin 密码：123456 其它MySQL 常用命令# 启动、关闭、重启 MySQL服务sudo service mysql startsudo service mysql stopsudo service mysql restart# 查看MySQL服务状态sudo service mysql status MySQL 用户认证方式查询$ sudo mysql -u rootmysql USE mysql;mysql SELECT User, Host, plugin FROM mysql.user;+------------------+-----------+-----------------------+| User | Host | plugin |+------------------+-----------+-----------------------+| debian-sys-maint | localhost | caching_sha2_password || mysql.infoschema | localhost | caching_sha2_password || mysql.session | localhost | caching_sha2_password || mysql.sys | localhost | caching_sha2_password || root | localhost | auth_socket || tws | localhost | auth_socket |+------------------+-----------+-----------------------+6 rows in set (0.00 sec) MySQL 删除用户mysql DROP USER tws@localhost;"},{"title":"功能梳理","path":"/wiki/cpp/tws-run.html","content":"00dd9c2c5c86dd0e1f8ce0e685de9f4ff0bd2a56b95edad86511c5d02f488f316760d7dce49fb836b51504758de8a211bcd2581eb7031339f7b407da5ff4892311b90f8085c0eb62976161580f45d9decaffdd630d0b7e470339139dd2bf6d39da932996dacfd2d0ac9ee14301c9aa0b551c4d96c7623025beaec65e203deb4cf73224719b44c3e4ea14b6bccb8ff50ffb7941f8393e53bdcbfdf526a403f8e5f8995133dfd83d3d6cb0b8a541804bceaa7f4c67d5db1dcb6f6a953b2c1ccaa42314d19667556223745996bc816d7e5698a572ded5593ef5e60eaebe1c202dafb1e6c7f41fac7c9fee6b8d711e30338dda764fc1239c4778854a251070b4834ca10cad61ae4a7d9976f56d0562a9548686a618c58319b5720b6004e6ce86de71e959ed53745df52a383d410ac18730d8b8ad1cec042e1e11b012cf8c631485a9dc49c6993bb17245ac555775f488fa21 Hey, password is required here."},{"title":"压测","path":"/wiki/cpp/tws-webbench.html","content":"保证 server 运行./server 压测$ cd test_pressure/webbench-1.5./webbench -c 500 -t 5 http://127.0.0.1:9006/Webbench - Simple Web Benchmark 1.5Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.Benchmarking: GET http://127.0.0.1:9006/1000 clients, running 5 sec.Speed=220188 pages/min, 411152 bytes/sec.Requests: 18349 susceed, 0 failed. QPS 是什么： QPS（Queries Per Second，每秒查询率）是衡量系统吞吐量的核心指标，代表服务器每秒能处理的有效请求数量。 QPS 如何计算： QPS = 总有效请求数 ÷ 总耗时（秒） 因此，上述压测的 QPS 18349 5 3669. webbench 原理 父进程 fork 若干个子进程，每个子进程在用户要求时间或默认的时间内，对目标 web 循环发出实际访问请求 父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息 子进程在时间到后结束；父进程在所有子进程退出后，统计并给用户显示最后的测试结果，然后退出"},{"title":"介绍","path":"/wiki/cpp/tws.html","content":"项目地址： https://github.com/qinguoyi/TinyWebServer 参考资料： https://deepwiki.com/qinguoyi/TinyWebServer 小白视角：一文读懂社长的TinyWebServer(Raw_Version) ZWiley的随记: WebServer项目"},{"title":"WSL 常用命令","path":"/wiki/cpp/wsl-cmd.html","content":"列出所有已安装的WSL发行版wsl --list --verbose 卸载某个WSL发行版wsl --unregister Ubuntu-18.04"},{"title":"WSL 开发环境配置","path":"/wiki/cpp/wsl-dev.html","content":"可根据需要选择安装 sudo apt install git cmake gdb build-essential clang clang-tidy \\ clang-format pkg-config tcpdump tshark"},{"title":"WSL 安装","path":"/wiki/cpp/wsl-install.html","content":"1. 以管理员身份打开 Windows PowerShell 启用 WSL 功能 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用虚拟机功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 2. 重启计算机3. 下载并安装 WSL 2 的 Linux 内核更新包 打开 PowerShell，运行以下命令 wsl --update 4. 设置 WSL 2 为默认版本 打开 PowerShell，运行以下命令 wsl --set-default-version 2 5. 通过 Microsoft Store 安装 Ubuntu 或其他 Linux 发行版 开始使用 WSL"},{"title":"bpftool","path":"/wiki/ebpf/bpftool.html","content":"将程序加载到内核中bpftool prog load hello.bpf.o /sys/fs/bpf/hello 查看已加载的程序bpftool prog list"},{"title":"WSL2 安装 BPF 工具链","path":"/wiki/ebpf/ebpf-install.html","content":"https://cardioid-line.github.io/ubuntu-an-zhuang-bcc-zhi-nan/"},{"title":"index","path":"/wiki/ebpf/ebpf.html","content":"todoWSL 安装 bcc web eBPF.io eBPF Developer Tutorial eBPF技术实践白皮书 blog 酷壳: eBPF 介绍 Learning eBPF the Hard Way: 从 nginx eBPF 的实现说起 BPF 学习路径总结 book Learning eBPF Learning eBPF Chinese version (⭐26) online version Learning eBPF Chinese version (⭐2)"},{"title":"02. eBPF’s “Hello World”","path":"/wiki/ebpf/learning-ebpf-02.html","content":"NOTE:Since eBPF is so powerful, it requires special privileges to use it. Privileges are automatically assigned to the root user, so the easiest way to run eBPF programs is as root, perhaps by using sudo. BCC’s “Hello World”int hello(void *ctx) bpf_trace_printk(Hello World!); return 0; All the eBPF program does is use a helper function, bpf_trace_printk(), to write a message. the bpf_trace_printk() helper function in the kernel always sends output to the same predefined pseudofile location: /sys/kernel/debug/tracing/trace_pipe. Running “Hello World”BPF Mapsa much better way to get information out of an eBPF program Hash Table MapTypical uses include the following: User space writing configuration information to be retrieved by an eBPF program An eBPF program storing state, for later retrieval by another eBPF program (or a future run of the same program) An eBPF program writing results or metrics into a map, for retrieval by the user space app that will present results BPF_HASH(counter_table);int hello(void *ctx) u64 uid; u64 counter = 0; u64 *p; uid = bpf_get_current_uid_gid() 0xFFFFFFFF; p = counter_table.lookup(uid); if (p != 0) counter = *p; counter++; counter_table.update(uid, counter); return 0; Perf and Ring Bufer MapsRing BuferBPF_PERF_OUTPUT(output); struct data_t int pid; int uid; char command[16]; char message[12];; int hello(void *ctx) struct data_t data = ; char message[12] = Hello World; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); bpf_probe_read_kernel(data.message, sizeof(data.message), message); output.perf_submit(ctx, data, sizeof(data)); return 0; Function Callsinlined function Tail Callstail calls can call and execute another eBPF program and replace the execution context, similar to how the execve() system call operates for regular processes. Tail calls allow for calling a series of functions without growing the stack. This is particularly useful in eBPF where the stack is limited to 512 bytes. Tail calls are made using the bpf_tail_call() helper function, which has the following signature: long bpf_tail_call(void *ctx, struct bpf_map *prog_array_map, u32 index) This helper is somewhat unusual in that if it succeeds, it never returns. The helper could fail, for example, if the indicated program doesn’t exist in the map, in which case the calling program carries on executing. BPF_PROG_ARRAY(syscall, 500);int hello(struct bpf_raw_tracepoint_args *ctx) int opcode = ctx-args[1]; syscall.call(ctx, opcode); bpf_trace_printk(Another syscall: %d, opcode); return 0;int hello_exec(void *ctx) bpf_trace_printk(Executing a program); return 0;int hello_timer(struct bpf_raw_tracepoint_args *ctx) int opcode = ctx-args[1]; switch (opcode) case 222: bpf_trace_printk(Creating a timer); break; case 226: bpf_trace_printk(Deleting a timer); break; default: bpf_trace_printk(Some other timer operation); break; return 0;int ignore_opcode(void *ctx) return 0; Summary"},{"title":"03. Anatomy of an eBPF Program","path":"/wiki/ebpf/learning-ebpf-03.html","content":"The eBPF Virtual MachineJIT (just-in-time) compilation eBPF RegistersThe eBPF virtual machine uses 10 general-purpose registers, numbered 0 to 9. Register 10 is used as a stack frame pointer (and can only be read, but not written). include/uapi/linux/bpf.h /* Register numbers */enum BPF_REG_0 = 0, // The return value from the function\tBPF_REG_1, // The context argument to an eBPF program\tBPF_REG_2,\tBPF_REG_3,\tBPF_REG_4,\tBPF_REG_5,\tBPF_REG_6,\tBPF_REG_7,\tBPF_REG_8,\tBPF_REG_9,\tBPF_REG_10,\t__MAX_BPF_REG,; Before calling a function from eBPF code, the arguments to that function are placed in Register 1 through Register 5 (not all the registers are used if there are fewer than five arguments). eBPF Instructions include/uapi/linux/bpf.h struct bpf_insn __u8\tcode; /* opcode */\t__u8\tdst_reg:4;\t/* dest register */\t__u8\tsrc_reg:4;\t/* source register */\t__s16\toff; /* signed offset */\t__s32\timm; /* signed immediate constant */; This bpf_insn structure is 64 bits (or 8 bytes) long. When loaded into the kernel, the bytecode of an eBPF program is represented by a series of these bpf_insn structures. eBPF “Hello World” for a Network Interface#include linux/bpf.h#include bpf/bpf_helpers.hint counter = 0;SEC(xdp)int hello(struct xdp_md *ctx) bpf_printk(Hello World %d, counter); counter++; return XDP_PASS;char LICENSE[] SEC(license) = Dual BSD/GPL; XDP_PASS: This is the verdict indicating to the kernel that it should process this network packet as normal. Compiling an eBPF Object File Makefile: %.bpf.o: %.bpf.c\tclang \\ -target bpf \\ -I/usr/include/$(shell uname -m)-linux-gnu \\ -g \\ -O2 -o $@ -c $ Inspecting an eBPF Object File$ llvm-objdump -S hello.bpf.o Loading the Program into the Kernel$ bpftool prog load hello.bpf.o /sys/fs/bpf/hello$ ls /sys/fs/bpfhello Inspecting the Loaded Program$ bpftool prog list $ bpftool prog show id 540 --pretty id: 540, type: xdp, name: hello, tag: d35b94b4c0c10efb, gpl_compatible: true, loaded_at: 1659461987, uid: 0, bytes_xlated: 96, jited: true, bytes_jited: 148, bytes_memlock: 4096, map_ids: [165,166 ], btf_id: 254 The BPF Program TagThe ID can vary every time you load or unload the program, but the tag will remain the same. bpftool prog show id 540bpftool prog show name hellobpftool prog show tag d35b94b4c0c10efbbpftool prog show pinned /sys/fs/bpf/hello The Translated Bytecode$ bpftool prog dump xlated name helloint hello(struct xdp_md * ctx):; bpf_printk(Hello World %d, counter); 0: (18) r6 = map[id:165][0]+0 2: (61) r3 = *(u32 *)(r6 +0) 3: (18) r1 = map[id:166][0]+0 5: (b7) r2 = 15 6: (85) call bpf_trace_printk#-78032; counter++; 7: (61) r1 = *(u32 *)(r6 +0) 8: (07) r1 += 1 9: (63) *(u32 *)(r6 +0) = r1; return XDP_PASS; 10: (b7) r0 = 2 11: (95) exit The JIT-Compiled Machine Code$ bpftool prog dump jited name helloint hello(struct xdp_md * ctx):bpf_prog_d35b94b4c0c10efb_hello:; bpf_printk(Hello World %d, counter); 0: hint #34 4: stp x29, x30, [sp, #-16]! 8: mov x29, sp c: stp x19, x20, [sp, #-16]! 10: stp x21, x22, [sp, #-16]! 14: stp x25, x26, [sp, #-16]! 18: mov x25, sp 1c: mov x26, #0 20: hint #36 24: sub sp, sp, #0 28: mov x19, #-140733193388033 2c: movk x19, #2190, lsl #16 30: movk x19, #49152 34: mov x10, #0 38: ldr w2, [x19, x10] 3c: mov x0, #-205419695833089 40: movk x0, #709, lsl #16 44: movk x0, #5904 48: mov x1, #15 4c: mov x10, #-6992 50: movk x10, #29844, lsl #16 54: movk x10, #56832, lsl #32 58: blr x10 5c: add x7, x0, #0; counter++; 60: mov x10, #0 64: ldr w0, [x19, x10] 68: add x0, x0, #1 6c: mov x10, #0 70: str w0, [x19, x10]; return XDP_PASS; 74: mov x7, #2 78: mov sp, sp 7c: ldp x25, x26, [sp], #16 80: ldp x21, x22, [sp], #16 84: ldp x19, x20, [sp], #16 88: ldp x29, x30, [sp], #16 8c: add x0, x7, #0 90: ret Attaching to an Event$ bpftool net attach xdp id 540 dev eth0 view all the network-attached eBPF programs: $ bpftool net listxdp:eth0(2) driver id 540tc:flow_dissector: $ ip link trace output: $ cat /sys/kernel/debug/tracing/trace_pipe or: $ bpftool prog tracelog Global Variables$ bpftool map list165: array name hello.bss flags 0x400 key 4B value 4B max_entries 1 memlock 4096B btf_id 254166: array name hello.rodata flags 0x80 key 4B value 15B max_entries 1 memlock 4096B btf_id 254 frozen inspect its contents: $ bpftool map dump name hello.bss[ value: .bss: [ counter: 11127 ] ] bpftool is able to pretty-print the field names from a map (here, the variable name counter) only if BTF information is available, and that information is included only if you compile with the -g flag. $ bpftool map dump name hello.rodata[ value: .rodata: [ hello.____fmt: Hello World %d ] ] Detaching the Program$ bpftool net detach xdp dev eth0 However, the program is still loaded into the kernel: $ bpftool prog show name hello395: xdp name hello tag 9d0e949f89f1a82c gpl loaded_at 2022-12-19T18:20:32+0000 uid 0 xlated 48B jited 108B memlock 4096B map_ids 4 Unloading the Program$ rm /sys/fs/bpf/hello$ bpftool prog show name hello BPF to BPF Callsa very simple function that extracts the syscall opcode from the tracepoint arguments: static __attribute((noinline)) int get_opcode(struct bpf_raw_tracepoint_args *ctx) return ctx-args[1]; The eBPF function that calls this function looks like this: SEC(raw_tp)int hello(struct bpf_raw_tracepoint_args *ctx) int opcode = get_opcode(ctx); bpf_printk(Syscall: %d, opcode); return 0; $ bpftool prog load hello-func.bpf.o /sys/fs/bpf/hello$ bpftool prog list name hello893: raw_tracepoint name hello tag 3d9eb0c23d4ab186 gpl loaded_at 2023-01-05T18:57:31+0000 uid 0 xlated 80B jited 208B memlock 4096B map_ids 204 btf_id 302 The interesting part of this exercise is inspecting the eBPF bytecode to see the get_opcode() function $ bpftool prog dump xlated name helloint hello(struct bpf_raw_tracepoint_args * ctx):; int opcode = get_opcode(ctx); # 1 0: (85) call pc+7#bpf_prog_cbacc90865b1b9a5_get_opcode; bpf_printk(Syscall: %d, opcode); 1: (18) r1 = map[id:193][0]+0 3: (b7) r2 = 12 4: (bf) r3 = r0 5: (85) call bpf_trace_printk#-73584; return 0; 6: (b7) r0 = 0 7: (95) exitint get_opcode(struct bpf_raw_tracepoint_args * ctx): # 2; return ctx-args[1]; 8: (79) r0 = *(u64 *)(r1 +8); return ctx-args[1]; 9: (95) exit"},{"title":"04. The bpf() System Call","path":"/wiki/ebpf/learning-ebpf-04.html","content":"the eBPF code running in the kernel does not use syscalls to access maps. eBPF programs use helper functions to read and write to maps bpf()’s signature: int bpf(int cmd, union bpf_attr *attr, unsigned int size); cmd, specifies which command to perform. attr, whatever data is needed to specify the parameters for the command size, how many bytes of data there are in attr struct user_msg_t // 1 char message[12];;BPF_HASH(config, u32, struct user_msg_t); // 2BPF_PERF_OUTPUT(output); // 3struct data_t // 4 int pid; int uid; char command[16]; char message[12];;int hello(void *ctx) // 5 struct data_t data = ; struct user_msg_t *p; char message[12] = Hello World; data.pid = bpf_get_current_pid_tgid() 32; data.uid = bpf_get_current_uid_gid() 0xFFFFFFFF; bpf_get_current_comm(data.command, sizeof(data.command)); p = config.lookup(data.uid); // 6 if (p != 0) bpf_probe_read_kernel(data.message, sizeof(data.message), p-message); else bpf_probe_read_kernel(data.message, sizeof(data.message), message); output.perf_submit(ctx, data, sizeof(data)); return 0; the bpf() system calls that are used when it runs $ strace -e bpf ./hello-buffer-config.py Loading BTF Data loading a blob of BTF data into the kernel the return code from the bpf() system call (3 in my example) is a file descriptor that refers to that data bpf(BPF_BTF_LOAD, btf=\\237\\353\\1\\0... , 40) = 3 BTF allows eBPF programs to be portable across different kernel versions so that you can compile a program on one machine and use it on another, which might be using a different kernel version and hence have different kernel data structures. Creating Maps creates an eBPF map bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_PERF_EVENT_ARRAY, key_size=4, value_size=4, max_entries=22, ... map_name=output, ..., 80) = 4 bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_HASH, key_size=4, value_size=13, max_entries=10240, ... map_name=config, ... btf_fd=3, ..., 80) = 5 Loading a Programbpf(BPF_PROG_LOAD, prog_type=BPF_PROG_TYPE_KPROBE, insn_cnt=47, insns=0x7408c9814000, license=GPL, ... prog_name=hello, ... expected_attach_type=BPF_CGROUP_INET_INGRESS, prog_btf_fd=3, ..., 152) = 6 Modifying a Map from User Spaceb[config][ct.c_int(0)] = ct.create_string_buffer(bHey root!)b[config][ct.c_int(501)] = ct.create_string_buffer(bHi user 501!) You can see these entries being defined in the map through syscalls like this: bpf(BPF_MAP_UPDATE_ELEM, map_fd=5, key=0x7408c92a9020, value=0x7408c92a8520, flags=BPF_ANY, 32) = 0 use bpftool to view the map’s contents bpftool map dump name config [ key: 0, value: message: Hey root! , key: 501, value: message: Hi user 501! ] BPF Program and Map References reference counts When there are no references left to a BPF program, the kernel removes the program. An additional reference is created when you pin a program to the filesystem. Pinningbpftool prog load hello.bpf.o /sys/fs/bpf/hello These pinned objects aren’t real files persisted to disk. They are held in memory, which means they will not remain in place over a system reboot. Programs that are attached within the network stack or cgroups (short for “control groups”) aren’t associated with any user space process, so they stay in place even after the user space program that loads them exits. ip link set dev eth0 xdp obj hello.bpf.o sec xdp BPF LinksAnother way to create a reference to a BPF program BPF links provide a layer of abstraction between an eBPF program and the event it’s attached to. Additional Syscalls Involved in eBPFInitializing the Perf Buferbpf(BPF_MAP_UPDATE_ELEM, map_fd=4, key=0x770d75d708a0, value=0x770d75d70520, flags=BPF_ANY, 32) = 0 strace to show a few more syscalls when running this example, strace -e bpf,perf_event_open,ioctl,ppoll ./hello-buffer-config.py Attaching to Kprobe Eventsa file descriptor representing that particular event perf_event_open(type=0x8 /* PERF_TYPE_??? */, ..., ...) = 7 the value 6 to indicate that it’s a kprobe type of perf event $ cat /sys/bus/event_source/devices/kprobe/type attaching a Berkeley Packet Filter (BPF) program to an existing kprobe tracepoint event: ioctl(7, PERF_EVENT_IOC_SET_BPF, 6) = 0 turns the kprobe event on: ioctl(7, PERF_EVENT_IOC_ENABLE, 0) = 0 Setting Up and Reading Perf EventsNOTE:与使用的处理器的核心数量有关 perf_event_open(type=PERF_TYPE_SOFTWARE, size=0 /* PERF_ATTR_SIZE_??? */, config=PERF_COUNT_SW_BPF_OUTPUT, ..., -1, X, -1, PERF_FLAG_FD_CLOEXEC) = 8ioctl(Y, PERF_EVENT_IOC_ENABLE, 0) = 0bpf(BPF_MAP_UPDATE_ELEM, map_fd=4, key=0x7644407f88a0, value=0x7644407f8520, flags=BPF_ANY, 32) = 0 User space code can then use ppoll() on all four of these output stream file descriptors so that it can get the data output ppoll([fd=8, events=POLLIN, fd=9, events=POLLIN, fd=10, events=POLLIN,fd=11, events=POLLIN], 4, NULL, NULL, 0) = 1 ([fd=8, revents=POLLIN]) You won’t see the return code written to the screen until something triggers execve(), which causes the eBPF program to write data that user space retrieves using this ppoll() call. Ring Bufersring buffers are preferred over perf buffers partly for performance reasons The bpf() syscall that creates the output ring buffer map: bpf(BPF_MAP_CREATE, map_type=BPF_MAP_TYPE_RINGBUF, key_size=0, value_size=0, max_entries=4096, ..., map_name=output, ..., 80) = 4 For a ring buffer, there’s just the one file descriptor shared across all CPU cores. Reading Information from a Mapan extract of the bpf() syscalls that bpftool makes while reading the contents of the config map: strace -e bpf bpftool map dump name config Finding a Mapbpftool walks through all the maps looking for any with the name config bpf(BPF_MAP_GET_NEXT_ID, start_id=0, ..., 12) = 0bpf(BPF_MAP_GET_FD_BY_ID, map_id=25, ..., 12) = 3bpf(BPF_OBJ_GET_INFO_BY_FD, info=bpf_fd=3, ..., 16) = 0bpf(BPF_MAP_GET_NEXT_ID, start_id=25, ..., 12) = 0bpf(BPF_MAP_GET_FD_BY_ID, map_id=26, ..., 12) = 3bpf(BPF_OBJ_GET_INFO_BY_FD, info=bpf_fd=3, ..., 16) = 0 Reading Map Elementsbpf(BPF_MAP_GET_NEXT_KEY, map_fd=3, key=NULL, next_key=0x5897d6dd81c0, 24) = 0bpf(BPF_MAP_LOOKUP_ELEM, map_fd=3, key=0x5897d6dd81c0, value=0x5897d6dd81e0, flags=BPF_ANY, 32) = 0 [ key: 0, value: message: Hey root! bpf(BPF_MAP_GET_NEXT_KEY, map_fd=3, key=0x5897d6dd81c0, next_key=0x5897d6dd81c0, 24) = -1 ENOENT (No such file or directory) ]+++ exited with 0 +++ Summarytodo Exercisestodo QA 我在运行 strace -e bpf,perf_event_open,ioctl,ppoll ./hello-buffer-config.py 时，并没有看到 ppoll 的相关调用 可能调用的是 poll poll([fd=8, events=POLLIN, fd=9, events=POLLIN, ...], 22, -1) = 1 ([fd=23, revents=POLLIN])"},{"title":"介绍","path":"/wiki/wlan/index.html","content":"131fd7c5506bb654a6cea69bbe40f3df7da318ecb0403b621d8f115b1f8d302bf6a9a4d5270b84db0e87e59dfe247981efcd8281284099f469b4b4e8f634e868e4671607d4a31592aeff9d649d1e0407bd7e1bc1cbf54d87af3576a02bf8498f2fdbb69f3bef66d718f02ef934c3851bd23c8b140d894efd71c93d3642f3d411603562ce7eae6717ce330a06cf6eef7c9fa36333050b55caf8efd91b39b2131d1ca0948aed75e43787b7163c54d62c027a420ed131665238b87de39ae2d8e7ea6de41a1dce92224b92bf589d1873a158e5371aa4880c0094095609838fe2e76e080c6da16ab74a1c3fb0a14928da5d400cae7a12bcbac5d2c250f791b0d46a905a1381a271cb7eadb98ee1a4ba97835872b4e4626f7f80e727fb3d49ac05760febd85438206bdaa6a09be2f192edce456b782bf63d57da24f8155c5a791e52bd98185580ce691b8734808d92a88dbe0fbd732db0e73c764cae2beb80797ca8b8549a8c76a648b2b16c6aa5137e5ffedbff4ee147d5370a5810ccadb61942ad69cdb241911353fd464bdeda402d9e2404ea735852a7ab9e75f56ba829952669402b15f9ec52fd0bdf7d7f3d42d9bb0534a4f92300fa7ee6df8ec6d9ce9824609e3ff230f3c258ff46f17db7c311c9c10da218083eb5c2e403ca9f838a3f6f12f33df838fe76844e1779e468c512c7ce776b1aa612d330eb79054415608982b02000de020ab1ea2c02648772eb593f4624491a5b891cd162e4d443b97876b9546a7d021109b2f3cfcdd5630fd22a942f99cbd3157ab67a087702322dbead0a1a138b435b2f9d042589146bc194902d9c3537ae34d1e31833f91942f651422588db2159b26ab4d559d936f5f1721af6734d4af09768a65b16c6dbde939c2ad0a1e11c468544ca73bf243cecefb148dbe95b67b1468d80cb31b761291734bc708a3ac7ae9753f5a43d91766afbb254e7a389db40c0a71d272b1471ecf95ab18a890f2ca583102cd106b2a05b54a35b70e1934423975409558894b6a5ddf15164d9ad5c2d67134f1020617df33294d76d15bac449b71ed633afbf4f593655f4df7c913309c76c2cad2aee207071e1f0aecb1cbdb712ff5e87049ffbe1027f1af47000a65a71ab1522e2b93164e02d7a774d54294b9d018945bb633bf0114e375758dd0ec034faa896a8b3a715dbec5c5c8168daff0fefc37a516803e2c1354d26123d0fcb94d23a4cb2dd459d1532d89216f9fe744434257971cd4be4dc3013e22b0cafee42b89aa3a52af0c8518701048962258e1375d2e40e07c75b3d7a21f2c51bee8749659ebdc0b694c5fccd75cf860964b83be091c5e020e6a2ce3f5605890c84a5d717d22ce483b18fe614cc2933b455d495c62843ef750b96c066456d8dcd421a90ee61e3994d32df1c8cd2774877dea24302089cf59f1e0987f4c7e76d116e0b5897c6086c71bbc87020f5c7efeec606db70012ac0b2362d8c32223eb8257e03abe7948e9e5ef3cb1969ba05dcd5d20af794bee131bfd0a41228fe3e6e5559d3b6e82a5d9a220910f7a8cab8089739e36933e285fa9c11c288a19a2dae2b8e51e9416c273d23d8761e2a8c9b21d945db73b8b7d483056f8ffe19cfb02becb4ed3d02da0edf91f74aed61fedb53c884924d501e17f0850b314ac207a148de8786d9909e069ecf0ef493af008ad9f44bf52356e838d561e3f6800a55484ac8d75ea84320f27d05e85a31c910f46e78e2f8ff099dbc93fb11808bc40b60e5cce87f1c51d9c404f79b33df7ddc4102a5b2365ba7b63f7a8d7f906b1a3040baddb5e858d3a9516737a32fedb89a38a7f55c9aebf6b1d975f063f4f9a0abf6014bd7741ed25df7724b6c8443c0d8f078b9959f94679c597cb1f32b1f26d7b8a1b728d614b89fabec5d47d400e2c098bb4904449e69261a62660d365ff35e49c7051a9cd85dc4022ad9eb44a3a795a2d007462b1d0f4e022691bd962106536039145c7d8826acfd432d057e99269f31ae805103d24c25cb6e244b151d070ecb5bcc75130ef7513bcb1d3eccfdcfc7720641120dbb3d2d9e30bb3cd2cc34e1d69dd0e5197c02774eb887dce80799de00465f0c230b9901908f20d399adc2ef6387f72d55a2f26f3f17add585d64da9967ce58a2ee6b8f6c39e7737686e7de74c4747daea0576d18d34feb2b423700764ec2dc56a8b1d3dc26dbd10ca477257077bedbd5f4c01a507c1ce7fa3c08efbfec1a7dd56794cfbad6457dcc7e3507238920beb3856e6916f2a52f525b0a277cfcbb24dc77827c35be75bbd87e6047d563d6eac2f271b6329783a024d1a7efd49580ff58df3531df32b6e66d4caa20bbba3fdd489f9df7b8ad76df863e510e293b0b92dfdfd637eb82b287114935630f018d11dedd806d0d3a88cfbbf112cfe4f64fe58d02fd38a14893bcbf57c57648c67d21167c1f5cfefaedf6e19a059340b53e966cd58fdf1ebd06d05998fa64f05d3410de89f4d6a137cded66dbc5cbb176958a7005141efa5ba41194a6ff74244d12e6c1d6f07008c08bb44f04db7cabc9ad811758f40a319205a90eba1f9991f0a12d5e1c37fdfc3a7742a97fa2266c1e5c569c451c05b3fed136e0fdbbfeea9bcb5e7a7aefdea7abe179f6f0069646f9893e7bd1f814a1d01f185a58257171fdd44 Hey, password is required here."},{"title":"光猫","path":"/wiki/wlan/cmcc.html","content":"如何获取联通光猫管理员密码 在地址栏 192.168.1.1 后面加上 /backupsettings.conf 把这个文件用记事本打开，找到 Adminpassword 一行后面的就是了"},{"title":"路由器","path":"/wiki/wlan/router.html","content":"123"}]